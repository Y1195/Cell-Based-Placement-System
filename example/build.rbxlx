<roblox version="4">
  <Item class="Workspace" referent="0">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="AllowThirdPartySales">false</bool>
      <token name="AnimationWeightedBlendFix">0</token>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <token name="ClientAnimatorThrottling">0</token>
      <string name="CollisionGroups">Default^0^-1</string>
      <Ref name="CurrentCamera">1</Ref>
      <double name="DistributedGameTime">0</double>
      <bool name="ExplicitAutoJoints">true</bool>
      <float name="FallenPartsDestroyHeight">-500</float>
      <Vector3 name="GlobalWind">
        <X>0</X>
        <Y>0</Y>
        <Z>0</Z>
      </Vector3>
      <float name="Gravity">196.2</float>
      <token name="HumanoidOnlySetCollisionsOnStateChange">0</token>
      <token name="InterpolationThrottling">0</token>
      <token name="LevelOfDetail">0</token>
      <token name="MeshPartHeadsAndAccessories">0</token>
      <CoordinateFrame name="ModelMeshCFrame">
        <X>0</X>
        <Y>0</Y>
        <Z>0</Z>
        <R00>1</R00>
        <R01>0</R01>
        <R02>0</R02>
        <R10>0</R10>
        <R11>1</R11>
        <R12>0</R12>
        <R20>0</R20>
        <R21>0</R21>
        <R22>1</R22>
      </CoordinateFrame>
      <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
      <Vector3 name="ModelMeshSize">
        <X>0</X>
        <Y>0</Y>
        <Z>0</Z>
      </Vector3>
      <bool name="NeedsPivotMigration">false</bool>
      <token name="PhysicsInertiaAndVolumeFix">0</token>
      <token name="PhysicsSteppingMethod">0</token>
      <Ref name="PrimaryPart">null</Ref>
      <token name="ReplicateInstanceDestroySetting">0</token>
      <token name="Retargeting">0</token>
      <token name="SignalBehavior">0</token>
      <int64 name="SourceAssetId">-1</int64>
      <token name="StreamOutBehavior">0</token>
      <bool name="StreamingEnabled">false</bool>
      <int name="StreamingMinRadius">64</int>
      <token name="StreamingPauseMode">0</token>
      <int name="StreamingTargetRadius">1024</int>
      <BinaryString name="Tags"></BinaryString>
      <bool name="TerrainWeldsFixed">true</bool>
      <bool name="TouchesUseCollisionGroups">false</bool>
      <OptionalCoordinateFrame name="WorldPivotData">
        <CFrame>
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CFrame>
      </OptionalCoordinateFrame>
    </Properties>
    <Item class="Part" referent="2">
      <Properties>
        <string name="Name">Baseplate</string>
        <bool name="Anchored">true</bool>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <float name="BackParamA">-0.5</float>
        <float name="BackParamB">0.5</float>
        <token name="BackSurface">0</token>
        <token name="BackSurfaceInput">0</token>
        <float name="BottomParamA">-0.5</float>
        <float name="BottomParamB">0.5</float>
        <token name="BottomSurface">0</token>
        <token name="BottomSurfaceInput">0</token>
        <CoordinateFrame name="CFrame">
          <X>0</X>
          <Y>-8</Y>
          <Z>0</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CoordinateFrame>
        <bool name="CanCollide">true</bool>
        <bool name="CanQuery">true</bool>
        <bool name="CanTouch">true</bool>
        <bool name="CastShadow">true</bool>
        <int name="CollisionGroupId">0</int>
        <Color3uint8 name="Color3uint8">5987163</Color3uint8>
        <PhysicalProperties name="CustomPhysicalProperties">
          <CustomPhysics>false</CustomPhysics>
        </PhysicalProperties>
        <token name="formFactorRaw">0</token>
        <float name="FrontParamA">-0.5</float>
        <float name="FrontParamB">0.5</float>
        <token name="FrontSurface">0</token>
        <token name="FrontSurfaceInput">0</token>
        <float name="LeftParamA">-0.5</float>
        <float name="LeftParamB">0.5</float>
        <token name="LeftSurface">0</token>
        <token name="LeftSurfaceInput">0</token>
        <bool name="Locked">true</bool>
        <bool name="Massless">false</bool>
        <token name="Material">256</token>
        <BinaryString name="MaterialVariantSerialized">
        </BinaryString>
        <CoordinateFrame name="PivotOffset">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CoordinateFrame>
        <float name="Reflectance">0</float>
        <float name="RightParamA">-0.5</float>
        <float name="RightParamB">0.5</float>
        <token name="RightSurface">0</token>
        <token name="RightSurfaceInput">0</token>
        <int name="RootPriority">0</int>
        <Vector3 name="RotVelocity">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
        </Vector3>
        <token name="shape">1</token>
        <Vector3 name="size">
          <X>2048</X>
          <Y>16</Y>
          <Z>2048</Z>
        </Vector3>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <float name="TopParamA">-0.5</float>
        <float name="TopParamB">0.5</float>
        <token name="TopSurface">0</token>
        <token name="TopSurfaceInput">0</token>
        <float name="Transparency">0</float>
        <Vector3 name="Velocity">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
        </Vector3>
      </Properties>
      <Item class="Texture" referent="3">
        <Properties>
          <string name="Name">Texture</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Color3 name="Color3">
            <R>0</R>
            <G>0</G>
            <B>0</B>
          </Color3>
          <token name="Face">1</token>
          <float name="OffsetStudsU">0</float>
          <float name="OffsetStudsV">0</float>
          <int64 name="SourceAssetId">-1</int64>
          <float name="StudsPerTileU">8</float>
          <float name="StudsPerTileV">8</float>
          <BinaryString name="Tags"></BinaryString>
          <Content name="Texture">
            <url>rbxassetid://6372755229</url>
          </Content>
          <float name="Transparency">0.8</float>
          <int name="ZIndex">1</int>
        </Properties>
      </Item>
    </Item>
    <Item class="Terrain" referent="4">
      <Properties>
        <string name="Name">Terrain</string>
        <token name="AcquisitionMethod">0</token>
        <bool name="Anchored">true</bool>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <float name="BackParamA">-0.5</float>
        <float name="BackParamB">0.5</float>
        <token name="BackSurface">0</token>
        <token name="BackSurfaceInput">0</token>
        <float name="BottomParamA">-0.5</float>
        <float name="BottomParamB">0.5</float>
        <token name="BottomSurface">4</token>
        <token name="BottomSurfaceInput">0</token>
        <CoordinateFrame name="CFrame">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CoordinateFrame>
        <bool name="CanCollide">true</bool>
        <bool name="CanQuery">true</bool>
        <bool name="CanTouch">true</bool>
        <bool name="CastShadow">true</bool>
        <int name="CollisionGroupId">0</int>
        <Color3uint8 name="Color3uint8">10724005</Color3uint8>
        <PhysicalProperties name="CustomPhysicalProperties">
          <CustomPhysics>false</CustomPhysics>
        </PhysicalProperties>
        <bool name="Decoration">false</bool>
        <float name="FrontParamA">-0.5</float>
        <float name="FrontParamB">0.5</float>
        <token name="FrontSurface">0</token>
        <token name="FrontSurfaceInput">0</token>
        <float name="LeftParamA">-0.5</float>
        <float name="LeftParamB">0.5</float>
        <token name="LeftSurface">0</token>
        <token name="LeftSurfaceInput">0</token>
        <bool name="Locked">true</bool>
        <bool name="Massless">false</bool>
        <token name="Material">256</token>
        <BinaryString name="MaterialColors"><![CDATA[AAAAAAAAucpXcXNvnZ6YimFJ7N+4rIpgk5SV2OLw////q4JghHtgVlle38+WujQAV1lep6J82OLwwd1d3djTzr2fyMi+]]></BinaryString>
        <BinaryString name="MaterialVariantSerialized">
        </BinaryString>
        <BinaryString name="PhysicsGrid"><![CDATA[AgMAAAAAAAAAAAAAAAA=]]></BinaryString>
        <CoordinateFrame name="PivotOffset">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CoordinateFrame>
        <float name="Reflectance">0</float>
        <float name="RightParamA">-0.5</float>
        <float name="RightParamB">0.5</float>
        <token name="RightSurface">0</token>
        <token name="RightSurfaceInput">0</token>
        <int name="RootPriority">0</int>
        <Vector3 name="RotVelocity">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
        </Vector3>
        <Vector3 name="size">
          <X>2044</X>
          <Y>252</Y>
          <Z>2044</Z>
        </Vector3>
        <BinaryString name="SmoothGrid"><![CDATA[AQU=]]></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <float name="TopParamA">-0.5</float>
        <float name="TopParamB">0.5</float>
        <token name="TopSurface">3</token>
        <token name="TopSurfaceInput">0</token>
        <float name="Transparency">0</float>
        <Vector3 name="Velocity">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
        </Vector3>
        <Color3 name="WaterColor">
          <R>0.04705883</R>
          <G>0.32941177</G>
          <B>0.36078432</B>
        </Color3>
        <float name="WaterReflectance">1</float>
        <float name="WaterTransparency">0.3</float>
        <float name="WaterWaveSize">0.15</float>
        <float name="WaterWaveSpeed">10</float>
      </Properties>
    </Item>
    <Item class="SpawnLocation" referent="5">
      <Properties>
        <string name="Name">SpawnLocation</string>
        <bool name="AllowTeamChangeOnTouch">false</bool>
        <bool name="Anchored">true</bool>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <float name="BackParamA">-0.5</float>
        <float name="BackParamB">0.5</float>
        <token name="BackSurface">0</token>
        <token name="BackSurfaceInput">0</token>
        <float name="BottomParamA">-0.5</float>
        <float name="BottomParamB">0.5</float>
        <token name="BottomSurface">0</token>
        <token name="BottomSurfaceInput">0</token>
        <CoordinateFrame name="CFrame">
          <X>0</X>
          <Y>0.5</Y>
          <Z>0</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CoordinateFrame>
        <bool name="CanCollide">true</bool>
        <bool name="CanQuery">true</bool>
        <bool name="CanTouch">true</bool>
        <bool name="CastShadow">false</bool>
        <int name="CollisionGroupId">0</int>
        <Color3uint8 name="Color3uint8">10724005</Color3uint8>
        <PhysicalProperties name="CustomPhysicalProperties">
          <CustomPhysics>false</CustomPhysics>
        </PhysicalProperties>
        <int name="Duration">0</int>
        <bool name="Enabled">true</bool>
        <token name="formFactorRaw">1</token>
        <float name="FrontParamA">-0.5</float>
        <float name="FrontParamB">0.5</float>
        <token name="FrontSurface">0</token>
        <token name="FrontSurfaceInput">0</token>
        <float name="LeftParamA">-0.5</float>
        <float name="LeftParamB">0.5</float>
        <token name="LeftSurface">0</token>
        <token name="LeftSurfaceInput">0</token>
        <bool name="Locked">true</bool>
        <bool name="Massless">false</bool>
        <token name="Material">256</token>
        <BinaryString name="MaterialVariantSerialized">
        </BinaryString>
        <bool name="Neutral">true</bool>
        <CoordinateFrame name="PivotOffset">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CoordinateFrame>
        <float name="Reflectance">0</float>
        <float name="RightParamA">-0.5</float>
        <float name="RightParamB">0.5</float>
        <token name="RightSurface">0</token>
        <token name="RightSurfaceInput">0</token>
        <int name="RootPriority">0</int>
        <Vector3 name="RotVelocity">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
        </Vector3>
        <token name="shape">1</token>
        <Vector3 name="size">
          <X>12</X>
          <Y>1</Y>
          <Z>12</Z>
        </Vector3>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <int name="TeamColor">194</int>
        <float name="TopParamA">-0.5</float>
        <float name="TopParamB">0.5</float>
        <token name="TopSurface">0</token>
        <token name="TopSurfaceInput">0</token>
        <float name="Transparency">0</float>
        <Vector3 name="Velocity">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
        </Vector3>
      </Properties>
      <Item class="Decal" referent="6">
        <Properties>
          <string name="Name">Decal</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Color3 name="Color3">
            <R>1</R>
            <G>1</G>
            <B>1</B>
          </Color3>
          <token name="Face">1</token>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
          <Content name="Texture">
            <url>rbxasset://textures/SpawnLocation.png</url>
          </Content>
          <float name="Transparency">0</float>
          <int name="ZIndex">1</int>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="7">
      <Properties>
        <string name="Name">Plots</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="Folder" referent="8">
        <Properties>
          <string name="Name">Plot</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags">UGxvdA==</BinaryString>
        </Properties>
        <Item class="Model" referent="9">
          <Properties>
            <string name="Name">Grid</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <token name="LevelOfDetail">0</token>
            <CoordinateFrame name="ModelMeshCFrame">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
            <Vector3 name="ModelMeshSize">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <bool name="NeedsPivotMigration">false</bool>
            <Ref name="PrimaryPart">10</Ref>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <OptionalCoordinateFrame name="WorldPivotData">
              <CFrame>
                <X>-24</X>
                <Y>0</Y>
                <Z>-60</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CFrame>
            </OptionalCoordinateFrame>
          </Properties>
          <Item class="Part" referent="10">
            <Properties>
              <string name="Name">Part</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>0</X>
                <Y>0.5</Y>
                <Z>-40</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">false</bool>
              <bool name="CanTouch">false</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">16711871</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">true</bool>
              <token name="Material">256</token>
              <BinaryString name="MaterialVariantSerialized">
              </BinaryString>
              <CoordinateFrame name="PivotOffset">
                <X>-24</X>
                <Y>-0.5</Y>
                <Z>-20</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>48</X>
                <Y>1</Y>
                <Z>40</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0.75</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="11">
        <Properties>
          <string name="Name">Plot</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags">UGxvdA==</BinaryString>
        </Properties>
        <Item class="Model" referent="12">
          <Properties>
            <string name="Name">Grid</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <token name="LevelOfDetail">0</token>
            <CoordinateFrame name="ModelMeshCFrame">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
            <Vector3 name="ModelMeshSize">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <bool name="NeedsPivotMigration">false</bool>
            <Ref name="PrimaryPart">13</Ref>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <OptionalCoordinateFrame name="WorldPivotData">
              <CFrame>
                <X>-72</X>
                <Y>0</Y>
                <Z>-20</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CFrame>
            </OptionalCoordinateFrame>
          </Properties>
          <Item class="Part" referent="13">
            <Properties>
              <string name="Name">Part</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-48</X>
                <Y>0.5</Y>
                <Z>0</Z>
                <R00>0</R00>
                <R01>0</R01>
                <R02>1</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>-1</R20>
                <R21>0</R21>
                <R22>0</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">false</bool>
              <bool name="CanTouch">false</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">16711871</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">true</bool>
              <token name="Material">256</token>
              <BinaryString name="MaterialVariantSerialized">
              </BinaryString>
              <CoordinateFrame name="PivotOffset">
                <X>-24</X>
                <Y>-0.5</Y>
                <Z>-20</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>48</X>
                <Y>1</Y>
                <Z>40</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0.75</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="14">
        <Properties>
          <string name="Name">Plot</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags">UGxvdA==</BinaryString>
        </Properties>
        <Item class="Model" referent="15">
          <Properties>
            <string name="Name">Grid</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <token name="LevelOfDetail">0</token>
            <CoordinateFrame name="ModelMeshCFrame">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
            <Vector3 name="ModelMeshSize">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <bool name="NeedsPivotMigration">false</bool>
            <Ref name="PrimaryPart">16</Ref>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <OptionalCoordinateFrame name="WorldPivotData">
              <CFrame>
                <X>68</X>
                <Y>0</Y>
                <Z>-24</Z>
                <R00>0</R00>
                <R01>0</R01>
                <R02>-1</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>1</R20>
                <R21>0</R21>
                <R22>0</R22>
              </CFrame>
            </OptionalCoordinateFrame>
          </Properties>
          <Item class="Part" referent="16">
            <Properties>
              <string name="Name">Part</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>48</X>
                <Y>0.5</Y>
                <Z>0</Z>
                <R00>0</R00>
                <R01>0</R01>
                <R02>-1</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>1</R20>
                <R21>0</R21>
                <R22>0</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">false</bool>
              <bool name="CanTouch">false</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">16711871</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">true</bool>
              <token name="Material">256</token>
              <BinaryString name="MaterialVariantSerialized">
              </BinaryString>
              <CoordinateFrame name="PivotOffset">
                <X>-24</X>
                <Y>-0.5</Y>
                <Z>-20</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>48</X>
                <Y>1</Y>
                <Z>40</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0.75</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="17">
        <Properties>
          <string name="Name">Plot</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags">UGxvdA==</BinaryString>
        </Properties>
        <Item class="Model" referent="18">
          <Properties>
            <string name="Name">Grid</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <token name="LevelOfDetail">0</token>
            <CoordinateFrame name="ModelMeshCFrame">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
            <Vector3 name="ModelMeshSize">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <bool name="NeedsPivotMigration">false</bool>
            <Ref name="PrimaryPart">19</Ref>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <OptionalCoordinateFrame name="WorldPivotData">
              <CFrame>
                <X>24</X>
                <Y>0</Y>
                <Z>60</Z>
                <R00>-1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>-1</R22>
              </CFrame>
            </OptionalCoordinateFrame>
          </Properties>
          <Item class="Part" referent="19">
            <Properties>
              <string name="Name">Part</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>0</X>
                <Y>0.5</Y>
                <Z>40</Z>
                <R00>-1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>-1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CanQuery">false</bool>
              <bool name="CanTouch">false</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">16711871</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">true</bool>
              <token name="Material">256</token>
              <BinaryString name="MaterialVariantSerialized">
              </BinaryString>
              <CoordinateFrame name="PivotOffset">
                <X>-24</X>
                <Y>-0.5</Y>
                <Z>-20</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>48</X>
                <Y>1</Y>
                <Z>40</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0.75</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="Camera" referent="1">
      <Properties>
        <string name="Name">Camera</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <CoordinateFrame name="CFrame">
          <X>0</X>
          <Y>20</Y>
          <Z>20</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>-0</R02>
          <R10>-0</R10>
          <R11>0.7808688</R11>
          <R12>0.62469506</R12>
          <R20>0</R20>
          <R21>-0.62469506</R21>
          <R22>0.7808688</R22>
        </CoordinateFrame>
        <Ref name="CameraSubject">null</Ref>
        <token name="CameraType">0</token>
        <float name="FieldOfView">70</float>
        <token name="FieldOfViewMode">0</token>
        <CoordinateFrame name="Focus">
          <X>0</X>
          <Y>0</Y>
          <Z>-5</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CoordinateFrame>
        <bool name="HeadLocked">true</bool>
        <float name="HeadScale">1</float>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
  </Item>
  <Item class="SoundService" referent="20">
    <Properties>
      <string name="Name">SoundService</string>
      <token name="AmbientReverb">0</token>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <float name="DistanceFactor">3.33</float>
      <float name="DopplerScale">1</float>
      <bool name="RespectFilteringEnabled">true</bool>
      <float name="RolloffScale">1</float>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="NonReplicatedCSGDictionaryService" referent="21">
    <Properties>
      <string name="Name">NonReplicatedCSGDictionaryService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="CSGDictionaryService" referent="22">
    <Properties>
      <string name="Name">CSGDictionaryService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Chat" referent="23">
    <Properties>
      <string name="Name">Chat</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="BubbleChatEnabled">true</bool>
      <bool name="LoadDefaultChat">true</bool>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="TimerService" referent="24">
    <Properties>
      <string name="Name">Instance</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Players" referent="25">
    <Properties>
      <string name="Name">Players</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="CharacterAutoLoads">true</bool>
      <int name="MaxPlayersInternal">30</int>
      <int name="PreferredPlayersInternal">30</int>
      <float name="RespawnTime">3</float>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="ReplicatedFirst" referent="26">
    <Properties>
      <string name="Name">ReplicatedFirst</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
    <Item class="Folder" referent="27">
      <Properties>
        <string name="Name">Game</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
  </Item>
  <Item class="TweenService" referent="28">
    <Properties>
      <string name="Name">TweenService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="MaterialService" referent="29">
    <Properties>
      <string name="Name">MaterialService</string>
      <string name="AsphaltName">Asphalt</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <string name="BasaltName">Basalt</string>
      <string name="BrickName">Brick</string>
      <string name="CobblestoneName">Cobblestone</string>
      <string name="ConcreteName">Concrete</string>
      <string name="CorrodedMetalName">CorrodedMetal</string>
      <string name="CrackedLavaName">CrackedLava</string>
      <string name="DiamondPlateName">DiamondPlate</string>
      <string name="FabricName">Fabric</string>
      <string name="FoilName">Foil</string>
      <string name="GlacierName">Glacier</string>
      <string name="GraniteName">Granite</string>
      <string name="GrassName">Grass</string>
      <string name="GroundName">Ground</string>
      <string name="IceName">Ice</string>
      <string name="LeafyGrassName">LeafyGrass</string>
      <string name="LimestoneName">Limestone</string>
      <string name="MarbleName">Marble</string>
      <string name="MetalName">Metal</string>
      <string name="MudName">Mud</string>
      <string name="PavementName">Pavement</string>
      <string name="PebbleName">Pebble</string>
      <string name="PlasticName">Plastic</string>
      <string name="RockName">Rock</string>
      <string name="SaltName">Salt</string>
      <string name="SandName">Sand</string>
      <string name="SandstoneName">Sandstone</string>
      <string name="SlateName">Slate</string>
      <string name="SmoothPlasticName">SmoothPlastic</string>
      <string name="SnowName">Snow</string>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
      <bool name="Use2022MaterialsXml">true</bool>
      <string name="WoodName">Wood</string>
      <string name="WoodPlanksName">WoodPlanks</string>
    </Properties>
  </Item>
  <Item class="TextChatService" referent="30">
    <Properties>
      <string name="Name">TextChatService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <token name="ChatVersion">0</token>
      <bool name="CreateDefaultCommands">true</bool>
      <bool name="CreateDefaultTextChannels">true</bool>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
    <Item class="ChatWindowConfiguration" referent="31">
      <Properties>
        <string name="Name">ChatWindowConfiguration</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <bool name="Enabled">true</bool>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
    <Item class="ChatInputBarConfiguration" referent="32">
      <Properties>
        <string name="Name">ChatInputBarConfiguration</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <bool name="Enabled">true</bool>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <Ref name="TargetTextChannel">null</Ref>
      </Properties>
    </Item>
  </Item>
  <Item class="PermissionsService" referent="33">
    <Properties>
      <string name="Name">PermissionsService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="PlayerEmulatorService" referent="34">
    <Properties>
      <string name="Name">PlayerEmulatorService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="CustomPoliciesEnabled">false</bool>
      <string name="EmulatedCountryCode"></string>
      <string name="EmulatedGameLocale"></string>
      <bool name="PlayerEmulationEnabled">false</bool>
      <BinaryString name="SerializedEmulatedPolicyInfo">
      </BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="StudioData" referent="35">
    <Properties>
      <string name="Name">StudioData</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="CommitInflightAuthorId">0</int64>
      <BinaryString name="CommitInflightGuid">
      </BinaryString>
      <int name="CommitInflightPlaceVersion">0</int>
      <bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
      <int64 name="SourceAssetId">-1</int64>
      <int64 name="SrcPlaceId">9919885263</int64>
      <int64 name="SrcUniverseId">3660747836</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="36">
    <Properties>
      <string name="Name">StarterPlayer</string>
      <bool name="AllowCustomAnimations">true</bool>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="AutoJumpEnabled">true</bool>
      <float name="CameraMaxZoomDistance">128</float>
      <float name="CameraMinZoomDistance">0.5</float>
      <token name="CameraMode">0</token>
      <float name="CharacterJumpHeight">7.2</float>
      <float name="CharacterJumpPower">50</float>
      <float name="CharacterMaxSlopeAngle">89</float>
      <bool name="CharacterUseJumpPower">false</bool>
      <float name="CharacterWalkSpeed">16</float>
      <token name="DevCameraOcclusionMode">0</token>
      <token name="DevComputerCameraMovementMode">0</token>
      <token name="DevComputerMovementMode">0</token>
      <token name="DevTouchCameraMovementMode">0</token>
      <token name="DevTouchMovementMode">0</token>
      <bool name="EnableMouseLockOption">true</bool>
      <int64 name="GameSettingsAssetIDFace">0</int64>
      <int64 name="GameSettingsAssetIDHead">0</int64>
      <int64 name="GameSettingsAssetIDLeftArm">0</int64>
      <int64 name="GameSettingsAssetIDLeftLeg">0</int64>
      <int64 name="GameSettingsAssetIDPants">0</int64>
      <int64 name="GameSettingsAssetIDRightArm">0</int64>
      <int64 name="GameSettingsAssetIDRightLeg">0</int64>
      <int64 name="GameSettingsAssetIDShirt">0</int64>
      <int64 name="GameSettingsAssetIDTeeShirt">0</int64>
      <int64 name="GameSettingsAssetIDTorso">0</int64>
      <token name="GameSettingsAvatar">1</token>
      <token name="GameSettingsR15Collision">0</token>
      <NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
      <NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
      <NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
      <NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
      <NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
      <float name="HealthDisplayDistance">100</float>
      <bool name="LoadCharacterAppearance">true</bool>
      <token name="LoadCharacterLayeredClothing">0</token>
      <float name="NameDisplayDistance">100</float>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
      <bool name="UserEmotesEnabled">true</bool>
    </Properties>
    <Item class="StarterPlayerScripts" referent="37">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="Folder" referent="38">
        <Properties>
          <string name="Name">Game</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="LocalScript" referent="39">
          <Properties>
            <string name="Name">KnitClient</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <bool name="Disabled">false</bool>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezREMkMyNjY2LUU5NEYtNEU4OC1BN0E5LUQ3REI2RENEOUQwOH0=]]></BinaryString>
            <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Loader = require(ReplicatedStorage.Packages.Loader)

Knit.AddControllersDeep(ReplicatedStorage.Game.Controllers)
Loader.LoadChildren(ReplicatedStorage.Game.Components)

Knit.Start()
:andThen(function()
	print("KnitClient Started")
end)
:catch(warn)
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="StarterCharacterScripts" referent="40">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterPack" referent="41">
    <Properties>
      <string name="Name">StarterPack</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="StarterGui" referent="42">
    <Properties>
      <string name="Name">StarterGui</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="ResetPlayerGuiOnSpawn">true</bool>
      <token name="ScreenOrientation">4</token>
      <bool name="ShowDevelopmentGui">true</bool>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
      <token name="VirtualCursorMode">0</token>
    </Properties>
    <Item class="ScreenGui" referent="43">
      <Properties>
        <string name="Name">ScreenGui</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <bool name="AutoLocalize">true</bool>
        <int name="DisplayOrder">1</int>
        <bool name="Enabled">false</bool>
        <bool name="IgnoreGuiInset">true</bool>
        <bool name="ResetOnSpawn">false</bool>
        <Ref name="RootLocalizationTable">null</Ref>
        <token name="SelectionBehaviorDown">0</token>
        <token name="SelectionBehaviorLeft">0</token>
        <token name="SelectionBehaviorRight">0</token>
        <token name="SelectionBehaviorUp">0</token>
        <bool name="SelectionGroup">false</bool>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <token name="ZIndexBehavior">1</token>
      </Properties>
      <Item class="Frame" referent="44">
        <Properties>
          <string name="Name">builder</string>
          <bool name="Active">false</bool>
          <Vector2 name="AnchorPoint">
            <X>0.5</X>
            <Y>0.5</Y>
          </Vector2>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <bool name="AutoLocalize">true</bool>
          <token name="AutomaticSize">0</token>
          <Color3 name="BackgroundColor3">
            <R>1</R>
            <G>1</G>
            <B>1</B>
          </Color3>
          <float name="BackgroundTransparency">1</float>
          <Color3 name="BorderColor3">
            <R>0.10588236</R>
            <G>0.16470589</G>
            <B>0.20784315</B>
          </Color3>
          <token name="BorderMode">0</token>
          <int name="BorderSizePixel">1</int>
          <bool name="ClipsDescendants">false</bool>
          <bool name="Draggable">false</bool>
          <int name="LayoutOrder">0</int>
          <Ref name="NextSelectionDown">null</Ref>
          <Ref name="NextSelectionLeft">null</Ref>
          <Ref name="NextSelectionRight">null</Ref>
          <Ref name="NextSelectionUp">null</Ref>
          <UDim2 name="Position">
            <XS>0.5</XS>
            <XO>0</XO>
            <YS>0.5</YS>
            <YO>0</YO>
          </UDim2>
          <Ref name="RootLocalizationTable">null</Ref>
          <float name="Rotation">0</float>
          <bool name="Selectable">false</bool>
          <token name="SelectionBehaviorDown">0</token>
          <token name="SelectionBehaviorLeft">0</token>
          <token name="SelectionBehaviorRight">0</token>
          <token name="SelectionBehaviorUp">0</token>
          <bool name="SelectionGroup">false</bool>
          <Ref name="SelectionImageObject">null</Ref>
          <int name="SelectionOrder">0</int>
          <UDim2 name="Size">
            <XS>0</XS>
            <XO>560</XO>
            <YS>0</YS>
            <YO>350</YO>
          </UDim2>
          <token name="SizeConstraint">0</token>
          <int64 name="SourceAssetId">-1</int64>
          <token name="Style">0</token>
          <BinaryString name="Tags"></BinaryString>
          <bool name="Visible">true</bool>
          <int name="ZIndex">1</int>
        </Properties>
        <Item class="UIScale" referent="45">
          <Properties>
            <string name="Name">UIScale</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="Scale">1</float>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="Frame" referent="46">
          <Properties>
            <string name="Name">Frame</string>
            <bool name="Active">false</bool>
            <Vector2 name="AnchorPoint">
              <X>0.5</X>
              <Y>0.5</Y>
            </Vector2>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <bool name="AutoLocalize">true</bool>
            <token name="AutomaticSize">0</token>
            <Color3 name="BackgroundColor3">
              <R>1</R>
              <G>1</G>
              <B>1</B>
            </Color3>
            <float name="BackgroundTransparency">1</float>
            <Color3 name="BorderColor3">
              <R>0.10588236</R>
              <G>0.16470589</G>
              <B>0.20784315</B>
            </Color3>
            <token name="BorderMode">0</token>
            <int name="BorderSizePixel">1</int>
            <bool name="ClipsDescendants">false</bool>
            <bool name="Draggable">false</bool>
            <int name="LayoutOrder">0</int>
            <Ref name="NextSelectionDown">null</Ref>
            <Ref name="NextSelectionLeft">null</Ref>
            <Ref name="NextSelectionRight">null</Ref>
            <Ref name="NextSelectionUp">null</Ref>
            <UDim2 name="Position">
              <XS>0.5</XS>
              <XO>0</XO>
              <YS>0.5</YS>
              <YO>0</YO>
            </UDim2>
            <Ref name="RootLocalizationTable">null</Ref>
            <float name="Rotation">0</float>
            <bool name="Selectable">false</bool>
            <token name="SelectionBehaviorDown">0</token>
            <token name="SelectionBehaviorLeft">0</token>
            <token name="SelectionBehaviorRight">0</token>
            <token name="SelectionBehaviorUp">0</token>
            <bool name="SelectionGroup">false</bool>
            <Ref name="SelectionImageObject">null</Ref>
            <int name="SelectionOrder">0</int>
            <UDim2 name="Size">
              <XS>1</XS>
              <XO>0</XO>
              <YS>1</YS>
              <YO>0</YO>
            </UDim2>
            <token name="SizeConstraint">0</token>
            <int64 name="SourceAssetId">-1</int64>
            <token name="Style">0</token>
            <BinaryString name="Tags"></BinaryString>
            <bool name="Visible">true</bool>
            <int name="ZIndex">1</int>
          </Properties>
          <Item class="Frame" referent="47">
            <Properties>
              <string name="Name">border</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0.5</X>
                <Y>0.5</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">0</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <int name="LayoutOrder">0</int>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>0.5</XS>
                <XO>0</XO>
                <YS>0.5</YS>
                <YO>0</YO>
              </UDim2>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <bool name="Selectable">false</bool>
              <token name="SelectionBehaviorDown">0</token>
              <token name="SelectionBehaviorLeft">0</token>
              <token name="SelectionBehaviorRight">0</token>
              <token name="SelectionBehaviorUp">0</token>
              <bool name="SelectionGroup">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <int name="SelectionOrder">0</int>
              <UDim2 name="Size">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <bool name="Visible">true</bool>
              <int name="ZIndex">2</int>
            </Properties>
            <Item class="UICorner" referent="48">
              <Properties>
                <string name="Name">UICorner</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <UDim name="CornerRadius">
                  <S>0</S>
                  <O>20</O>
                </UDim>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="Frame" referent="49">
              <Properties>
                <string name="Name">color</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>0.5921569</R>
                  <G>0.72156864</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">0</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
              <Item class="UICorner" referent="50">
                <Properties>
                  <string name="Name">UICorner</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <UDim name="CornerRadius">
                    <S>0</S>
                    <O>15</O>
                  </UDim>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="UIPadding" referent="51">
              <Properties>
                <string name="Name">UIPadding</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <UDim name="PaddingBottom">
                  <S>0</S>
                  <O>5</O>
                </UDim>
                <UDim name="PaddingLeft">
                  <S>0</S>
                  <O>5</O>
                </UDim>
                <UDim name="PaddingRight">
                  <S>0</S>
                  <O>5</O>
                </UDim>
                <UDim name="PaddingTop">
                  <S>0</S>
                  <O>5</O>
                </UDim>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="Frame" referent="52">
              <Properties>
                <string name="Name">content</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">2</int>
              </Properties>
            </Item>
          </Item>
          <Item class="Frame" referent="53">
            <Properties>
              <string name="Name">shadow</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0.5</X>
                <Y>0.5</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <int name="LayoutOrder">0</int>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>0.5</XS>
                <XO>0</XO>
                <YS>0.5</YS>
                <YO>0</YO>
              </UDim2>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <bool name="Selectable">false</bool>
              <token name="SelectionBehaviorDown">0</token>
              <token name="SelectionBehaviorLeft">0</token>
              <token name="SelectionBehaviorRight">0</token>
              <token name="SelectionBehaviorUp">0</token>
              <bool name="SelectionGroup">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <int name="SelectionOrder">0</int>
              <UDim2 name="Size">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <bool name="Visible">true</bool>
              <int name="ZIndex">1</int>
            </Properties>
            <Item class="ImageLabel" referent="54">
              <Properties>
                <string name="Name">Shadow</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <Content name="Image">
                  <url>rbxasset://textures/particles/explosion01_implosion_main.dds</url>
                </Content>
                <Color3 name="ImageColor3">
                  <R>0</R>
                  <G>0</G>
                  <B>0</B>
                </Color3>
                <Vector2 name="ImageRectOffset">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <Vector2 name="ImageRectSize">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <float name="ImageTransparency">0</float>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="ResampleMode">0</token>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <token name="ScaleType">1</token>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <Rect2D name="SliceCenter">
                  <min>
                    <X>128</X>
                    <Y>128</Y>
                  </min>
                  <max>
                    <X>128</X>
                    <Y>128</Y>
                  </max>
                </Rect2D>
                <float name="SliceScale">1</float>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
                <UDim2 name="TileSize">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
            </Item>
            <Item class="UIPadding" referent="55">
              <Properties>
                <string name="Name">UIPadding</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <UDim name="PaddingBottom">
                  <S>0</S>
                  <O>-80</O>
                </UDim>
                <UDim name="PaddingLeft">
                  <S>0</S>
                  <O>-80</O>
                </UDim>
                <UDim name="PaddingRight">
                  <S>0</S>
                  <O>-80</O>
                </UDim>
                <UDim name="PaddingTop">
                  <S>0</S>
                  <O>-60</O>
                </UDim>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="Frame" referent="56">
        <Properties>
          <string name="Name">hotbar</string>
          <bool name="Active">false</bool>
          <Vector2 name="AnchorPoint">
            <X>0.5</X>
            <Y>1</Y>
          </Vector2>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <bool name="AutoLocalize">true</bool>
          <token name="AutomaticSize">0</token>
          <Color3 name="BackgroundColor3">
            <R>1</R>
            <G>1</G>
            <B>1</B>
          </Color3>
          <float name="BackgroundTransparency">1</float>
          <Color3 name="BorderColor3">
            <R>0.10588236</R>
            <G>0.16470589</G>
            <B>0.20784315</B>
          </Color3>
          <token name="BorderMode">0</token>
          <int name="BorderSizePixel">1</int>
          <bool name="ClipsDescendants">false</bool>
          <bool name="Draggable">false</bool>
          <int name="LayoutOrder">0</int>
          <Ref name="NextSelectionDown">null</Ref>
          <Ref name="NextSelectionLeft">null</Ref>
          <Ref name="NextSelectionRight">null</Ref>
          <Ref name="NextSelectionUp">null</Ref>
          <UDim2 name="Position">
            <XS>0.5</XS>
            <XO>0</XO>
            <YS>1</YS>
            <YO>-20</YO>
          </UDim2>
          <Ref name="RootLocalizationTable">null</Ref>
          <float name="Rotation">0</float>
          <bool name="Selectable">false</bool>
          <token name="SelectionBehaviorDown">0</token>
          <token name="SelectionBehaviorLeft">0</token>
          <token name="SelectionBehaviorRight">0</token>
          <token name="SelectionBehaviorUp">0</token>
          <bool name="SelectionGroup">false</bool>
          <Ref name="SelectionImageObject">null</Ref>
          <int name="SelectionOrder">0</int>
          <UDim2 name="Size">
            <XS>1</XS>
            <XO>0</XO>
            <YS>0</YS>
            <YO>100</YO>
          </UDim2>
          <token name="SizeConstraint">0</token>
          <int64 name="SourceAssetId">-1</int64>
          <token name="Style">0</token>
          <BinaryString name="Tags"></BinaryString>
          <bool name="Visible">true</bool>
          <int name="ZIndex">1</int>
        </Properties>
        <Item class="UIListLayout" referent="57">
          <Properties>
            <string name="Name">UIListLayout</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <token name="FillDirection">0</token>
            <token name="HorizontalAlignment">0</token>
            <UDim name="Padding">
              <S>0</S>
              <O>20</O>
            </UDim>
            <token name="SortOrder">2</token>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <token name="VerticalAlignment">1</token>
          </Properties>
        </Item>
        <Item class="Frame" referent="58">
          <Properties>
            <string name="Name">main</string>
            <bool name="Active">false</bool>
            <Vector2 name="AnchorPoint">
              <X>0</X>
              <Y>0</Y>
            </Vector2>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <bool name="AutoLocalize">true</bool>
            <token name="AutomaticSize">0</token>
            <Color3 name="BackgroundColor3">
              <R>1</R>
              <G>1</G>
              <B>1</B>
            </Color3>
            <float name="BackgroundTransparency">1</float>
            <Color3 name="BorderColor3">
              <R>0.10588236</R>
              <G>0.16470589</G>
              <B>0.20784315</B>
            </Color3>
            <token name="BorderMode">0</token>
            <int name="BorderSizePixel">1</int>
            <bool name="ClipsDescendants">false</bool>
            <bool name="Draggable">false</bool>
            <int name="LayoutOrder">0</int>
            <Ref name="NextSelectionDown">null</Ref>
            <Ref name="NextSelectionLeft">null</Ref>
            <Ref name="NextSelectionRight">null</Ref>
            <Ref name="NextSelectionUp">null</Ref>
            <UDim2 name="Position">
              <XS>0</XS>
              <XO>0</XO>
              <YS>0</YS>
              <YO>0</YO>
            </UDim2>
            <Ref name="RootLocalizationTable">null</Ref>
            <float name="Rotation">0</float>
            <bool name="Selectable">false</bool>
            <token name="SelectionBehaviorDown">0</token>
            <token name="SelectionBehaviorLeft">0</token>
            <token name="SelectionBehaviorRight">0</token>
            <token name="SelectionBehaviorUp">0</token>
            <bool name="SelectionGroup">false</bool>
            <Ref name="SelectionImageObject">null</Ref>
            <int name="SelectionOrder">0</int>
            <UDim2 name="Size">
              <XS>1</XS>
              <XO>0</XO>
              <YS>1</YS>
              <YO>0</YO>
            </UDim2>
            <token name="SizeConstraint">0</token>
            <int64 name="SourceAssetId">-1</int64>
            <token name="Style">0</token>
            <BinaryString name="Tags"></BinaryString>
            <bool name="Visible">true</bool>
            <int name="ZIndex">1</int>
          </Properties>
          <Item class="UIAspectRatioConstraint" referent="59">
            <Properties>
              <string name="Name">UIAspectRatioConstraint</string>
              <float name="AspectRatio">1</float>
              <token name="AspectType">0</token>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <token name="DominantAxis">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="Frame" referent="60">
            <Properties>
              <string name="Name">Frame</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0.5</X>
                <Y>0.5</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <int name="LayoutOrder">0</int>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>0.5</XS>
                <XO>0</XO>
                <YS>0.5</YS>
                <YO>0</YO>
              </UDim2>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <bool name="Selectable">false</bool>
              <token name="SelectionBehaviorDown">0</token>
              <token name="SelectionBehaviorLeft">0</token>
              <token name="SelectionBehaviorRight">0</token>
              <token name="SelectionBehaviorUp">0</token>
              <bool name="SelectionGroup">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <int name="SelectionOrder">0</int>
              <UDim2 name="Size">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <bool name="Visible">true</bool>
              <int name="ZIndex">1</int>
            </Properties>
            <Item class="Frame" referent="61">
              <Properties>
                <string name="Name">Button</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">2</int>
              </Properties>
              <Item class="TextButton" referent="62">
                <Properties>
                  <string name="Name">TextButton</string>
                  <bool name="Active">true</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoButtonColor">true</bool>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <token name="Font">3</token>
                  <int name="LayoutOrder">0</int>
                  <float name="LineHeight">1</float>
                  <int name="MaxVisibleGraphemes">-1</int>
                  <bool name="Modal">false</bool>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <bool name="RichText">false</bool>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">true</bool>
                  <bool name="Selected">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <string name="Text"></string>
                  <Color3 name="TextColor3">
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                  </Color3>
                  <bool name="TextScaled">false</bool>
                  <float name="TextSize">14</float>
                  <Color3 name="TextStrokeColor3">
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                  </Color3>
                  <float name="TextStrokeTransparency">1</float>
                  <float name="TextTransparency">0</float>
                  <token name="TextTruncate">0</token>
                  <bool name="TextWrapped">false</bool>
                  <token name="TextXAlignment">2</token>
                  <token name="TextYAlignment">1</token>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="UICorner" referent="63">
                  <Properties>
                    <string name="Name">UICorner</string>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <UDim name="CornerRadius">
                      <S>0.5</S>
                      <O>0</O>
                    </UDim>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                  </Properties>
                </Item>
              </Item>
              <Item class="UIScale" referent="64">
                <Properties>
                  <string name="Name">UIScale</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <float name="Scale">1.15</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Frame" referent="65">
              <Properties>
                <string name="Name">Frame</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
              <Item class="Frame" referent="66">
                <Properties>
                  <string name="Name">scale</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0.5</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="67">
                  <Properties>
                    <string name="Name">border</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">2</int>
                  </Properties>
                  <Item class="UICorner" referent="68">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <UDim name="CornerRadius">
                        <S>0.5</S>
                        <O>0</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags"></BinaryString>
                    </Properties>
                  </Item>
                  <Item class="Frame" referent="69">
                    <Properties>
                      <string name="Name">icon</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">2</int>
                    </Properties>
                    <Item class="ImageLabel" referent="70">
                      <Properties>
                        <string name="Name">ImageLabel</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <Content name="Image">
                          <url>rbxassetid://390345587</url>
                        </Content>
                        <Color3 name="ImageColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <Vector2 name="ImageRectOffset">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <Vector2 name="ImageRectSize">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <float name="ImageTransparency">0</float>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0.5</XS>
                          <XO>0</XO>
                          <YS>0.5</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="ResampleMode">0</token>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <token name="ScaleType">3</token>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>0</XS>
                          <XO>100</XO>
                          <YS>0</YS>
                          <YO>100</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <Rect2D name="SliceCenter">
                          <min>
                            <X>0</X>
                            <Y>0</Y>
                          </min>
                          <max>
                            <X>0</X>
                            <Y>0</Y>
                          </max>
                        </Rect2D>
                        <float name="SliceScale">1</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                        <UDim2 name="TileSize">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                      <Item class="UIScale" referent="71">
                        <Properties>
                          <string name="Name">UIScale</string>
                          <BinaryString name="AttributesSerialize"></BinaryString>
                          <float name="Scale">0.6</float>
                          <int64 name="SourceAssetId">-1</int64>
                          <BinaryString name="Tags"></BinaryString>
                        </Properties>
                      </Item>
                    </Item>
                  </Item>
                  <Item class="Frame" referent="72">
                    <Properties>
                      <string name="Name">background</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>0.5921569</R>
                        <G>0.72156864</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="Frame" referent="73">
                      <Properties>
                        <string name="Name">purple</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>0.5921569</R>
                          <G>0.72156864</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">0</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0.5</XS>
                          <XO>0</XO>
                          <YS>0.5</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags"></BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                      <Item class="UICorner" referent="74">
                        <Properties>
                          <string name="Name">UICorner</string>
                          <BinaryString name="AttributesSerialize"></BinaryString>
                          <UDim name="CornerRadius">
                            <S>0.5</S>
                            <O>0</O>
                          </UDim>
                          <int64 name="SourceAssetId">-1</int64>
                          <BinaryString name="Tags"></BinaryString>
                        </Properties>
                      </Item>
                    </Item>
                    <Item class="UIPadding" referent="75">
                      <Properties>
                        <string name="Name">UIPadding</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <UDim name="PaddingBottom">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingLeft">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingRight">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingTop">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
                <Item class="ImageLabel" referent="76">
                  <Properties>
                    <string name="Name">Shadow</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <Content name="Image">
                      <url>rbxasset://textures/particles/explosion01_implosion_main.dds</url>
                    </Content>
                    <Color3 name="ImageColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <Vector2 name="ImageRectOffset">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <Vector2 name="ImageRectSize">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <float name="ImageTransparency">0</float>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.7</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="ResampleMode">0</token>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <token name="ScaleType">0</token>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <Rect2D name="SliceCenter">
                      <min>
                        <X>0</X>
                        <Y>0</Y>
                      </min>
                      <max>
                        <X>0</X>
                        <Y>0</Y>
                      </max>
                    </Rect2D>
                    <float name="SliceScale">1</float>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <UDim2 name="TileSize">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UIScale" referent="77">
                    <Properties>
                      <string name="Name">UIScale</string>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <float name="Scale">2</float>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags"></BinaryString>
                    </Properties>
                  </Item>
                </Item>
                <Item class="UIScale" referent="78">
                  <Properties>
                    <string name="Name">UIScale</string>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <float name="Scale">1</float>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                  </Properties>
                </Item>
              </Item>
              <Item class="Frame" referent="79">
                <Properties>
                  <string name="Name">extra</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0.5</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">2</int>
                </Properties>
                <Item class="Frame" referent="80">
                  <Properties>
                    <string name="Name">tooltip</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>1</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>-0.1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0.3</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="Frame" referent="81">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">0</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="UICorner" referent="82">
                      <Properties>
                        <string name="Name">UICorner</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <UDim name="CornerRadius">
                          <S>0.5</S>
                          <O>0</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
                <Item class="Frame" referent="83">
                  <Properties>
                    <string name="Name">badge</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.1</XS>
                      <XO>0</XO>
                      <YS>0.1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>0.4</XS>
                      <XO>0</XO>
                      <YS>0.4</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">3</int>
                  </Properties>
                  <Item class="Frame" referent="84">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="ImageLabel" referent="85">
                      <Properties>
                        <string name="Name">ImageLabel</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <Content name="Image">
                          <url>rbxassetid://1244653012</url>
                        </Content>
                        <Color3 name="ImageColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <Vector2 name="ImageRectOffset">
                          <X>500</X>
                          <Y>600</Y>
                        </Vector2>
                        <Vector2 name="ImageRectSize">
                          <X>100</X>
                          <Y>100</Y>
                        </Vector2>
                        <float name="ImageTransparency">0</float>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0</XS>
                          <XO>0</XO>
                          <YS>0</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="ResampleMode">0</token>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <token name="ScaleType">3</token>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <Rect2D name="SliceCenter">
                          <min>
                            <X>0</X>
                            <Y>0</Y>
                          </min>
                          <max>
                            <X>0</X>
                            <Y>0</Y>
                          </max>
                        </Rect2D>
                        <float name="SliceScale">1</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                        <UDim2 name="TileSize">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                    </Item>
                    <Item class="UIScale" referent="86">
                      <Properties>
                        <string name="Name">UIScale</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <float name="Scale">1.2</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="UIScale" referent="87">
          <Properties>
            <string name="Name">UIScale</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="Scale">1</float>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="Frame" referent="88">
          <Properties>
            <string name="Name">main</string>
            <bool name="Active">false</bool>
            <Vector2 name="AnchorPoint">
              <X>0</X>
              <Y>0</Y>
            </Vector2>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <bool name="AutoLocalize">true</bool>
            <token name="AutomaticSize">0</token>
            <Color3 name="BackgroundColor3">
              <R>1</R>
              <G>1</G>
              <B>1</B>
            </Color3>
            <float name="BackgroundTransparency">1</float>
            <Color3 name="BorderColor3">
              <R>0.10588236</R>
              <G>0.16470589</G>
              <B>0.20784315</B>
            </Color3>
            <token name="BorderMode">0</token>
            <int name="BorderSizePixel">1</int>
            <bool name="ClipsDescendants">false</bool>
            <bool name="Draggable">false</bool>
            <int name="LayoutOrder">0</int>
            <Ref name="NextSelectionDown">null</Ref>
            <Ref name="NextSelectionLeft">null</Ref>
            <Ref name="NextSelectionRight">null</Ref>
            <Ref name="NextSelectionUp">null</Ref>
            <UDim2 name="Position">
              <XS>0</XS>
              <XO>0</XO>
              <YS>0</YS>
              <YO>0</YO>
            </UDim2>
            <Ref name="RootLocalizationTable">null</Ref>
            <float name="Rotation">0</float>
            <bool name="Selectable">false</bool>
            <token name="SelectionBehaviorDown">0</token>
            <token name="SelectionBehaviorLeft">0</token>
            <token name="SelectionBehaviorRight">0</token>
            <token name="SelectionBehaviorUp">0</token>
            <bool name="SelectionGroup">false</bool>
            <Ref name="SelectionImageObject">null</Ref>
            <int name="SelectionOrder">0</int>
            <UDim2 name="Size">
              <XS>1</XS>
              <XO>0</XO>
              <YS>1</YS>
              <YO>0</YO>
            </UDim2>
            <token name="SizeConstraint">0</token>
            <int64 name="SourceAssetId">-1</int64>
            <token name="Style">0</token>
            <BinaryString name="Tags"></BinaryString>
            <bool name="Visible">true</bool>
            <int name="ZIndex">1</int>
          </Properties>
          <Item class="UIAspectRatioConstraint" referent="89">
            <Properties>
              <string name="Name">UIAspectRatioConstraint</string>
              <float name="AspectRatio">1</float>
              <token name="AspectType">0</token>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <token name="DominantAxis">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="Frame" referent="90">
            <Properties>
              <string name="Name">Frame</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0.5</X>
                <Y>0.5</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <int name="LayoutOrder">0</int>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>0.5</XS>
                <XO>0</XO>
                <YS>0.5</YS>
                <YO>0</YO>
              </UDim2>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <bool name="Selectable">false</bool>
              <token name="SelectionBehaviorDown">0</token>
              <token name="SelectionBehaviorLeft">0</token>
              <token name="SelectionBehaviorRight">0</token>
              <token name="SelectionBehaviorUp">0</token>
              <bool name="SelectionGroup">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <int name="SelectionOrder">0</int>
              <UDim2 name="Size">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <bool name="Visible">true</bool>
              <int name="ZIndex">1</int>
            </Properties>
            <Item class="Frame" referent="91">
              <Properties>
                <string name="Name">Button</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">2</int>
              </Properties>
              <Item class="TextButton" referent="92">
                <Properties>
                  <string name="Name">TextButton</string>
                  <bool name="Active">true</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoButtonColor">true</bool>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <token name="Font">3</token>
                  <int name="LayoutOrder">0</int>
                  <float name="LineHeight">1</float>
                  <int name="MaxVisibleGraphemes">-1</int>
                  <bool name="Modal">false</bool>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <bool name="RichText">false</bool>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">true</bool>
                  <bool name="Selected">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <string name="Text"></string>
                  <Color3 name="TextColor3">
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                  </Color3>
                  <bool name="TextScaled">false</bool>
                  <float name="TextSize">14</float>
                  <Color3 name="TextStrokeColor3">
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                  </Color3>
                  <float name="TextStrokeTransparency">1</float>
                  <float name="TextTransparency">0</float>
                  <token name="TextTruncate">0</token>
                  <bool name="TextWrapped">false</bool>
                  <token name="TextXAlignment">2</token>
                  <token name="TextYAlignment">1</token>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="UICorner" referent="93">
                  <Properties>
                    <string name="Name">UICorner</string>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <UDim name="CornerRadius">
                      <S>0.5</S>
                      <O>0</O>
                    </UDim>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                  </Properties>
                </Item>
              </Item>
              <Item class="UIScale" referent="94">
                <Properties>
                  <string name="Name">UIScale</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <float name="Scale">1.15</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Frame" referent="95">
              <Properties>
                <string name="Name">Frame</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
              <Item class="Frame" referent="96">
                <Properties>
                  <string name="Name">scale</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0.5</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="97">
                  <Properties>
                    <string name="Name">border</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">2</int>
                  </Properties>
                  <Item class="UICorner" referent="98">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <UDim name="CornerRadius">
                        <S>0.5</S>
                        <O>0</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags"></BinaryString>
                    </Properties>
                  </Item>
                  <Item class="Frame" referent="99">
                    <Properties>
                      <string name="Name">icon</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">2</int>
                    </Properties>
                    <Item class="ImageLabel" referent="100">
                      <Properties>
                        <string name="Name">ImageLabel</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <Content name="Image">
                          <url>rbxassetid://390345587</url>
                        </Content>
                        <Color3 name="ImageColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <Vector2 name="ImageRectOffset">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <Vector2 name="ImageRectSize">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <float name="ImageTransparency">0</float>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0.5</XS>
                          <XO>0</XO>
                          <YS>0.5</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="ResampleMode">0</token>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <token name="ScaleType">3</token>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>0</XS>
                          <XO>100</XO>
                          <YS>0</YS>
                          <YO>100</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <Rect2D name="SliceCenter">
                          <min>
                            <X>0</X>
                            <Y>0</Y>
                          </min>
                          <max>
                            <X>0</X>
                            <Y>0</Y>
                          </max>
                        </Rect2D>
                        <float name="SliceScale">1</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                        <UDim2 name="TileSize">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                      <Item class="UIScale" referent="101">
                        <Properties>
                          <string name="Name">UIScale</string>
                          <BinaryString name="AttributesSerialize"></BinaryString>
                          <float name="Scale">0.6</float>
                          <int64 name="SourceAssetId">-1</int64>
                          <BinaryString name="Tags"></BinaryString>
                        </Properties>
                      </Item>
                    </Item>
                  </Item>
                  <Item class="Frame" referent="102">
                    <Properties>
                      <string name="Name">background</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>0.5921569</R>
                        <G>0.72156864</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="Frame" referent="103">
                      <Properties>
                        <string name="Name">purple</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>0.5921569</R>
                          <G>0.72156864</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">0</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0.5</XS>
                          <XO>0</XO>
                          <YS>0.5</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags"></BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                      <Item class="UICorner" referent="104">
                        <Properties>
                          <string name="Name">UICorner</string>
                          <BinaryString name="AttributesSerialize"></BinaryString>
                          <UDim name="CornerRadius">
                            <S>0.5</S>
                            <O>0</O>
                          </UDim>
                          <int64 name="SourceAssetId">-1</int64>
                          <BinaryString name="Tags"></BinaryString>
                        </Properties>
                      </Item>
                    </Item>
                    <Item class="UIPadding" referent="105">
                      <Properties>
                        <string name="Name">UIPadding</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <UDim name="PaddingBottom">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingLeft">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingRight">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingTop">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
                <Item class="ImageLabel" referent="106">
                  <Properties>
                    <string name="Name">Shadow</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <Content name="Image">
                      <url>rbxasset://textures/particles/explosion01_implosion_main.dds</url>
                    </Content>
                    <Color3 name="ImageColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <Vector2 name="ImageRectOffset">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <Vector2 name="ImageRectSize">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <float name="ImageTransparency">0</float>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.7</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="ResampleMode">0</token>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <token name="ScaleType">0</token>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <Rect2D name="SliceCenter">
                      <min>
                        <X>0</X>
                        <Y>0</Y>
                      </min>
                      <max>
                        <X>0</X>
                        <Y>0</Y>
                      </max>
                    </Rect2D>
                    <float name="SliceScale">1</float>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <UDim2 name="TileSize">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UIScale" referent="107">
                    <Properties>
                      <string name="Name">UIScale</string>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <float name="Scale">2</float>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags"></BinaryString>
                    </Properties>
                  </Item>
                </Item>
                <Item class="UIScale" referent="108">
                  <Properties>
                    <string name="Name">UIScale</string>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <float name="Scale">1</float>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                  </Properties>
                </Item>
              </Item>
              <Item class="Frame" referent="109">
                <Properties>
                  <string name="Name">extra</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0.5</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">2</int>
                </Properties>
                <Item class="Frame" referent="110">
                  <Properties>
                    <string name="Name">tooltip</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>1</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>-0.1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0.3</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="Frame" referent="111">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">0</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="UICorner" referent="112">
                      <Properties>
                        <string name="Name">UICorner</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <UDim name="CornerRadius">
                          <S>0.5</S>
                          <O>0</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
                <Item class="Frame" referent="113">
                  <Properties>
                    <string name="Name">badge</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.1</XS>
                      <XO>0</XO>
                      <YS>0.1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>0.4</XS>
                      <XO>0</XO>
                      <YS>0.4</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">3</int>
                  </Properties>
                  <Item class="Frame" referent="114">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="ImageLabel" referent="115">
                      <Properties>
                        <string name="Name">ImageLabel</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <Content name="Image">
                          <url>rbxassetid://1244653012</url>
                        </Content>
                        <Color3 name="ImageColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <Vector2 name="ImageRectOffset">
                          <X>500</X>
                          <Y>600</Y>
                        </Vector2>
                        <Vector2 name="ImageRectSize">
                          <X>100</X>
                          <Y>100</Y>
                        </Vector2>
                        <float name="ImageTransparency">0</float>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0</XS>
                          <XO>0</XO>
                          <YS>0</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="ResampleMode">0</token>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <token name="ScaleType">3</token>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <Rect2D name="SliceCenter">
                          <min>
                            <X>0</X>
                            <Y>0</Y>
                          </min>
                          <max>
                            <X>0</X>
                            <Y>0</Y>
                          </max>
                        </Rect2D>
                        <float name="SliceScale">1</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                        <UDim2 name="TileSize">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                    </Item>
                    <Item class="UIScale" referent="116">
                      <Properties>
                        <string name="Name">UIScale</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <float name="Scale">1.2</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Frame" referent="117">
          <Properties>
            <string name="Name">main</string>
            <bool name="Active">false</bool>
            <Vector2 name="AnchorPoint">
              <X>0</X>
              <Y>0</Y>
            </Vector2>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <bool name="AutoLocalize">true</bool>
            <token name="AutomaticSize">0</token>
            <Color3 name="BackgroundColor3">
              <R>1</R>
              <G>1</G>
              <B>1</B>
            </Color3>
            <float name="BackgroundTransparency">1</float>
            <Color3 name="BorderColor3">
              <R>0.10588236</R>
              <G>0.16470589</G>
              <B>0.20784315</B>
            </Color3>
            <token name="BorderMode">0</token>
            <int name="BorderSizePixel">1</int>
            <bool name="ClipsDescendants">false</bool>
            <bool name="Draggable">false</bool>
            <int name="LayoutOrder">0</int>
            <Ref name="NextSelectionDown">null</Ref>
            <Ref name="NextSelectionLeft">null</Ref>
            <Ref name="NextSelectionRight">null</Ref>
            <Ref name="NextSelectionUp">null</Ref>
            <UDim2 name="Position">
              <XS>0</XS>
              <XO>0</XO>
              <YS>0</YS>
              <YO>0</YO>
            </UDim2>
            <Ref name="RootLocalizationTable">null</Ref>
            <float name="Rotation">0</float>
            <bool name="Selectable">false</bool>
            <token name="SelectionBehaviorDown">0</token>
            <token name="SelectionBehaviorLeft">0</token>
            <token name="SelectionBehaviorRight">0</token>
            <token name="SelectionBehaviorUp">0</token>
            <bool name="SelectionGroup">false</bool>
            <Ref name="SelectionImageObject">null</Ref>
            <int name="SelectionOrder">0</int>
            <UDim2 name="Size">
              <XS>1</XS>
              <XO>0</XO>
              <YS>1</YS>
              <YO>0</YO>
            </UDim2>
            <token name="SizeConstraint">0</token>
            <int64 name="SourceAssetId">-1</int64>
            <token name="Style">0</token>
            <BinaryString name="Tags"></BinaryString>
            <bool name="Visible">true</bool>
            <int name="ZIndex">1</int>
          </Properties>
          <Item class="UIAspectRatioConstraint" referent="118">
            <Properties>
              <string name="Name">UIAspectRatioConstraint</string>
              <float name="AspectRatio">1</float>
              <token name="AspectType">0</token>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <token name="DominantAxis">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="Frame" referent="119">
            <Properties>
              <string name="Name">Frame</string>
              <bool name="Active">false</bool>
              <Vector2 name="AnchorPoint">
                <X>0.5</X>
                <Y>0.5</Y>
              </Vector2>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <bool name="AutoLocalize">true</bool>
              <token name="AutomaticSize">0</token>
              <Color3 name="BackgroundColor3">
                <R>1</R>
                <G>1</G>
                <B>1</B>
              </Color3>
              <float name="BackgroundTransparency">1</float>
              <Color3 name="BorderColor3">
                <R>0.10588236</R>
                <G>0.16470589</G>
                <B>0.20784315</B>
              </Color3>
              <token name="BorderMode">0</token>
              <int name="BorderSizePixel">1</int>
              <bool name="ClipsDescendants">false</bool>
              <bool name="Draggable">false</bool>
              <int name="LayoutOrder">0</int>
              <Ref name="NextSelectionDown">null</Ref>
              <Ref name="NextSelectionLeft">null</Ref>
              <Ref name="NextSelectionRight">null</Ref>
              <Ref name="NextSelectionUp">null</Ref>
              <UDim2 name="Position">
                <XS>0.5</XS>
                <XO>0</XO>
                <YS>0.5</YS>
                <YO>0</YO>
              </UDim2>
              <Ref name="RootLocalizationTable">null</Ref>
              <float name="Rotation">0</float>
              <bool name="Selectable">false</bool>
              <token name="SelectionBehaviorDown">0</token>
              <token name="SelectionBehaviorLeft">0</token>
              <token name="SelectionBehaviorRight">0</token>
              <token name="SelectionBehaviorUp">0</token>
              <bool name="SelectionGroup">false</bool>
              <Ref name="SelectionImageObject">null</Ref>
              <int name="SelectionOrder">0</int>
              <UDim2 name="Size">
                <XS>1</XS>
                <XO>0</XO>
                <YS>1</YS>
                <YO>0</YO>
              </UDim2>
              <token name="SizeConstraint">0</token>
              <int64 name="SourceAssetId">-1</int64>
              <token name="Style">0</token>
              <BinaryString name="Tags"></BinaryString>
              <bool name="Visible">true</bool>
              <int name="ZIndex">1</int>
            </Properties>
            <Item class="Frame" referent="120">
              <Properties>
                <string name="Name">Button</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">2</int>
              </Properties>
              <Item class="TextButton" referent="121">
                <Properties>
                  <string name="Name">TextButton</string>
                  <bool name="Active">true</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoButtonColor">true</bool>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <token name="Font">3</token>
                  <int name="LayoutOrder">0</int>
                  <float name="LineHeight">1</float>
                  <int name="MaxVisibleGraphemes">-1</int>
                  <bool name="Modal">false</bool>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <bool name="RichText">false</bool>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">true</bool>
                  <bool name="Selected">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <string name="Text"></string>
                  <Color3 name="TextColor3">
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                  </Color3>
                  <bool name="TextScaled">false</bool>
                  <float name="TextSize">14</float>
                  <Color3 name="TextStrokeColor3">
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                  </Color3>
                  <float name="TextStrokeTransparency">1</float>
                  <float name="TextTransparency">0</float>
                  <token name="TextTruncate">0</token>
                  <bool name="TextWrapped">false</bool>
                  <token name="TextXAlignment">2</token>
                  <token name="TextYAlignment">1</token>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="UICorner" referent="122">
                  <Properties>
                    <string name="Name">UICorner</string>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <UDim name="CornerRadius">
                      <S>0.5</S>
                      <O>0</O>
                    </UDim>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                  </Properties>
                </Item>
              </Item>
              <Item class="UIScale" referent="123">
                <Properties>
                  <string name="Name">UIScale</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <float name="Scale">1.15</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Frame" referent="124">
              <Properties>
                <string name="Name">Frame</string>
                <bool name="Active">false</bool>
                <Vector2 name="AnchorPoint">
                  <X>0.5</X>
                  <Y>0.5</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236</R>
                  <G>0.16470589</G>
                  <B>0.20784315</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">false</bool>
                <bool name="Draggable">false</bool>
                <int name="LayoutOrder">0</int>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0.5</XS>
                  <XO>0</XO>
                  <YS>0.5</YS>
                  <YO>0</YO>
                </UDim2>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">false</bool>
                <token name="SelectionBehaviorDown">0</token>
                <token name="SelectionBehaviorLeft">0</token>
                <token name="SelectionBehaviorRight">0</token>
                <token name="SelectionBehaviorUp">0</token>
                <bool name="SelectionGroup">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <int name="SelectionOrder">0</int>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <token name="Style">0</token>
                <BinaryString name="Tags"></BinaryString>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
              <Item class="Frame" referent="125">
                <Properties>
                  <string name="Name">scale</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0.5</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="126">
                  <Properties>
                    <string name="Name">border</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">2</int>
                  </Properties>
                  <Item class="UICorner" referent="127">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <UDim name="CornerRadius">
                        <S>0.5</S>
                        <O>0</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags"></BinaryString>
                    </Properties>
                  </Item>
                  <Item class="Frame" referent="128">
                    <Properties>
                      <string name="Name">icon</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">2</int>
                    </Properties>
                    <Item class="ImageLabel" referent="129">
                      <Properties>
                        <string name="Name">ImageLabel</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <Content name="Image">
                          <url>rbxassetid://390345587</url>
                        </Content>
                        <Color3 name="ImageColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <Vector2 name="ImageRectOffset">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <Vector2 name="ImageRectSize">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <float name="ImageTransparency">0</float>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0.5</XS>
                          <XO>0</XO>
                          <YS>0.5</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="ResampleMode">0</token>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <token name="ScaleType">3</token>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>0</XS>
                          <XO>100</XO>
                          <YS>0</YS>
                          <YO>100</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <Rect2D name="SliceCenter">
                          <min>
                            <X>0</X>
                            <Y>0</Y>
                          </min>
                          <max>
                            <X>0</X>
                            <Y>0</Y>
                          </max>
                        </Rect2D>
                        <float name="SliceScale">1</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                        <UDim2 name="TileSize">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                      <Item class="UIScale" referent="130">
                        <Properties>
                          <string name="Name">UIScale</string>
                          <BinaryString name="AttributesSerialize"></BinaryString>
                          <float name="Scale">0.6</float>
                          <int64 name="SourceAssetId">-1</int64>
                          <BinaryString name="Tags"></BinaryString>
                        </Properties>
                      </Item>
                    </Item>
                  </Item>
                  <Item class="Frame" referent="131">
                    <Properties>
                      <string name="Name">background</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>0.5921569</R>
                        <G>0.72156864</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="Frame" referent="132">
                      <Properties>
                        <string name="Name">purple</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>0.5921569</R>
                          <G>0.72156864</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">0</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0.5</XS>
                          <XO>0</XO>
                          <YS>0.5</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags"></BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                      <Item class="UICorner" referent="133">
                        <Properties>
                          <string name="Name">UICorner</string>
                          <BinaryString name="AttributesSerialize"></BinaryString>
                          <UDim name="CornerRadius">
                            <S>0.5</S>
                            <O>0</O>
                          </UDim>
                          <int64 name="SourceAssetId">-1</int64>
                          <BinaryString name="Tags"></BinaryString>
                        </Properties>
                      </Item>
                    </Item>
                    <Item class="UIPadding" referent="134">
                      <Properties>
                        <string name="Name">UIPadding</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <UDim name="PaddingBottom">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingLeft">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingRight">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <UDim name="PaddingTop">
                          <S>0</S>
                          <O>5</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
                <Item class="ImageLabel" referent="135">
                  <Properties>
                    <string name="Name">Shadow</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <Content name="Image">
                      <url>rbxasset://textures/particles/explosion01_implosion_main.dds</url>
                    </Content>
                    <Color3 name="ImageColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <Vector2 name="ImageRectOffset">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <Vector2 name="ImageRectSize">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <float name="ImageTransparency">0</float>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.7</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="ResampleMode">0</token>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <token name="ScaleType">0</token>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <Rect2D name="SliceCenter">
                      <min>
                        <X>0</X>
                        <Y>0</Y>
                      </min>
                      <max>
                        <X>0</X>
                        <Y>0</Y>
                      </max>
                    </Rect2D>
                    <float name="SliceScale">1</float>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                    <UDim2 name="TileSize">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UIScale" referent="136">
                    <Properties>
                      <string name="Name">UIScale</string>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <float name="Scale">2</float>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags"></BinaryString>
                    </Properties>
                  </Item>
                </Item>
                <Item class="UIScale" referent="137">
                  <Properties>
                    <string name="Name">UIScale</string>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <float name="Scale">1</float>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags"></BinaryString>
                  </Properties>
                </Item>
              </Item>
              <Item class="Frame" referent="138">
                <Properties>
                  <string name="Name">extra</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0.5</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236</R>
                    <G>0.16470589</G>
                    <B>0.20784315</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <token name="SelectionBehaviorDown">0</token>
                  <token name="SelectionBehaviorLeft">0</token>
                  <token name="SelectionBehaviorRight">0</token>
                  <token name="SelectionBehaviorUp">0</token>
                  <bool name="SelectionGroup">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <int name="SelectionOrder">0</int>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags"></BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">2</int>
                </Properties>
                <Item class="Frame" referent="139">
                  <Properties>
                    <string name="Name">tooltip</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>1</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>-0.1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0.3</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="Frame" referent="140">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">0</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="UICorner" referent="141">
                      <Properties>
                        <string name="Name">UICorner</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <UDim name="CornerRadius">
                          <S>0.5</S>
                          <O>0</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
                <Item class="Frame" referent="142">
                  <Properties>
                    <string name="Name">badge</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize"></BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236</R>
                      <G>0.16470589</G>
                      <B>0.20784315</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.1</XS>
                      <XO>0</XO>
                      <YS>0.1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <token name="SelectionBehaviorDown">0</token>
                    <token name="SelectionBehaviorLeft">0</token>
                    <token name="SelectionBehaviorRight">0</token>
                    <token name="SelectionBehaviorUp">0</token>
                    <bool name="SelectionGroup">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <int name="SelectionOrder">0</int>
                    <UDim2 name="Size">
                      <XS>0.4</XS>
                      <XO>0</XO>
                      <YS>0.4</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags"></BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">3</int>
                  </Properties>
                  <Item class="Frame" referent="143">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize"></BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236</R>
                        <G>0.16470589</G>
                        <B>0.20784315</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <token name="SelectionBehaviorDown">0</token>
                      <token name="SelectionBehaviorLeft">0</token>
                      <token name="SelectionBehaviorRight">0</token>
                      <token name="SelectionBehaviorUp">0</token>
                      <bool name="SelectionGroup">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <int name="SelectionOrder">0</int>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags"></BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="ImageLabel" referent="144">
                      <Properties>
                        <string name="Name">ImageLabel</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236</R>
                          <G>0.16470589</G>
                          <B>0.20784315</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <Content name="Image">
                          <url>rbxassetid://1244653012</url>
                        </Content>
                        <Color3 name="ImageColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <Vector2 name="ImageRectOffset">
                          <X>500</X>
                          <Y>600</Y>
                        </Vector2>
                        <Vector2 name="ImageRectSize">
                          <X>100</X>
                          <Y>100</Y>
                        </Vector2>
                        <float name="ImageTransparency">0</float>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0</XS>
                          <XO>0</XO>
                          <YS>0</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="ResampleMode">0</token>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <token name="ScaleType">3</token>
                        <bool name="Selectable">false</bool>
                        <token name="SelectionBehaviorDown">0</token>
                        <token name="SelectionBehaviorLeft">0</token>
                        <token name="SelectionBehaviorRight">0</token>
                        <token name="SelectionBehaviorUp">0</token>
                        <bool name="SelectionGroup">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <int name="SelectionOrder">0</int>
                        <UDim2 name="Size">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <Rect2D name="SliceCenter">
                          <min>
                            <X>0</X>
                            <Y>0</Y>
                          </min>
                          <max>
                            <X>0</X>
                            <Y>0</Y>
                          </max>
                        </Rect2D>
                        <float name="SliceScale">1</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                        <UDim2 name="TileSize">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                    </Item>
                    <Item class="UIScale" referent="145">
                      <Properties>
                        <string name="Name">UIScale</string>
                        <BinaryString name="AttributesSerialize"></BinaryString>
                        <float name="Scale">1.2</float>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags"></BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="ScreenGui" referent="146">
      <Properties>
        <string name="Name">white</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <bool name="AutoLocalize">true</bool>
        <int name="DisplayOrder">0</int>
        <bool name="Enabled">false</bool>
        <bool name="IgnoreGuiInset">true</bool>
        <bool name="ResetOnSpawn">false</bool>
        <Ref name="RootLocalizationTable">null</Ref>
        <token name="SelectionBehaviorDown">0</token>
        <token name="SelectionBehaviorLeft">0</token>
        <token name="SelectionBehaviorRight">0</token>
        <token name="SelectionBehaviorUp">0</token>
        <bool name="SelectionGroup">false</bool>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <token name="ZIndexBehavior">1</token>
      </Properties>
      <Item class="Frame" referent="147">
        <Properties>
          <string name="Name">Frame</string>
          <bool name="Active">false</bool>
          <Vector2 name="AnchorPoint">
            <X>0</X>
            <Y>0</Y>
          </Vector2>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <bool name="AutoLocalize">true</bool>
          <token name="AutomaticSize">0</token>
          <Color3 name="BackgroundColor3">
            <R>1</R>
            <G>1</G>
            <B>1</B>
          </Color3>
          <float name="BackgroundTransparency">0</float>
          <Color3 name="BorderColor3">
            <R>0.10588236</R>
            <G>0.16470589</G>
            <B>0.20784315</B>
          </Color3>
          <token name="BorderMode">0</token>
          <int name="BorderSizePixel">1</int>
          <bool name="ClipsDescendants">false</bool>
          <bool name="Draggable">false</bool>
          <int name="LayoutOrder">0</int>
          <Ref name="NextSelectionDown">null</Ref>
          <Ref name="NextSelectionLeft">null</Ref>
          <Ref name="NextSelectionRight">null</Ref>
          <Ref name="NextSelectionUp">null</Ref>
          <UDim2 name="Position">
            <XS>0</XS>
            <XO>0</XO>
            <YS>0</YS>
            <YO>0</YO>
          </UDim2>
          <Ref name="RootLocalizationTable">null</Ref>
          <float name="Rotation">0</float>
          <bool name="Selectable">false</bool>
          <token name="SelectionBehaviorDown">0</token>
          <token name="SelectionBehaviorLeft">0</token>
          <token name="SelectionBehaviorRight">0</token>
          <token name="SelectionBehaviorUp">0</token>
          <bool name="SelectionGroup">false</bool>
          <Ref name="SelectionImageObject">null</Ref>
          <int name="SelectionOrder">0</int>
          <UDim2 name="Size">
            <XS>1</XS>
            <XO>0</XO>
            <YS>1</YS>
            <YO>0</YO>
          </UDim2>
          <token name="SizeConstraint">0</token>
          <int64 name="SourceAssetId">-1</int64>
          <token name="Style">0</token>
          <BinaryString name="Tags"></BinaryString>
          <bool name="Visible">true</bool>
          <int name="ZIndex">1</int>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="LocalizationService" referent="148">
    <Properties>
      <string name="Name">LocalizationService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="TeleportService" referent="149">
    <Properties>
      <string name="Name">Teleport Service</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="CollectionService" referent="150">
    <Properties>
      <string name="Name">CollectionService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="PhysicsService" referent="151">
    <Properties>
      <string name="Name">PhysicsService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Geometry" referent="152">
    <Properties>
      <string name="Name">Geometry</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="InsertService" referent="153">
    <Properties>
      <string name="Name">InsertService</string>
      <bool name="AllowClientInsertModels">false</bool>
      <bool name="AllowInsertFreeModels">false</bool>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
    <Item class="StringValue" referent="154">
      <Properties>
        <string name="Name">InsertionHash</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <string name="Value">{9964E4EF-B0D2-4AFE-A149-1003916A7AEF}</string>
      </Properties>
    </Item>
  </Item>
  <Item class="GamePassService" referent="155">
    <Properties>
      <string name="Name">GamePassService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Debris" referent="156">
    <Properties>
      <string name="Name">Debris</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int name="MaxItems">1000</int>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="CookiesService" referent="157">
    <Properties>
      <string name="Name">CookiesService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="VRService" referent="158">
    <Properties>
      <string name="Name">VRService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="ContextActionService" referent="159">
    <Properties>
      <string name="Name">ContextActionService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="ScriptService" referent="160">
    <Properties>
      <string name="Name">Instance</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="AssetService" referent="161">
    <Properties>
      <string name="Name">AssetService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="TouchInputService" referent="162">
    <Properties>
      <string name="Name">TouchInputService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="AnalyticsService" referent="163">
    <Properties>
      <string name="Name">AnalyticsService</string>
      <string name="ApiKey"></string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Instance" referent="164">
    <Properties>
      <string name="Name">FilteredSelection</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Selection" referent="165">
    <Properties>
      <string name="Name">Selection</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Instance" referent="166">
    <Properties>
      <string name="Name">FilteredSelection</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="ServerScriptService" referent="167">
    <Properties>
      <string name="Name">ServerScriptService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="LoadStringEnabled">false</bool>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
    <Item class="Folder" referent="168">
      <Properties>
        <string name="Name">Game</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="Script" referent="169">
        <Properties>
          <string name="Name">KnitServer</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <bool name="Disabled">false</bool>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezZBNjUyOEU4LTJCOTYtNEE5Ny1CMjZGLTUzRDBEOUNBQkZBNn0=]]></BinaryString>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Loader = require(ReplicatedStorage.Packages.Loader)

Knit.AddServicesDeep(ServerStorage.Game.Services)
Loader.LoadChildren(ServerStorage.Game.Components)

Knit.Start()
:andThen(function()
	print("KnitServer Started")
end)
:catch(warn)
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerStorage" referent="170">
    <Properties>
      <string name="Name">ServerStorage</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
    <Item class="Folder" referent="171">
      <Properties>
        <string name="Name">TagList</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags">VGFnRWRpdG9yVGFnQ29udGFpbmVy</BinaryString>
      </Properties>
      <Item class="Configuration" referent="172">
        <Properties>
          <string name="Name">Plot</string>
          <BinaryString name="AttributesSerialize">BgAAAAsAAABBbHdheXNPblRvcAMABQAAAENvbG9yD3KGgD5Papw+aTUCPwgAAABEcmF3VHlwZQIDAAAAQm94BQAAAEdyb3VwAgAAAAAEAAAASWNvbgIJAAAAdGFnX2dyZWVuBwAAAFZpc2libGUDAQ==</BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="173">
      <Properties>
        <string name="Name">Game</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="Folder" referent="174">
        <Properties>
          <string name="Name">Components</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="175">
          <Properties>
            <string name="Name">Plot</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezMxOUY1N0Y3LTBEQjEtNDE4RS05RjNBLUI2RkJCRTg5NzkwQn0=]]></BinaryString>
            <string name="Source"><![CDATA[-- Component
-- 0_1195
-- May 07, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Http = game:GetService("HttpService")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Component = require(ReplicatedStorage.Packages.Component)
local Janitor = require(ReplicatedStorage.Packages.Janitor)
local GridModules = require(ReplicatedStorage.Game.Shared.Grid)
local State = require(ServerStorage.Game.Modules.State)
local Fusion = require(ReplicatedStorage.Packages.Fusion)
local ItemData = require(ReplicatedStorage.Game.Shared.ItemData)
local Sift = require(ReplicatedStorage.Packages.sift)
local Grid = GridModules.Grid
local GridUtil = GridModules.GridUtil
local CellObject = GridModules.CellObject

local Class = Component.new({
	Tag = "Plot",
	Ancestors = { workspace },
})

function Class:GetOwner()
	local instance: Folder = self.Instance
	local ownerId = instance:GetAttribute("OwnerId")
	local UserService = Knit.GetService("UserService")
	return UserService:GetUserById(ownerId)
end

function Class:SetOwner(user)
	self:ClearOwner()

	local instance: Folder = self.Instance
	instance:SetAttribute("OwnerId", user.Player.UserId)

	State:dispatch({
		type = "SetObjects",
		key = self.Key,
		objects = user.Data.GridObjects,
	})
end

function Class:ClearOwner()
	self.Grid:Clear()
	State:dispatch({
		type = "SetObjects",
		key = self.Key,
		objects = {},
	})
	local instance: Folder = self.Instance
	instance:SetAttribute("OwnerId", nil)
end

function Class:Construct()
	local instance: Folder = self.Instance
	self._janitor = Janitor.new()

	self.Key = Http:GenerateGUID(false)

	local gridModel: Model = instance.Grid
	local origin = gridModel:GetPivot()
	local plotRoot = gridModel.PrimaryPart
	local size = Vector2.new(plotRoot.Size.X, plotRoot.Size.Z)
	local grid = Grid.new(origin, size, 4)
	self.Grid = grid
	self._janitor:Add(function()
		self.Grid:Destroy()
	end)

	State:dispatch({
		type = "SetObjects",
		key = self.Key,
		objects = {},
	})
	self._janitor:Add(function()
		State:dispatch({
			type = "RemovePlot",
			key = self.Key,
		})
	end)

	self._objects = Fusion.State({})
	self._janitor:Add(function()
		self._objects:set({}, true)
	end)

	local computed = Fusion.ComputedPairs(self._objects, function(_index: number, value)
		local itemId, position, rotation = GridUtil.DeserializeCell(value)
		local baseItemData: ItemData.ItemData = ItemData[tonumber(itemId)]

		local gridPositionList = GridUtil.GetGridPositionList(
			baseItemData.Id,
			position,
			GridUtil.Directions[rotation + 1]
		)

		local prefab = baseItemData.Prefab
		prefab = prefab:Clone()
		prefab.PrimaryPart.PivotOffset = CFrame.new(-prefab.PrimaryPart.Size / 2)

		local rotationOffset = GridUtil.GetRotationOffset(baseItemData.Id, GridUtil.Directions[rotation + 1])
		local placedObjectWorldCFrame: CFrame = grid:GetWorldCFrame(position)
			* CFrame.new(Vector3.new(rotationOffset.X, 0, rotationOffset.Y) * grid.cellSize)
			* CFrame.Angles(0, math.pi / 2 * rotation, 0)

		prefab:PivotTo(placedObjectWorldCFrame)
		prefab.PrimaryPart.PivotOffset = CFrame.new(0, -prefab.PrimaryPart.Size / 2, 0)

		local cellObject = CellObject.new(prefab, position, GridUtil.Directions[rotation + 1])
		-- place object in data
		GridUtil.PlaceObjectInGrid(grid, gridPositionList, cellObject)
		return { cellObject, gridPositionList } -- need to return cellObject for parenting
	end, function(data)
		local gridPositionList = data[2]
		-- RemoveObjectFromGrid calls cell:Clear() which calls cellObject:Destroy()
		GridUtil.RemoveObjectFromGrid(grid, gridPositionList)
	end)

	local folder: Folder = Fusion.New("Folder")({
		Name = "Assets",
		Parent = instance,

		[Fusion.Children] = { -- TODO fix not parenting to workspace. Fusion.Instances.Scheduler uses RenderStepped instead of Hearbeat
			Fusion.ComputedPairs(computed, function(_i, data) -- hm, this works
				-- parent object
				local cellObject = data[1]
				local prefab = cellObject:Get()
				return prefab
			end),
		},
	})
	self._janitor:Add(function()
		folder:Destroy()
	end)
	-- watch for plot state
	local function onChange(newObjects)
		-- TODO throttle
		self._objects:set(newObjects)
	end

	local selector = function(state)
		return state.plots[self.Key]
	end

	local value = selector(State:getState())

	self._janitor:Add(State.changed:connect(function(newState, _oldState)
		local newValue = selector(newState)
		if Sift.Array.equalsDeep(newValue, value) then
			return
		end
		value = newValue
		onChange(value)
	end).disconnect)

	onChange(value)
end

function Class:Start() end

function Class:Stop()
	self:ClearOwner()
	self._janitor:Destroy()
end

return Class
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="176">
        <Properties>
          <string name="Name">Modules</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="177">
          <Properties>
            <string name="Name">ProfileService</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0IyRDhFQjVCLTU1QzItNEY1QS05MjY4LTM3NjZFNzQ0NEY5Mn0=]]></BinaryString>
            <string name="Source">-- local Madwork = _G.Madwork
--[[
{Madwork}

-[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API
	
	Official documentation:
		https://madstudioroblox.github.io/ProfileService/

	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.
		
	Members:
	
		ProfileService.ServiceLocked         [bool]
		
		ProfileService.IssueSignal           [ScriptSignal] (error_message, profile_store_name, profile_key)
		ProfileService.CorruptionSignal      [ScriptSignal] (profile_store_name, profile_key)
		ProfileService.CriticalStateSignal   [ScriptSignal] (is_critical_state)
	
	Functions:
	
		ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]
			profile_store_index   [string] -- DataStore name
			OR
			profile_store_index   [table]: -- Allows the developer to define more GlobalDataStore variables
				{
					Name = "StoreName", -- [string] -- DataStore name
					-- Optional arguments:
					Scope = "StoreScope", -- [string] -- DataStore scope
				}
			profile_template      [table] -- Profiles will default to given table (hard-copy) when no data was saved previously

		ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)
			-- Returns true if ProfileService is connected to live Roblox DataStores
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore
		
	Methods [ProfileStore]:
	
		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile] or nil -- not_released_handler(place_id, game_job_id)
			profile_key            [string] -- DataStore key
			not_released_handler   nil or []: -- Defaults to "ForceLoad"
				[string] "ForceLoad" -- Force loads profile on first call
				OR
				[string] "Steal" -- Steals the profile ignoring it's session lock
				OR
				[function] (place_id, game_job_id) --> [string] "Repeat", "Cancel", "ForceLoad" or "Steal"
					place_id      [number] or nil
					game_job_id   [string] or nil

				-- not_released_handler [function] will be triggered in cases where the profile is not released by a session. This
				--	function may yield for as long as desirable and must return one of three string values:

						["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
						["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
						["ForceLoad"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards
							and release the profile for another session that has loaded the profile
						["Steal"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying
							a session lock for this session.

		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates] or nil
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
			profile_key      [string] -- DataStore key
			update_handler   [function] (global_updates [GlobalUpdates])
			
		ProfileStore:ViewProfileAsync(profile_key, version) --> [Profile] or nil
			-- Reads profile without requesting a session lock; Data will not be saved and profile doesn't need to be released
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date) --> [ProfileVersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool]
			-- Completely wipes out profile data from the DataStore / mock DataStore with no way to recover it.
						
		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":
		
			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)

	Methods [ProfileVersionQuery]:

		ProfileVersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile has the same rules as profile returned by :ViewProfileAsync()
		
	Members [Profile]:
	
		Profile.Data              [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData          [table] (Read-only) -- Information about this profile
		
			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after
				they pile up)

		Profile.MetaTagsUpdated   [ScriptSignal] (meta_tags_latest) -- Fires after every auto-save, after
			--	Profile.MetaData.MetaTagsLatest has been updated with the version that's guaranteed to be saved;
			--  .MetaTagsUpdated will fire regardless of whether .MetaTagsLatest changed after update;
			--	.MetaTagsUpdated may fire after the Profile is released - changes to Profile.Data are not saved
			--	after release.

		Profile.RobloxMetaData    [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds           [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo           [DataStoreKeyInfo]
		Profile.KeyInfoUpdated    [ScriptSignal] (key_info [DataStoreKeyInfo])
		
		Profile.GlobalUpdates     [GlobalUpdates]
		
	Methods [Profile]:
	
		-- SAFE METHODS - Will not error after profile expires:
		Profile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to
			
		Profile:GetMetaTag(tag_name) --> value [any]
			tag_name   [string]
		
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
		
		Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
			-- WARNING: Profiles can be released externally if another session force-loads
			--	this profile - use :ListenToRelease() to handle player leaving cleanup.
			
		Profile:Release() -- Call after the session has finished working with this profile
			e.g., after the player leaves (Profile object will become expired) (Does not yield)

		Profile:ListenToHopReady(listener) --> [ScriptConnection] () -- Passed listener will be executed after the releasing UpdateAsync call finishes;
			--	Wrap universe teleport requests with this method AFTER releasing the profile to improve session lock sharing between universe places;
			--  :ListenToHopReady() will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a release happens
			--	next to an auto-update in regular usage scenarios.

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)
			user_id   [number]

		Profile:Identify() --> [string] -- Returns a string containing DataStore name, scope and key; Used for debug;
			-- Example return: "[Store:"GameData";Scope:"Live";Key:"Player_2312310"]"
		
		Profile:SetMetaTag(tag_name, value) -- Equivalent of Profile.MetaData.MetaTags[tag_name] = value
			tag_name   [string]
			value      [any]
		
		Profile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)

		-- VIEW-MODE ONLY:

		Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

		Profile:OverwriteAsync() -- (Yields) Saves the profile payload to the DataStore and removes the session lock
		
	Methods [GlobalUpdates]:
	
	-- ALWAYS PUBLIC:
		GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data [table]}, ...}
		GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data [table]}, ...}
		
	-- ONLY WHEN FROM "Profile.GlobalUpdates":
		GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] (update_id, update_data)
			update_data   [table]
		GlobalUpdates:LockActiveUpdate(update_id)  -- WARNING: will error after profile expires
		GlobalUpdates:ClearLockedUpdate(update_id) -- WARNING: will error after profile expires
		
	-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
		GlobalUpdates:AddActiveUpdate(update_data)
			update_data   [table]
		GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
			update_data   [table]
		GlobalUpdates:ClearActiveUpdate(update_id)
		
--]]

local SETTINGS = {

	AutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)
	RobloxWriteCooldown = 7, -- Seconds between successive DataStore calls for the same key
	ForceLoadMaxSteps = 8, -- Steps taken before ForceLoad request steals the active session for a profile
	AssumeDeadSessionLock = 30 * 60, -- (seconds) If a profile hasn't been updated for 30 minutes, assume the session lock is dead
		-- As of writing, os.time() is not completely reliable, so we can only assume session locks are dead after a significant amount of time.
	
	IssueCountForCriticalState = 5, -- Issues to collect to announce critical state
	IssueLast = 120, -- Seconds
	CriticalStateLast = 120, -- Seconds
	
	MetaTagsUpdatedValues = { -- Technical stuff - do not alter
		ProfileCreateTime = true,
		SessionLoadCount = true,
		ActiveSession = true,
		ForceLoadSession = true,
		LastUpdate = true,
	},
	
}

local Madwork -- Standalone Madwork reference for portable version of ProfileService
do

	local MadworkScriptSignal = {}

	local FreeRunnerThread = nil
	
	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		FreeRunnerThread = acquired_runner_thread
	end
	
	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end
	
	-- ScriptConnection object:

	local ScriptConnection = {
		--[[
			_listener = listener,
			_script_signal = script_signal,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,
			
			_next = next_script_connection,
			_is_connected = is_connected,
		--]]
	}
	ScriptConnection.__index = ScriptConnection

	function ScriptConnection:Disconnect()

		if self._is_connected == false then
			return
		end

		self._is_connected = false
		self._script_signal._listener_count -= 1

		if self._script_signal._head == self then
			self._script_signal._head = self._next
		else
			local prev = self._script_signal._head
			while prev ~= nil and prev._next ~= self do
				prev = prev._next
			end
			if prev ~= nil then
				prev._next = self._next
			end
		end

		if self._disconnect_listener ~= nil then
			if not FreeRunnerThread then
				FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
			end
			task.spawn(FreeRunnerThread, self._disconnect_listener, self._disconnect_param)
			self._disconnect_listener = nil
		end

	end
	
	-- ScriptSignal object:

	local ScriptSignal = {
		--[[
			_head = nil,
			_listener_count = 0,
		--]]
	}
	ScriptSignal.__index = ScriptSignal

	function ScriptSignal:Connect(listener, disconnect_listener, disconnect_param) --> [ScriptConnection]

		local script_connection = {
			_listener = listener,
			_script_signal = self,
			_disconnect_listener = disconnect_listener,
			_disconnect_param = disconnect_param,

			_next = self._head,
			_is_connected = true,
		}
		setmetatable(script_connection, ScriptConnection)

		self._head = script_connection
		self._listener_count += 1

		return script_connection

	end

	function ScriptSignal:GetListenerCount() --> [number]
		return self._listener_count
	end

	function ScriptSignal:Fire(...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item._listener, ...)
			end
			item = item._next
		end
	end

	function ScriptSignal:FireUntil(continue_callback, ...)
		local item = self._head
		while item ~= nil do
			if item._is_connected == true then
				item._listener(...)
				if continue_callback() ~= true then
					return
				end
			end
			item = item._next
		end
	end

	function MadworkScriptSignal.NewScriptSignal() --> [ScriptSignal]
		return {
			_head = nil,
			_listener_count = 0,
			Connect = ScriptSignal.Connect,
			GetListenerCount = ScriptSignal.GetListenerCount,
			Fire = ScriptSignal.Fire,
			FireUntil = ScriptSignal.FireUntil,
		}
	end

	-- Madwork framework namespace:
	
	Madwork = {
		NewScriptSignal = MadworkScriptSignal.NewScriptSignal,
		ConnectToOnClose = function(task, run_in_studio_mode)
			if game:GetService("RunService"):IsStudio() == false or run_in_studio_mode == true then
				game:BindToClose(task)
			end
		end,
	}

end

----- Service Table -----

local ProfileService = {

	ServiceLocked = false, -- Set to true once the server is shutting down

	IssueSignal = Madwork.NewScriptSignal(), -- (error_message, profile_store_name, profile_key) -- Fired when a DataStore API call throws an error
	CorruptionSignal = Madwork.NewScriptSignal(), -- (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has
	-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a noon table value

	CriticalState = false, -- Set to true while DataStore service is throwing too many errors
	CriticalStateSignal = Madwork.NewScriptSignal(), -- (is_critical_state) -- Fired when CriticalState is set to true
	-- (You may alert players with this, or set up analytics)

	ServiceIssueCount = 0,

	_active_profile_stores = {}, -- {profile_store, ...}

	_auto_save_list = {}, -- {profile, ...} -- loaded profile table which will be circularly auto-saved

	_issue_queue = {}, -- [table] {issue_time, ...}
	_critical_state_start = 0, -- [number] 0 = no critical state / os.clock() = critical state start

	-- Debug:
	_mock_data_store = {},
	_user_mock_data_store = {},

	_use_mock_data_store = false,

}

--[[
	Saved profile structure:
	
	DataStoreProfile = {
		Data = {},
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			MetaTags = {},
			LastUpdate = 0, -- os.time()
		},
		RobloxMetaData = {},
		UserIds = {},
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
	
	OR
	
	DataStoreProfile = {
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
--]]

----- Private Variables -----

local ActiveProfileStores = ProfileService._active_profile_stores
local AutoSaveList = ProfileService._auto_save_list
local IssueQueue = ProfileService._issue_queue

local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local IsLiveCheckActive = false

local UseMockDataStore = false
local MockDataStore = ProfileService._mock_data_store -- Mock data store used when API access is disabled

local UserMockDataStore = ProfileService._user_mock_data_store -- Separate mock data store accessed via ProfileStore.Mock
local UseMockTag = {}

local CustomWriteQueue = {
	--[[
		[store] = {
			[key] = {
				LastWrite = os.clock(),
				Queue = {callback, ...},
				CleanupJob = nil,
			},
			...
		},
		...
	--]]
}

----- Utils -----

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

----- Private functions -----

local function IdentifyProfile(store_name, store_scope, key)
	return string.format(
		"[Store:\"%s\";%sKey:\"%s\"]",
		store_name,
		store_scope ~= nil and string.format("Scope:\"%s\";", store_scope) or "",
		key
	)
end

local function CustomWriteQueueCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		CustomWriteQueue[store][key] = nil
		if next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueMarkForCleanup(store, key)
	if CustomWriteQueue[store] ~= nil then
		if CustomWriteQueue[store][key] ~= nil then

			local queue_data = CustomWriteQueue[store][key]
			local queue = queue_data.Queue

			if queue_data.CleanupJob == nil then

				queue_data.CleanupJob = RunService.Heartbeat:Connect(function()
					if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
						queue_data.CleanupJob:Disconnect()
						CustomWriteQueueCleanup(store, key)
					end
				end)

			end

		elseif next(CustomWriteQueue[store]) == nil then
			CustomWriteQueue[store] = nil
		end
	end
end

local function CustomWriteQueueAsync(callback, store, key) --> ... -- Passed return from callback

	if CustomWriteQueue[store] == nil then
		CustomWriteQueue[store] = {}
	end
	if CustomWriteQueue[store][key] == nil then
		CustomWriteQueue[store][key] = {LastWrite = 0, Queue = {}, CleanupJob = nil}
	end

	local queue_data = CustomWriteQueue[store][key]
	local queue = queue_data.Queue

	-- Cleanup job:

	if queue_data.CleanupJob ~= nil then
		queue_data.CleanupJob:Disconnect()
		queue_data.CleanupJob = nil
	end

	-- Queue logic:

	if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and #queue == 0 then
		queue_data.LastWrite = os.clock()
		return callback()
	else
		table.insert(queue, callback)
		while true do
			if os.clock() - queue_data.LastWrite > SETTINGS.RobloxWriteCooldown and queue[1] == callback then
				table.remove(queue, 1)
				queue_data.LastWrite = os.clock()
				return callback()
			end
			task.wait()
		end
	end

end

local function IsCustomWriteQueueEmptyFor(store, key) --> is_empty [bool]
	local lookup = CustomWriteQueue[store]
	if lookup ~= nil then
		lookup = lookup[key]
		return lookup == nil or #lookup.Queue == 0
	end
	return true
end

local function WaitForLiveAccessCheck() -- This function was created to prevent the ProfileService module yielding execution when required
	while IsLiveCheckActive == true do
		task.wait()
	end
end

local function WaitForPendingProfileStore(profile_store)
	while profile_store._is_pending == true do
		task.wait()
	end
end

local function RegisterIssue(error_message, store_name, store_scope, profile_key) -- Called when a DataStore API call errors
	warn("[ProfileService]: DataStore API error " .. IdentifyProfile(store_name, store_scope, profile_key) .. " - \"" .. tostring(error_message) .. "\"")
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	ProfileService.IssueSignal:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterCorruption(store_name, store_scope, profile_key) -- Called when a corrupted profile is loaded
	warn("[ProfileService]: Resolved profile corruption " .. IdentifyProfile(store_name, store_scope, profile_key))
	ProfileService.CorruptionSignal:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = transform
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

--[[
update_settings = {
	ExistingProfileHandle = function(latest_data),
	MissingProfileHandle = function(latest_data),
	EditProfile = function(lastest_data),
}
--]]
local function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings, is_user_mock, is_get_call, version) --> loaded_data, key_info
	local loaded_data, key_info
	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local data_corrupted = false
			local global_updates_data = {0, {}}

			if latest_data == nil then
				missing_profile = true
			elseif type(latest_data) ~= "table" then
				missing_profile = true
				data_corrupted = true
			end

			if type(latest_data) == "table" then
				-- Case #1: Profile was loaded
				if type(latest_data.Data) == "table"
					and type(latest_data.MetaData) == "table"
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates
					if update_settings.ExistingProfileHandle ~= nil then
						update_settings.ExistingProfileHandle(latest_data)
					end
					-- Case #2: Profile was not loaded but GlobalUpdate data exists
				elseif latest_data.Data == nil
					and latest_data.MetaData == nil
					and type(latest_data.GlobalUpdates) == "table" then

					latest_data.WasCorrupted = false -- Must be set to false if set previously
					global_updates_data = latest_data.GlobalUpdates or global_updates_data
					missing_profile = true
				else
					missing_profile = true
					data_corrupted = true
				end
			end

			-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates_data,
				}
				if update_settings.MissingProfileHandle ~= nil then
					update_settings.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if update_settings.EditProfile ~= nil then
				update_settings.EditProfile(latest_data)
			end

			-- Data corruption handling (Silently override with empty profile) (Also run Case #1)
			if data_corrupted == true then
				latest_data.WasCorrupted = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end
		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock
			loaded_data, key_info = MockUpdateAsync(UserMockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		elseif UseMockDataStore == true then -- Used when API access is disabled
			loaded_data, key_info = MockUpdateAsync(MockDataStore, profile_store._profile_store_lookup, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield
		else
			loaded_data, key_info = CustomWriteQueueAsync(
				function() -- Callback
					if is_get_call == true then
						local get_data, get_key_info
						if version ~= nil then
							local success, error_message = pcall(function()
								get_data, get_key_info = profile_store._global_data_store:GetVersionAsync(profile_key, version)
							end)
							if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
								warn("[ProfileService]: Passed version argument is not valid; Traceback:\n" .. debug.traceback())
							end
						else
							get_data, get_key_info = profile_store._global_data_store:GetAsync(profile_key)
						end
						get_data = transform_function(get_data)
						return get_data, get_key_info
					else
						return profile_store._global_data_store:UpdateAsync(profile_key, transform_function)
					end
				end,
				profile_store._profile_store_lookup, -- Store
				profile_key -- Key
			)
		end
	end)
	if success == true and type(loaded_data) == "table" then
		-- Corruption handling:
		if loaded_data.WasCorrupted == true and is_get_call ~= true then
			RegisterCorruption(
				profile_store._profile_store_name,
				profile_store._profile_store_scope,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		RegisterIssue(
			(error_message ~= nil) and error_message or "Undefined error",
			profile_store._profile_store_name,
			profile_store._profile_store_scope,
			profile_key
		)
		-- Return nothing:
		return nil
	end
end

local function RemoveProfileFromAutoSave(profile)
	local auto_save_index = table.find(AutoSaveList, profile)
	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index &lt; AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end
end

local function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon
	-- Add at AutoSaveIndex and move AutoSaveIndex right:
	table.insert(AutoSaveList, AutoSaveIndex, profile)
	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end
end

local function ReleaseProfileInternally(profile)
	-- 1) Remove profile object from ProfileService references: --
	-- Clear reference in ProfileStore:
	local profile_store = profile._profile_store
	local loaded_profiles = profile._is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
	loaded_profiles[profile._profile_key] = nil
	if next(profile_store._loaded_profiles) == nil and next(profile_store._mock_loaded_profiles) == nil then -- ProfileStore has turned inactive
		local index = table.find(ActiveProfileStores, profile_store)
		if index ~= nil then
			table.remove(ActiveProfileStores, index)
		end
	end
	-- Clear auto update reference:
	RemoveProfileFromAutoSave(profile)
	-- 2) Trigger release listeners: --
	local place_id
	local game_job_id
	local active_session = profile.MetaData.ActiveSession
	if active_session ~= nil then
		place_id = active_session[1]
		game_job_id = active_session[2]
	end
	profile._release_listeners:Fire(place_id, game_job_id)
end

local function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
	local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
	local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
	local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
	-- "old_" or "new_" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	for _, new_global_update in ipairs(new_global_updates_data[2]) do
		-- Find old global update with the same update_id:
		local old_global_update
		for _, global_update in ipairs(old_global_updates_data[2]) do
			if global_update[1] == new_global_update[1] then
				old_global_update = global_update
				break
			end
		end
		-- A global update is new when it didn't exist before or its version_id or update_locked state changed:
		local is_new = false
		if old_global_update == nil or new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then
			is_new = true
		end
		if is_new == true then
			-- Active global updates:
			if new_global_update[3] == false then
				-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)
				local is_pending_lock = false
				for _, update_id in ipairs(pending_update_lock) do
					if new_global_update[1] == update_id then
						is_pending_lock = true
						break
					end
				end
				if is_pending_lock == false then
					-- Trigger new active update listeners:
					global_updates_object._new_active_update_listeners:Fire(new_global_update[1], new_global_update[4])
				end
			end
			-- Locked global updates:
			if new_global_update[3] == true then
				-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)
				local is_pending_clear = false
				for _, update_id in ipairs(pending_update_clear) do
					if new_global_update[1] == update_id then
						is_pending_clear = true
						break
					end
				end
				if is_pending_clear == false then
					-- Trigger new locked update listeners:

					global_updates_object._new_locked_update_listeners:FireUntil(
						function()
							-- Check if listener marked the update to be cleared:
							-- Normally there should be only one listener per profile for new locked global updates, but
							-- in case several listeners are connected we will not trigger more listeners after one listener
							-- marks the locked global update to be cleared.
							return table.find(pending_update_clear, new_global_update[1]) == nil
						end,
						new_global_update[1], new_global_update[4]
					)

				end
			end
		end
	end
end

local function SaveProfileAsync(profile, release_from_session, is_overwriting)
	if type(profile.Data) ~= "table" then
		RegisterCorruption(
			profile._profile_store._profile_store_name,
			profile._profile_store._profile_store_scope,
			profile._profile_key
		)
		error("[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! Profile: " .. profile:Identify())
	end
	if release_from_session == true and is_overwriting ~= true then
		ReleaseProfileInternally(profile)
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1
	local last_session_load_count = profile.MetaData.SessionLoadCount
	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again
	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	while repeat_save_flag == true do
		if release_from_session ~= true then
			repeat_save_flag = false
		end
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			profile._profile_store,
			profile._profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local session_owns_profile = false
					local force_load_pending = false

					if is_overwriting ~= true then
						-- 1) Check if this session still owns the profile: --
						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
						end
						if type(force_load_session) == "table" then
							force_load_pending = not IsThisSession(force_load_session)
						end
					else
						session_owns_profile = true
					end

					if session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile

						if is_overwriting ~= true then
							-- 2) Manage global updates: --
							local latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
							local latest_global_updates_list = latest_global_updates_data[2]

							local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
							local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
							local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
							-- Active update locking:
							for i = 1, #latest_global_updates_list do
								for _, lock_id in ipairs(pending_update_lock) do
									if latest_global_updates_list[i][1] == lock_id then
										latest_global_updates_list[i][3] = true
										break
									end
								end
							end
							-- Locked update clearing:
							for _, clear_id in ipairs(pending_update_clear) do
								for i = 1, #latest_global_updates_list do
									if latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then
										table.remove(latest_global_updates_list, i)
										break
									end
								end
							end
						end

						-- 3) Save profile data: --
						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then
							latest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData
							latest_data.MetaData.LastUpdate = os.time()
							if release_from_session == true or force_load_pending == true then
								latest_data.MetaData.ActiveSession = nil
							end
						else
							latest_data.MetaData = profile.MetaData
							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil
							latest_data.GlobalUpdates = profile.GlobalUpdates._updates_latest
						end

					end
				end,
			},
			profile._is_user_mock
		)
		if loaded_data ~= nil and key_info ~= nil then
			if is_overwriting == true then
				break
			end
			repeat_save_flag = false
			-- 4) Set latest data in profile: --
			-- Updating DataStoreKeyInfo:
			profile.KeyInfo = key_info
			-- Setting global updates:
			local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
			local old_global_updates_data = global_updates_object._updates_latest
			local new_global_updates_data = loaded_data.GlobalUpdates
			global_updates_object._updates_latest = new_global_updates_data
			-- Setting MetaData:
			local session_meta_data = profile.MetaData
			local latest_meta_data = loaded_data.MetaData
			for key in pairs(SETTINGS.MetaTagsUpdatedValues) do
				session_meta_data[key] = latest_meta_data[key]
			end
			session_meta_data.MetaTagsLatest = latest_meta_data.MetaTags
			-- 5) Check if session still owns the profile: --
			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false
			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == last_session_load_count
			end
			local is_active = profile:IsActive()
			if session_owns_profile == true then
				-- 6) Check for new global updates: --
				if is_active == true then -- Profile could've been released before the saving thread finished
					CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
				end
			else
				-- Session no longer owns the profile:
				-- 7) Release profile if it hasn't been released yet: --
				if is_active == true then
					ReleaseProfileInternally(profile)
				end
				-- Cleanup reference in custom write queue:
				CustomWriteQueueMarkForCleanup(profile._profile_store._profile_store_lookup, profile._profile_key)
				-- Hop ready listeners:
				if profile._hop_ready == false then
					profile._hop_ready = true
					profile._hop_ready_listeners:Fire()
				end
			end
			-- Signaling MetaTagsUpdated listeners after a possible external profile release was handled:
			profile.MetaTagsUpdated:Fire(profile.MetaData.MetaTagsLatest)
			-- Signaling KeyInfoUpdated listeners:
			profile.KeyInfoUpdated:Fire(key_info)
		elseif repeat_save_flag == true then
			task.wait() -- Prevent infinite loop in case DataStore API does not yield
		end
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1
end

----- Public functions -----

-- GlobalUpdates object:

local GlobalUpdates = {
	--[[
		_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
		_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
		_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
		
		_new_active_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		_new_locked_update_listeners = [ScriptSignal] / nil, -- [table / nil]
		
		_profile = Profile / nil, -- [Profile / nil]
		
		_update_handler_mode = true / nil, -- [bool / nil]
	--]]
}
GlobalUpdates.__index = GlobalUpdates

-- ALWAYS PUBLIC:
function GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == false then
			local is_pending_lock = false
			if self._pending_update_lock ~= nil then
				for _, update_id in ipairs(self._pending_update_lock) do
					if global_update[1] == update_id then
						is_pending_lock = true -- Exclude global updates pending to be locked
						break
					end
				end
			end
			if is_pending_lock == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

function GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == true then
			local is_pending_clear = false
			if self._pending_update_clear ~= nil then
				for _, update_id in ipairs(self._pending_update_clear) do
					if global_update[1] == update_id then
						is_pending_clear = true -- Exclude global updates pending to be cleared
						break
					end
				end
			end
			if is_pending_clear == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

-- ONLY WHEN FROM "Profile.GlobalUpdates":
function GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_active_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_active_update_listeners:Connect(listener)
end

function GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_locked_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	return self._new_locked_update_listeners:Connect(listener)
end

function GlobalUpdates:LockActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_lock == nil then
		error("[ProfileService]: Can't lock active global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't lock active global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_lock = false
		for _, lock_update_id in ipairs(self._pending_update_lock) do
			if update_id == lock_update_id then
				is_pending_lock = true -- Exclude global updates pending to be locked
				break
			end
		end
		if is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock
			table.insert(self._pending_update_lock, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearLockedUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_clear == nil then
		error("[ProfileService]: Can't clear locked global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_clear = false
		for _, clear_update_id in ipairs(self._pending_update_clear) do
			if update_id == clear_update_id then
				is_pending_clear = true -- Exclude global updates pending to be cleared
				break
			end
		end
		if is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear
			table.insert(self._pending_update_clear, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
function GlobalUpdates:AddActiveUpdate(update_data)
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local update_index = updates_latest[1] + 1 -- Incrementing global update index
	updates_latest[1] = update_index
	-- Add new active global update:
	table.insert(updates_latest[2], {update_index, 1, false, update_data})
end

function GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update = nil
	for _, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't change locked global update")
		end
		get_global_update[2] = get_global_update[2] + 1 -- Increment version id
		get_global_update[4] = update_data -- Set new global update data
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id argument")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update_index = nil
	local get_global_update = nil
	for index, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update_index = index
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't clear locked global update")
		end
		table.remove(updates_latest[2], get_global_update_index) -- Remove active global update
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- Profile object:

local Profile = {
	--[[
		Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
		MetaData = {}, -- [table] -- Updated with every auto-save
		GlobalUpdates = GlobalUpdates, -- [GlobalUpdates]
		
		_profile_store = ProfileStore, -- [ProfileStore]
		_profile_key = "", -- [string]
		
		_release_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready_listeners = [ScriptSignal] / nil, -- [table / nil]
		_hop_ready = false,
		
		_view_mode = true / nil, -- [bool] or nil
		
		_load_timestamp = os.clock(),
		
		_is_user_mock = false, -- ProfileStore.Mock
		_mock_key_info = {},
	--]]
}
Profile.__index = Profile

function Profile:IsActive() --> [bool]
	local loaded_profiles = self._is_user_mock == true and self._profile_store._mock_loaded_profiles or self._profile_store._loaded_profiles
	return loaded_profiles[self._profile_key] == self
end

function Profile:GetMetaTag(tag_name) --> value
	local meta_data = self.MetaData
	if meta_data == nil then
		return nil
		-- error("[ProfileService]: This Profile hasn't been loaded before - MetaData not available")
	end
	return self.MetaData.MetaTags[tag_name]
end

function Profile:SetMetaTag(tag_name, value)
	if type(tag_name) ~= "string" then
		error("[ProfileService]: tag_name must be a string")
	elseif string.len(tag_name) == 0 then
		error("[ProfileService]: Invalid tag_name")
	end
	self.MetaData.MetaTags[tag_name] = value
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self._profile_store._profile_template)
end

function Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self:IsActive() == false then
		-- Call release listener immediately if profile is expired
		local place_id
		local game_job_id
		local active_session = self.MetaData.ActiveSession
		if active_session ~= nil then
			place_id = active_session[1]
			game_job_id = active_session[2]
		end
		listener(place_id, game_job_id)
		return {Disconnect = function() end}
	else
		return self._release_listeners:Connect(listener)
	end
end

function Profile:Save()
	if self._view_mode == true then
		error("[ProfileService]: Can't save Profile in view mode - Should you be calling :OverwriteAsync() instead?")
	end
	if self:IsActive() == false then
		warn("[ProfileService]: Attempted saving an inactive profile "
			.. self:Identify() .. "; Traceback:\n" .. debug.traceback())
		return
	end
	-- Reject save request if a save is already pending in the queue - this will prevent the user from
	--	unecessary API request spam which we could not meaningfully execute anyways!
	if IsCustomWriteQueueEmptyFor(self._profile_store._profile_store_lookup, self._profile_key) == true then
		-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:
		RemoveProfileFromAutoSave(self)
		AddProfileToAutoSave(self)
		-- Call save function in a new thread:
		task.spawn(SaveProfileAsync, self)
	end
end

function Profile:Release()
	if self._view_mode == true then
		return
	end
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true) -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:ListenToHopReady(listener) --> [ScriptConnection] ()
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToHopReady()")
	end
	if self._view_mode == true then
		return {Disconnect = function() end}
	end
	if self._hop_ready == true then
		task.spawn(listener)
		return {Disconnect = function() end}
	else
		return self._hop_ready_listeners:Connect(listener)
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :AddUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end

	if user_id &lt; 0 and self._is_user_mock ~= true and UseMockDataStore ~= true then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end
	
end

function Profile:RemoveUserId(user_id) -- Unassociates user_id with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn("[ProfileService]: Invalid UserId argument for :RemoveUserId() ("
			.. tostring(user_id) .. "); Traceback:\n" .. debug.traceback())
		return
	end
	
	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:Identify() --> [string]
	return IdentifyProfile(
		self._profile_store._profile_store_name,
		self._profile_store._profile_store_scope,
		self._profile_key
	)
end

function Profile:ClearGlobalUpdates() -- Clears all global updates data from a profile payload

	if self._view_mode ~= true then
		error("[ProfileService]: :ClearGlobalUpdates() can only be used in view mode")
	end

	local global_updates_object = {
		_updates_latest = {0, {}},
		_profile = self,
	}
	setmetatable(global_updates_object, GlobalUpdates)

	self.GlobalUpdates = global_updates_object

end

function Profile:OverwriteAsync() -- Saves the profile to the DataStore and removes the session lock

	if self._view_mode ~= true then
		error("[ProfileService]: :OverwriteAsync() can only be used in view mode")
	end

	SaveProfileAsync(self, nil, true)

end

-- ProfileVersionQuery object:

local ProfileVersionQuery = {
	--[[
		_profile_store = profile_store,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = pages, -- [DataStoreVersionPages]
		_query_index = index, -- [number]
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	--]]
}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery:_MoveQueue()
	while #self._query_queue > 0 do
		local queue_entry = table.remove(self._query_queue, 1)
		task.spawn(queue_entry)
		if self._is_query_yielded == true then
			break
		end
	end
end

function ProfileVersionQuery:NextAsync(_is_stacking) --> [Profile] or nil

	if self._profile_store == nil then
		return nil
	end

	local profile
	local is_finished = false

	local function query_job()

		if self._query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self._query_pages == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)
			
			local list_success, error_message = pcall(function()
				self._query_pages = self._profile_store._global_data_store:ListVersionsAsync(
					self._profile_key,
					self._sort_direction,
					self._min_date,
					self._max_date
				)
				self._query_index = 0
			end)

			if list_success == false or self._query_pages == nil then
				warn("[ProfileService]: Version query fail - " .. tostring(error_message))
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		local current_page = self._query_pages:GetCurrentPage()
		local next_item = current_page[self._query_index + 1]

		-- No more entries:
		
		if self._query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self._is_query_yielded = true
			task.spawn(function()
				profile = self:NextAsync(true)
				is_finished = true
			end)

			local success = pcall(function()
				self._query_pages:AdvanceToNextPageAsync()
				self._query_index = 0
			end)

			if success == false or #self._query_pages:GetCurrentPage() == 0 then
				self._query_failure = true
			end

			self._is_query_yielded = false
			self:_MoveQueue()

			return

		end

		-- Next page item:

		self._query_index += 1
		profile = self._profile_store:ViewProfileAsync(self._profile_key, next_item.Version)
		is_finished = true

	end

	if self._is_query_yielded == false then
		query_job()
	else
		if _is_stacking == true then
			table.insert(self._query_queue, 1, query_job)
		else
			table.insert(self._query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

-- ProfileStore object:

local ProfileStore = {
	--[[
		Mock = {},
	
		_profile_store_name = "", -- [string] -- DataStore name
		_profile_store_scope = nil, -- [string] or [nil] -- DataStore scope
		_profile_store_lookup = "", -- [string] -- _profile_store_name .. "\0" .. (_profile_store_scope or "")
		
		_profile_template = {}, -- [table]
		_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
		
		_loaded_profiles = {[profile_key] = Profile, ...},
		_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
		
		_mock_loaded_profiles = {[profile_key] = Profile, ...},
		_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
	--]]
}
ProfileStore.__index = ProfileStore

function ProfileStore:LoadProfileAsync(profile_key, not_released_handler, _use_mock) --> [Profile / nil] not_released_handler(place_id, game_job_id)

	not_released_handler = not_released_handler or "ForceLoad"

	if self._profile_template == nil then
		error("[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore")
	end
	if type(profile_key) ~= "string" then
		error("[ProfileService]: profile_key must be a string")
	elseif string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(not_released_handler) ~= "function" and not_released_handler ~= "ForceLoad" and not_released_handler ~= "Steal" then
		error("[ProfileService]: Invalid not_released_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	local is_user_mock = _use_mock == UseMockTag

	-- Check if profile with profile_key isn't already loaded in this session:
	for _, profile_store in ipairs(ActiveProfileStores) do
		if profile_store._profile_store_lookup == self._profile_store_lookup then
			local loaded_profiles = is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
			if loaded_profiles[profile_key] ~= nil then
				error("[ProfileService]: Profile " .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) .. " is already loaded in this session")
				-- Are you using Profile:Release() properly?
			end
		end
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1
	local force_load = not_released_handler == "ForceLoad"
	local force_load_steps = 0
	local request_force_load = force_load -- First step of ForceLoad
	local steal_session = false -- Second step of ForceLoad
	local aggressive_steal = not_released_handler == "Steal" -- Developer invoked steal
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,
		-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare
		-- game breaking errors where a player rejoins the server super fast.
		local profile_load_jobs = is_user_mock == true and self._mock_profile_load_jobs or self._profile_load_jobs
		local loaded_data, key_info
		local load_id = LoadIndex + 1
		LoadIndex = load_id
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}
		if profile_load_job ~= nil then
			profile_load_job[1] = load_id -- Yoink load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end
		else
			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job
			profile_load_job[2] = table.pack(StandardProfileUpdateAsyncDataStore(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							local force_load_session = latest_data.MetaData.ForceLoadSession
							-- IsThisSession(active_session)
							if active_session == nil then
								latest_data.MetaData.ActiveSession = {PlaceId, JobId}
								latest_data.MetaData.ForceLoadSession = nil
							elseif type(active_session) == "table" then
								if IsThisSession(active_session) == false then
									local last_update = latest_data.MetaData.LastUpdate
									if last_update ~= nil then
										if os.time() - last_update > SETTINGS.AssumeDeadSessionLock then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
											return
										end
									end
									if steal_session == true or aggressive_steal == true then
										local force_load_uninterrupted = false
										if force_load_session ~= nil then
											force_load_uninterrupted = IsThisSession(force_load_session)
										end
										if force_load_uninterrupted == true or aggressive_steal == true then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
										end
									elseif request_force_load == true then
										latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
									end
								else
									latest_data.MetaData.ForceLoadSession = nil
								end
							end
						end
					end,
					MissingProfileHandle = function(latest_data)
						latest_data.Data = DeepCopyTable(self._profile_template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = {PlaceId, JobId},
							ForceLoadSession = nil,
							MetaTags = {},
						}
					end,
					EditProfile = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							if active_session ~= nil and IsThisSession(active_session) == true then
								latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
								latest_data.MetaData.LastUpdate = os.time()
							end
						end
					end,
				},
				is_user_mock
			))
			if profile_load_job[1] == load_id then -- Load job hasn't been yoinked
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job yoinked
			end
		end
		-- Handle load_data:
		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then
				if IsThisSession(active_session) == true then
					-- Special component in MetaTags:
					loaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)
					-- Case #1: Profile is now taken by this session:
					-- Create Profile object:
					local global_updates_object = {
						_updates_latest = loaded_data.GlobalUpdates,
						_pending_update_lock = {},
						_pending_update_clear = {},

						_new_active_update_listeners = Madwork.NewScriptSignal(),
						_new_locked_update_listeners = Madwork.NewScriptSignal(),

						_profile = nil,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					local profile = {
						Data = loaded_data.Data,
						MetaData = loaded_data.MetaData,
						MetaTagsUpdated = Madwork.NewScriptSignal(),

						RobloxMetaData = loaded_data.RobloxMetaData or {},
						UserIds = loaded_data.UserIds or {},
						KeyInfo = key_info,
						KeyInfoUpdated = Madwork.NewScriptSignal(),

						GlobalUpdates = global_updates_object,

						_profile_store = self,
						_profile_key = profile_key,

						_release_listeners = Madwork.NewScriptSignal(),
						_hop_ready_listeners = Madwork.NewScriptSignal(),
						_hop_ready = false,

						_load_timestamp = os.clock(),

						_is_user_mock = is_user_mock,
					}
					setmetatable(profile, Profile)
					global_updates_object._profile = profile
					-- Referencing Profile object in ProfileStore:
					if next(self._loaded_profiles) == nil and next(self._mock_loaded_profiles) == nil then -- ProfileStore object was inactive
						table.insert(ActiveProfileStores, self)
					end
					if is_user_mock == true then
						self._mock_loaded_profiles[profile_key] = profile
					else
						self._loaded_profiles[profile_key] = profile
					end
					-- Adding profile to AutoSaveList;
					AddProfileToAutoSave(profile)
					-- Special case - finished loading profile, but session is shutting down:
					if ProfileService.ServiceLocked == true then
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- nil will be returned by this call
					end
					-- Return Profile object:
					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile
				else
					-- Case #2: Profile is taken by some other session:
					if force_load == true then
						local force_load_session = loaded_data.MetaData.ForceLoadSession
						local force_load_uninterrupted = false
						if force_load_session ~= nil then
							force_load_uninterrupted = IsThisSession(force_load_session)
						end
						if force_load_uninterrupted == true then
							if request_force_load == false then
								force_load_steps = force_load_steps + 1
								if force_load_steps == SETTINGS.ForceLoadMaxSteps then
									steal_session = true
								end
							end
							task.wait() -- Overload prevention
						else
							-- Another session tried to force load this profile:
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						end
						request_force_load = false -- Only request a force load once
					elseif aggressive_steal == true then
						task.wait() -- Overload prevention
					else
						local handler_result = not_released_handler(active_session[1], active_session[2])
						if handler_result == "Repeat" then
							task.wait() -- Overload prevention
						elseif handler_result == "Cancel" then
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						elseif handler_result == "ForceLoad" then
							force_load = true
							request_force_load = true
							task.wait() -- Overload prevention
						elseif handler_result == "Steal" then
							aggressive_steal = true
							task.wait() -- Overload prevention
						else
							error(
								"[ProfileService]: Invalid return from not_released_handler (\"" .. tostring(handler_result) .. "\")(" .. type(handler_result) .. ");" ..
									"\n" .. IdentifyProfile(self._profile_store_name, self._profile_store_scope, profile_key) ..
									" Traceback:\n" .. debug.traceback()
							)
						end
					end
				end
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely the ProfileService.ServiceLocked flag was raised
			end
		else
			task.wait() -- Overload prevention
		end
	end
	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- If loop breaks return nothing
end

function ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler, _use_mock) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(update_handler) ~= "function" then
		error("[ProfileService]: Invalid update_handler")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	while ProfileService.ServiceLocked == false do
		-- Updating profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)
					-- Running update_handler:
					local global_updates_object = {
						_updates_latest = latest_data.GlobalUpdates,
						_update_handler_mode = true,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					update_handler(global_updates_object)
				end,
			},
			_use_mock == UseMockTag
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handling loaded_data:
		if loaded_data ~= nil then
			-- Return GlobalUpdates object (Update successful):
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			return global_updates_object
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- Return nothing (Update unsuccessful)
end

function ProfileStore:ViewProfileAsync(profile_key, version, _use_mock) --> [Profile / nil]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return nil
	end

	WaitForPendingProfileStore(self)

	if version ~= nil and (_use_mock == UseMockTag or UseMockDataStore == true) then
		return nil -- No version support in mock mode
	end

	while ProfileService.ServiceLocked == false do
		-- Load profile:
		local loaded_data, key_info = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)
					latest_data.Data = DeepCopyTable(self._profile_template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {},
					}
				end,
				EditProfile = nil,
			},
			_use_mock == UseMockTag,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)
		CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)
		-- Handle load_data:
		if loaded_data ~= nil then
			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end
			-- Create Profile object:
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates, -- {0, {}}
				_profile = nil,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			local profile = {
				Data = loaded_data.Data,
				MetaData = loaded_data.MetaData,
				MetaTagsUpdated = Madwork.NewScriptSignal(),

				RobloxMetaData = loaded_data.RobloxMetaData or {},
				UserIds = loaded_data.UserIds or {},
				KeyInfo = key_info,
				KeyInfoUpdated = Madwork.NewScriptSignal(),

				GlobalUpdates = global_updates_object,

				_profile_store = self,
				_profile_key = profile_key,

				_view_mode = true,

				_load_timestamp = os.clock(),
			}
			setmetatable(profile, Profile)
			global_updates_object._profile = profile
			-- Returning Profile object:
			return profile
		else
			task.wait() -- Overload prevention
		end
	end
	return nil -- If loop breaks return nothing
end

function ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date, _use_mock) --> [ProfileVersionQuery]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return setmetatable({}, ProfileVersionQuery) -- Silently fail :Next() requests
	end

	WaitForPendingProfileStore(self)

	if _use_mock == UseMockTag or UseMockDataStore == true then
		error("[ProfileService]: :ProfileVersionQuery() is not supported in mock mode")
	end

	-- Type check:
	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error("[ProfileService]: Invalid sort_direction (" .. tostring(sort_direction) .. ")")
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error("[ProfileService]: Invalid min_date (" .. tostring(min_date) .. ")")
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error("[ProfileService]: Invalid max_date (" .. tostring(max_date) .. ")")
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	local profile_version_query = {
		_profile_store = self,
		_profile_key = profile_key,
		_sort_direction = sort_direction,
		_min_date = min_date,
		_max_date = max_date,

		_query_pages = nil,
		_query_index = 0,
		_query_failure = false,

		_is_query_yielded = false,
		_query_queue = {},
	}
	setmetatable(profile_version_query, ProfileVersionQuery)

	return profile_version_query

end

function ProfileStore:WipeProfileAsync(profile_key, _use_mock) --> is_wipe_successful [bool]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end

	if ProfileService.ServiceLocked == true then
		return false
	end

	WaitForPendingProfileStore(self)

	local wipe_status = false

	if _use_mock == UseMockTag then -- Used when the profile is accessed through ProfileStore.Mock
		local mock_data_store = UserMockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	elseif UseMockDataStore == true then -- Used when API access is disabled
		local mock_data_store = MockDataStore[self._profile_store_lookup]
		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
		end
		wipe_status = true
		task.wait() -- Simulate API call yield
	else
		wipe_status = pcall(function()
			self._global_data_store:RemoveAsync(profile_key)
		end)
	end

	CustomWriteQueueMarkForCleanup(self._profile_store_lookup, profile_key)

	return wipe_status
end

-- New ProfileStore:

function ProfileService.GetProfileStore(profile_store_index, profile_template) --> [ProfileStore]

	local profile_store_name
	local profile_store_scope = nil

	-- Parsing profile_store_index:
	if type(profile_store_index) == "string" then
		-- profile_store_index as string:
		profile_store_name = profile_store_index
	elseif type(profile_store_index) == "table" then
		-- profile_store_index as table:
		profile_store_name = profile_store_index.Name
		profile_store_scope = profile_store_index.Scope
	else
		error("[ProfileService]: Invalid or missing profile_store_index")
	end

	-- Type checking:
	if profile_store_name == nil or type(profile_store_name) ~= "string" then
		error("[ProfileService]: Missing or invalid \"Name\" parameter")
	elseif string.len(profile_store_name) == 0 then
		error("[ProfileService]: ProfileStore name cannot be an empty string")
	end

	if profile_store_scope ~= nil and (type(profile_store_scope) ~= "string" or string.len(profile_store_scope) == 0) then
		error("[ProfileService]: Invalid \"Scope\" parameter")
	end

	if type(profile_template) ~= "table" then
		error("[ProfileService]: Invalid profile_template")
	end

	local profile_store
	profile_store = {
		Mock = {
			LoadProfileAsync = function(_, profile_key, not_released_handler)
				return profile_store:LoadProfileAsync(profile_key, not_released_handler, UseMockTag)
			end,
			GlobalUpdateProfileAsync = function(_, profile_key, update_handler)
				return profile_store:GlobalUpdateProfileAsync(profile_key, update_handler, UseMockTag)
			end,
			ViewProfileAsync = function(_, profile_key, version)
				return profile_store:ViewProfileAsync(profile_key, version, UseMockTag)
			end,
			FindProfileVersionAsync = function(_, profile_key, sort_direction, min_date, max_date)
				return profile_store:FindProfileVersionAsync(profile_key, sort_direction, min_date, max_date, UseMockTag)
			end,
			WipeProfileAsync = function(_, profile_key)
				return profile_store:WipeProfileAsync(profile_key, UseMockTag)
			end
		},

		_profile_store_name = profile_store_name,
		_profile_store_scope = profile_store_scope,
		_profile_store_lookup = profile_store_name .. "\0" .. (profile_store_scope or ""),

		_profile_template = profile_template,
		_global_data_store = nil,
		_loaded_profiles = {},
		_profile_load_jobs = {},
		_mock_loaded_profiles = {},
		_mock_profile_load_jobs = {},
		_is_pending = false,
	}
	setmetatable(profile_store, ProfileStore)

	if IsLiveCheckActive == true then
		profile_store._is_pending = true
		task.spawn(function()
			WaitForLiveAccessCheck()
			if UseMockDataStore == false then
				profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope)
			end
			profile_store._is_pending = false
		end)
	else
		if UseMockDataStore == false then
			profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name, profile_store_scope)
		end
	end

	return profile_store
end

function ProfileService.IsLive() --> [bool] -- (CAN YIELD!!!)

	WaitForLiveAccessCheck()

	return UseMockDataStore == false

end

----- Initialize -----

if IsStudio == true then
	IsLiveCheckActive = true
	task.spawn(function()
		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)
		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil
		if no_internet_access == true then
			warn("[ProfileService]: No internet access - check your network connection")
		end
		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			UseMockDataStore = true
			ProfileService._use_mock_data_store = true
			print("[ProfileService]: Roblox API services unavailable - data will not be saved")
		else
			print("[ProfileService]: Roblox API services available - data will be saved")
		end
		IsLiveCheckActive = false
	end)
end

----- Connections -----

-- Auto saving and issue queue managing:
RunService.Heartbeat:Connect(function()
	-- 1) Auto saving: --
	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile._load_timestamp &lt; SETTINGS.AutoSaveProfiles then
				-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end
	-- 2) Issue queue: --
	-- Critical state handling:
	if ProfileService.CriticalState == false then
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			ProfileService.CriticalState = true
			ProfileService.CriticalStateSignal:Fire(true)
			CriticalStateStart = os.clock()
			warn("[ProfileService]: Entered critical state")
		end
	else
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > SETTINGS.CriticalStateLast then
			ProfileService.CriticalState = false
			ProfileService.CriticalStateSignal:Fire(false)
			warn("[ProfileService]: Critical state ended")
		end
	end
	-- Issue queue:
	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > SETTINGS.IssueLast then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end
end)

-- Release all loaded profiles when the server is shutting down:
task.spawn(function()
	WaitForLiveAccessCheck()
	Madwork.ConnectToOnClose(
		function()
			ProfileService.ServiceLocked = true
			-- 1) Release all active profiles: --
			-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:
			local on_close_save_job_count = 0
			local active_profiles = {}
			for index, profile in ipairs(AutoSaveList) do
				active_profiles[index] = profile
			end
			-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
			for _, profile in ipairs(active_profiles) do
				if profile:IsActive() == true then
					on_close_save_job_count = on_close_save_job_count + 1
					task.spawn(function() -- Save profile on new thread
						SaveProfileAsync(profile, true)
						on_close_save_job_count = on_close_save_job_count - 1
					end)
				end
			end
			-- 2) Yield until all active profile jobs are finished: --
			while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
				task.wait()
			end
			return -- We're done!
		end,
		UseMockDataStore == false -- Always run this OnClose task if using Roblox API services
	)
end)

return ProfileService</string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="178">
          <Properties>
            <string name="Name">User</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezZGMjg0RkMxLUIzNjctNEU2NS1BNUJCLUI2RDc2NjFGOTk0MX0=]]></BinaryString>
            <string name="Source"><![CDATA[-- Class
-- 0_1195
-- May 06, 2022

--[[

keep data and the player object seperate

]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Janitor = require(ReplicatedStorage.Packages.Janitor)

local Class = {}
Class.__index = Class

function Class.__tostring(self)
	return tostring(self.Player.UserId)
end

function Class:UpdateData(key: string, callback: (any) -> (any), forceUpdate: boolean?)
	local currentData = self.Data[key]
	local newData = callback(currentData)

	self.Profile.Data[key] = newData
	self.Data[key] = newData

	Knit.GetService("DataService"):DataChanged(self, key, newData, forceUpdate)
end

function Class.new(player: Player)
	local self = setmetatable({
		Player = player,

		Profile = nil,
		Data = nil,

		_janitor = Janitor.new(),
	}, Class)

	return self
end

function Class:Destroy()
	self._janitor:Destroy()
end

return Class
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="179">
          <Properties>
            <string name="Name">State</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezQ2QjVBRjYzLTAzMzctNEVCRS1BQ0EzLTlCNjhBMTRERjlBOH0=]]></BinaryString>
            <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- local Silo = require(ReplicatedStorage.Packages.Silo)
-- local PlotsSilo = require(script.Silos.Plots)

-- return {
-- 	State = Silo.combine({
-- 		plots = PlotsSilo,
-- 	}),

-- 	Plots = PlotsSilo,
-- }

local Rodux = require(ReplicatedStorage.Game.Rodux)

local reducer = Rodux.combineReducers({
	plots = require(script.Reducers.Plots),
})

local store = Rodux.Store.new(reducer, {}, {
	Rodux.thunkMiddleware, -- Rodux.loggerMiddleware,
})

return store</string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="Folder" referent="180">
            <Properties>
              <string name="Name">Reducers</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="181">
              <Properties>
                <string name="Name">Plots</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0ZGNEE0MkQxLTRGODMtNEExNC04MEM2LUVBOTM1MEU0RkYxNn0=]]></BinaryString>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Rodux = require(ReplicatedStorage.Game.Rodux)
local Sift = require(ReplicatedStorage.Packages.sift)

local initialState = {}

local reducer = Rodux.createReducer(initialState, {
	NewPlot = function(state, action)
		return Sift.Dictionary.merge(state, {
			[action.key] = action.objects,
		})
	end,

	RemovePlot = function(state, action)
		return Sift.Dictionary.merge(state, {
			[action.key] = Sift.None,
		})
	end,

	SetObjects = function(state, action)
		local newState = Sift.Dictionary.merge(state, {
			[action.key] = action.objects,
		})
		return newState
	end,

	AddObject = function(state, action)
		return Sift.Dictionary.mergeDeep(state, {
			[action.key] = Sift.Array.push(state[action.key], action.serialized),
		})
	end,

	RemoveObject = function(state, action)
		return Sift.Dictionary.mergeDeep(state, {
			[action.key] = Sift.Array.removeValue(state[action.key], action.serialized),
		})
	end,
})

return reducer
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="182">
        <Properties>
          <string name="Name">Services</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="183">
          <Properties>
            <string name="Name">Data</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0YwNUVERjI0LTk3NkItNDk5NC04Mjg4LUJDMzEyNkYyRUJGMX0=]]></BinaryString>
            <string name="Source"><![CDATA[-- DataService
-- 0_1195
-- May 06, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

local Knit = require(ReplicatedStorage.Packages.Knit)
local ProfileService = require(ServerStorage.Game.Modules.ProfileService)
local DataTemplate = require(ReplicatedStorage.Game.Shared.DataTemplate)
local Promise = require(ReplicatedStorage.Packages.Promise)
local UserService

local PROFILE_STORE_NAME = "PlayerData"

local profileStore = ProfileService.GetProfileStore(PROFILE_STORE_NAME, DataTemplate)

local Service = Knit.CreateService({
	Name = "DataService",
	Client = {
		DataChanged = Knit.CreateSignal(),
	},
})

function Service.Client:RequestData(player: Player)
	local dataInited = player:GetAttribute("_dataInited")
	if dataInited == true then
		return nil
	end

	return Promise.retryWithDelay(function()
		return Promise.new(function(resolve, reject)
			local user = UserService:GetUser(player)
			if user then
				resolve(user)
			else
				reject()
			end
		end)
	end, 10, 1)
		:andThen(function(user)
			player:SetAttribute("_dataInited", true)
			return user.Data
		end)
		:catch()
		:expect()
end

function Service:LoadProfile(player: Player)
	local dataKey = "Player_" .. tostring(player.UserId)
	local profile = profileStore:LoadProfileAsync(dataKey)

	if not profile then
		UserService:Kick(player, "Roblox DataStore Down")
		return nil
	end

	if not player:IsDescendantOf(Players) then
		profile:Release()
	end

	profile:AddUserId(player.UserId)
	profile:Reconcile()
	profile:ListenToRelease(function()
		-- dont use UserService:Kick() here
		player:Kick()
	end)

	return profile
end

function Service:DataChanged(user, key: string, value: string, forceUpdate: boolean?)
	if forceUpdate then
		warn(string.format("FORCE UPDATE %s FOR %s", key, tostring(user)))
		self.Client.DataChanged:Fire(user.Player, key, value)
	end

	if key == "" then
		print(value)
	end
end

function Service:KnitStart() end

function Service:KnitInit()
	UserService = Knit.GetService("UserService")
end

return Service
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="184">
          <Properties>
            <string name="Name">Test</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0Q0OTM2OUM1LTEyQUItNDY3Qi05MUM3LTVBRjBGRjlBN0YxNH0=]]></BinaryString>
            <string name="Source">-- TestService
-- 0_1195
-- January 11, 2022

--[[



]]


local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)

local Service = Knit.CreateService{
	Name = "TestService",
	Client = {
	},
}


function Service:KnitStart()
	-- task.delay(10, function()
	-- 	local user = Knit.GetService("UserService"):GetUser(game.Players:GetPlayers()[1])
	-- 	Knit.GetService("DataService"):DataChanged(user, "Version", nil, true)
	-- end)
end


function Service:KnitInit()
	
end


return Service</string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="185">
          <Properties>
            <string name="Name">User</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezMwMzU3RUQ2LTMxMjMtNDc0Ny05QTRBLUNBMzkyOTdGRjE5N30=]]></BinaryString>
            <string name="Source"><![CDATA[-- UserService
-- 0_1195
-- May 06, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Signal = require(ReplicatedStorage.Packages.Signal)
local Janitor = require(ReplicatedStorage.Packages.Janitor)

local Service = Knit.CreateService({
	Name = "UserService",
	Client = {},

	Users = {},

	UserAdded = Signal.new(),
	UserRemoving = Signal.new(),
})

function Service:Observe(userAdded: () -> (), userRemoving: () -> ())
	local janitor = Janitor.new()
	for _, user in self.Users do
		task.spawn(userAdded, user)
	end
	janitor:Add(self.UserAdded:Connect(userAdded))
	janitor:Add(self.UserRemoving:Connect(userRemoving))
	return janitor
end

function Service:GetUser(player: Player)
	return self.Users[player]
end

function Service:GetUserById(userId: number)
	for player: Player, user in self.Users do
		if player.UserId == userId then
			return user
		end
	end
	return nil
end

function Service:GetUsers()
	return self.Users
end

function Service:Kick(player: Player, reason: string)
	warn(string.format("Kicking %d", player.UserId))
	player:Kick(reason)
end

function Service:KnitStart() end

function Service:KnitInit()
	local DataService = Knit.GetService("DataService")
	local User = require(ServerStorage.Game.Modules.User)

	local function playerAdded(player: Player)
		local user = User.new(player)

		local playerProfile = DataService:LoadProfile(player)
		if not playerProfile then
			self:Kick(player, "Roblox DataStore Down")
			return
		end

		user.Profile = playerProfile
		user.Data = playerProfile.Data

		user._janitor:Add(function()
			playerProfile:Release()
		end)

		if player:IsDescendantOf(Players) then
			self.Users[player] = user
			self.UserAdded:Fire(user)
		else
			user:Destroy()
		end
	end

	local function playerRemoving(player: Player)
		local user = self.Users[player]
		if not user then
			return
		end

		warn(string.format("Player %d leaving game", player.UserId))

		self.UserRemoving:Fire(user)
		user:Destroy()
		self.Users[player] = nil
	end

	for _, player in Players:GetPlayers() do
		task.spawn(playerAdded, player)
	end

	Players.PlayerAdded:Connect(playerAdded)
	Players.PlayerRemoving:Connect(playerRemoving)
end

return Service
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="186">
          <Properties>
            <string name="Name">Plot</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0I0MEYxQzkwLTM3RkMtNDAyNy1CNDFCLUIxNEM5MDFFMTQ3Nn0=]]></BinaryString>
            <string name="Source"><![CDATA[-- PlotService
-- 0_1195
-- May 07, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Run = game:GetService("RunService")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Promise = require(ReplicatedStorage.Packages.Promise)
local Plot = require(ServerStorage.Game.Components.Plot)
local ItemData = require(ReplicatedStorage.Game.Shared.ItemData)
local GridModules = require(ReplicatedStorage.Game.Shared.Grid)
local State = require(ServerStorage.Game.Modules.State)
local Sift = require(ReplicatedStorage.Packages.sift)
local GridUtil = GridModules.GridUtil
local UserService
-- arbitrary values
local MAX_GRID_SIZE_X = 100
local MAX_GRID_SIZE_Y = 100

local Service = Knit.CreateService({
	Name = "PlotService",
	Client = {
		PlaceObject = Knit.CreateSignal(),
	},
})

function Service:GetPlotForUser(user)
	for _, plot in Plot:GetAll() do
		if plot:GetOwner() == user then
			return plot
		end
	end
	return nil
end

function Service:GetEmptyPlot()
	for _, plot in Plot:GetAll() do
		if not plot:GetOwner() then
			return plot
		end
	end
	return nil
end

function Service:AwaitEmptyPlot(): Promise.Static
	return Promise.new(function(resolve, _reject, onCancel)
		local heartbeat

		local function done()
			heartbeat:Disconnect()
		end

		local function update()
			local plot = self:GetEmptyPlot()
			if plot then
				done()
				resolve(plot)
			end
		end

		onCancel(done)

		heartbeat = Run.Heartbeat:Connect(update)
	end)
end

function Service:KnitStart()
	local function userAdded(user)
		self
			:AwaitEmptyPlot()
			:timeout(30)
			:andThen(function(plot)
				plot:SetOwner(user)
			end)
			:catch(function(err)
				if Promise.Error.isKind(err, Promise.Error.Kind.TimedOut) then
					UserService:Kick(user.Player, "Failed to find empty plot")
				else
					warn(err)
				end
			end)
	end

	local function userRemoving(user)
		local plot = self:GetPlotForUser(user)
		if plot then
			plot:ClearOwner()
		end
	end

	UserService:Observe(userAdded, userRemoving)
end

function Service:KnitInit()
	UserService = Knit.GetService("UserService")

	local function clientRequestPlaceObject(user, id: number, position: Vector2, rotation: number)
		-- check if client has plot
		local plot = self:GetPlotForUser(user)
		if not plot then
			return { success = false, error = string.format("User %s does not have a plot.", tostring(user)) }
		end
		-- check valid item
		local baseItemData: ItemData.ItemData = ItemData[id]
		if not baseItemData then
			return { success = false, error = string.format("User %s attempted to place invalid item", tostring(user)) }
		end
		-- client is trying to place a valid object at a position
		local grid = plot.Grid
		local gridPositionList = GridUtil.GetGridPositionList(
			baseItemData.Id,
			position,
			GridUtil.Directions[rotation + 1]
		)
		local canPlace = GridUtil.CanPlaceObjectInGrid(grid, gridPositionList)
		if not canPlace then
			return {
				success = false,
				error = string.format("User %s attempted to place item at invalid position", tostring(user)),
			}
		end
		-- client can place
		return { success = true, plot = plot, gridPositionList = gridPositionList, baseItemData = baseItemData }
	end
	
	self.Client.PlaceObject:Connect(function(player: Player, id: number, position: Vector2, rotation: number)
		local user = UserService:GetUser(player)
		if not user then
			UserService:Kick(player, "Data not loaded")
			return
		end
		-- type checks
		assert(typeof(id) == "number", "")
		assert(typeof(position) == "Vector2", "")
		assert(typeof(rotation) == "number", "")

		rotation = math.clamp(rotation, 0, 3)
		local x = math.clamp(position.X, 0, MAX_GRID_SIZE_X)
		local y = math.clamp(position.Y, 0, MAX_GRID_SIZE_Y)
		position = Vector2.new(x, y)

		local requestResult = clientRequestPlaceObject(user, id, position, rotation)
		if requestResult.success then
			-- client can place valid item at valid position.
			local baseItemData = requestResult.baseItemData
			local serialized = GridUtil.SerializeCell(baseItemData.Id, position, rotation)
			-- update data
			user:UpdateData("GridObjects", function(gridObjects)
				return Sift.Array.push(gridObjects, serialized)
			end)
			-- update plot
			local plot = requestResult.plot
			State:dispatch({
				type = "AddObject",
				key = plot.Key,
				serialized = serialized,
			})
		else
			-- client failed checks. force update
			warn(requestResult.error)
			user:UpdateData("GridObjects", function(gridObjects)
				return gridObjects
			end, true)
		end
	end)
end

return Service
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="Model" referent="187">
      <Properties>
        <string name="Name">Model</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <token name="LevelOfDetail">0</token>
        <CoordinateFrame name="ModelMeshCFrame">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
          <R00>1</R00>
          <R01>0</R01>
          <R02>0</R02>
          <R10>0</R10>
          <R11>1</R11>
          <R12>0</R12>
          <R20>0</R20>
          <R21>0</R21>
          <R22>1</R22>
        </CoordinateFrame>
        <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
        <Vector3 name="ModelMeshSize">
          <X>0</X>
          <Y>0</Y>
          <Z>0</Z>
        </Vector3>
        <bool name="NeedsPivotMigration">false</bool>
        <Ref name="PrimaryPart">null</Ref>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <OptionalCoordinateFrame name="WorldPivotData">
          <CFrame>
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
            <R00>1</R00>
            <R01>0</R01>
            <R02>0</R02>
            <R10>0</R10>
            <R11>1</R11>
            <R12>0</R12>
            <R20>0</R20>
            <R21>0</R21>
            <R22>1</R22>
          </CFrame>
        </OptionalCoordinateFrame>
      </Properties>
      <Item class="Sound" referent="188">
        <Properties>
          <string name="Name">Video Game Buttons 10 (SFX)</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <float name="EmitterSize">10</float>
          <bool name="Looped">false</bool>
          <float name="xmlRead_MaxDistance_3">10000</float>
          <bool name="PlayOnRemove">false</bool>
          <float name="PlaybackSpeed">1</float>
          <bool name="Playing">false</bool>
          <token name="RollOffMode">0</token>
          <Ref name="SoundGroup">null</Ref>
          <Content name="SoundId">
            <url>rbxassetid://9120410355</url>
          </Content>
          <int64 name="SourceAssetId">9120410355</int64>
          <BinaryString name="Tags"></BinaryString>
          <double name="TimePosition">0</double>
          <float name="Volume">2</float>
        </Properties>
      </Item>
      <Item class="Sound" referent="189">
        <Properties>
          <string name="Name">Pen Clicks 6 (SFX)</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <float name="EmitterSize">10</float>
          <bool name="Looped">false</bool>
          <float name="xmlRead_MaxDistance_3">10000</float>
          <bool name="PlayOnRemove">false</bool>
          <float name="PlaybackSpeed">1</float>
          <bool name="Playing">false</bool>
          <token name="RollOffMode">0</token>
          <Ref name="SoundGroup">null</Ref>
          <Content name="SoundId">
            <url>rbxassetid://9117280354</url>
          </Content>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
          <double name="TimePosition">0</double>
          <float name="Volume">2</float>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ReplicatedStorage" referent="190">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
    <Item class="Folder" referent="191">
      <Properties>
        <string name="Name">Game</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="Folder" referent="192">
        <Properties>
          <string name="Name">Components</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="193">
          <Properties>
            <string name="Name">Plot</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0ZFREVBQUQ4LURBNzAtNDYwOS05MjBCLURGODNFMDdBRTQxN30=]]></BinaryString>
            <string name="Source"><![CDATA[-- Component
-- 0_1195
-- May 06, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Component = require(ReplicatedStorage.Packages.Component)
local Janitor = require(ReplicatedStorage.Packages.Janitor)
local Streamable = require(ReplicatedStorage.Packages.Streamable).Streamable
local GridModules = require(ReplicatedStorage.Game.Shared.Grid)
local State = require(ReplicatedStorage.Game.Modules.State)
local Fusion = require(ReplicatedStorage.Packages.Fusion)
local ItemData = require(ReplicatedStorage.Game.Shared.ItemData)
local Sift = require(ReplicatedStorage.Packages.sift)
local Grid = GridModules.Grid
local GridUtil = GridModules.GridUtil
local CellObject = GridModules.CellObject

local Class = Component.new({
	Tag = "Plot",
	Ancestors = { workspace },
})

function Class:IsLocalPlayerPlot(): boolean
	local instance: Model = self.Instance
	local ownerId: number = instance:GetAttribute("OwnerId")
	return ownerId == Knit.Player.UserId
end

function Class:StartForLocalPlayer()
	self:StopForLocalPlayer()

	local localJanitor = self._janitor:Get("LocalJanitor")

	local instance: Model = self.Instance
	-- StreamingEnabled compatable, hopefully
	local primaryStreamable = Streamable.primary(instance.Grid)
	localJanitor:Add(primaryStreamable)
	primaryStreamable:Observe(function(primaryPart)
		primaryPart.Color = Color3.fromRGB(48, 216, 112)
	end)

	local gridModel: Model = instance.Grid
	local origin = gridModel:GetPivot()
	local plotRoot = gridModel.PrimaryPart
	local size = Vector2.new(plotRoot.Size.X, plotRoot.Size.Z)
	local grid = Grid.new(origin, size, 4)
	self.Grid = grid
	localJanitor:Add(function()
		self.Grid:Destroy()
	end)

	self._objects = Fusion.State({})
	localJanitor:Add(function()
		self._objects:set({}, true)
	end)
	-- needs to be indexed or it will not work?
	self.Computed = Fusion.ComputedPairs(self._objects, function(_index: number, value)
		local itemId, position, rotation = GridUtil.DeserializeCell(value)
		local baseItemData: ItemData.ItemData = ItemData[tonumber(itemId)]

		local cellObject = CellObject.new(baseItemData.Id, position, GridUtil.Directions[rotation + 1])
		local gridPositionList = GridUtil.GetGridPositionList(
			baseItemData.Id,
			position,
			GridUtil.Directions[rotation + 1]
		)
		GridUtil.PlaceObjectInGrid(grid, gridPositionList, cellObject)
		return gridPositionList
	end, function(gridPositionList)
		GridUtil.RemoveObjectFromGrid(grid, gridPositionList)
	end)
	localJanitor:Add(function()
		self.Computed = nil
	end)
	-- watch for objects
	local function onChange(objects)
		self._objects:set(objects)
	end

	local selector = function(state)
		return state.plot
	end

	local value = selector(State:getState())

	localJanitor:Add(State.changed:connect(function(newState, _oldState)
		local newValue = selector(newState)
		if Sift.Array.equalsDeep(newValue, value) then
			return
		end
		value = newValue
		onChange(value)
	end).disconnect)

	onChange(value)
	-- set plot
	local PlotController = Knit.GetController("PlotController")
	PlotController.MyPlot = self
	localJanitor:Add(function()
		PlotController.MyPlot = nil
	end)
end

function Class:StopForLocalPlayer()
	local localJanitor = self._janitor:Get("LocalJanitor")

	local primaryStreamable = Streamable.primary(self.Instance.Grid)
	localJanitor:Add(primaryStreamable)
	primaryStreamable:Observe(function(primaryPart)
		primaryPart.Color = Color3.fromRGB(255, 0, 255)
	end)
	localJanitor:Cleanup()
end

function Class:Construct()
	local instance = self.Instance
	self._janitor = Janitor.new()

	local localJanitor = Janitor.new()
	self._janitor:Add(localJanitor, nil, "LocalJanitor")
	-- only want to start the component for localplayer
	local function ownerIdChanged()
		local ownerId: number = instance:GetAttribute("OwnerId")
		if ownerId == Knit.Player.UserId then
			self:StartForLocalPlayer()
		else
			self:StopForLocalPlayer()
		end
	end

	task.spawn(ownerIdChanged)

	self._janitor:Add(instance:GetAttributeChangedSignal("OwnerId"):Connect(ownerIdChanged))
end

function Class:Start() end

function Class:Stop()
	self:StopForLocalPlayer()
	self._janitor:Destroy()
end

return Class
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="194">
        <Properties>
          <string name="Name">Controllers</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="195">
          <Properties>
            <string name="Name">Data</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezRDRjdGMjhBLTZEMzUtNDRDQS1BQkM1LUMxRjhEMTA3OTFFN30=]]></BinaryString>
            <string name="Source"><![CDATA[-- DataController
-- 0_1195
-- May 06, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Http = game:GetService("HttpService")

local Knit = require(ReplicatedStorage.Packages.Knit)
local State = require(ReplicatedStorage.Game.Modules.State)
local Sift = require(ReplicatedStorage.Packages.sift)
local Signal = require(ReplicatedStorage.Packages.Signal)

local Controller = Knit.CreateController({
	Name = "DataController",

	DataChanged = Signal.new(),
})

function Controller:KnitStart() end

function Controller:KnitInit()
	local function dataChanged(key, value)
		if value == nil then
			value = Sift.None
		end

		State:dispatch({
			type = "SetPlayerData",
			key = key,
			value = value,
		})

		self.DataChanged:Fire(key, value)

		print(string.format("Got new player data %s: %s", key, Http:JSONEncode(value)))
	end

	local DataService = Knit.GetService("DataService")
	DataService
		:RequestData()
		:andThen(function(data)
			for k, v in data do
				dataChanged(k, v)
			end
		end)
		:catch(warn)

	DataService.DataChanged:Connect(dataChanged)
end

return Controller
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="196">
          <Properties>
            <string name="Name">Test</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0FFMkY0MjU0LTRBODctNDkzRS04RDAyLUFCN0ExOEIyQkNBOH0=]]></BinaryString>
            <string name="Source">-- TestController
-- 0_1195
-- January 11, 2022

--[[



]]


local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)

local Controller = Knit.CreateController{
	Name = "TestController",
}


function Controller:KnitStart()
	-- local State = require(ReplicatedStorage.Game.Modules.State)
	-- State.State:Dispatch(State.Data.Actions.SetPlayerData({
	-- 	key = "Keybinds",
	-- 	value = {
	-- 		Keyboard = {
	-- 			["Hotbar1"] = "Q",
	-- 			["Hotbar2"] = "E",
	-- 		},
	-- 		Gamepad = {},
	-- 		Touch = {},
	-- 	},
	-- }))
end


function Controller:KnitInit()
	
end


return Controller</string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="197">
          <Properties>
            <string name="Name">Scale</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0NBNTE1RjUyLTE4RUYtNDc5OC1BNDUzLTE2Mzg5OUZCNjE4Rn0=]]></BinaryString>
            <string name="Source"><![CDATA[-- ScaleController
-- 0_1195
-- May 08, 2022

--[[

https://devforum.roblox.com/t/scaler-using-uiscale-to-scale-your-ui/1105672

]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)
local State = require(ReplicatedStorage.Game.Modules.State)

local MULTIPLIER = 1 / 720
local DISPATCH_DELAY = 0.5

local camera = workspace.CurrentCamera

local Controller = Knit.CreateController({
	Name = "ScaleController",
})

function Controller:KnitStart() end

function Controller:KnitInit()
	local updateThread = task.delay(DISPATCH_DELAY, function() end)

	local function viewportSizeChanged()
		local viewportSize = camera.ViewportSize

		local sizeX, sizeY = viewportSize.X, viewportSize.Y
		local scale = MULTIPLIER * sizeY

		if sizeY > sizeX then
			scale = MULTIPLIER * sizeX
		end

		task.cancel(updateThread)
		updateThread = task.delay(DISPATCH_DELAY, function()
			State:dispatch({
				type = "SetScale",
				scale = scale,
			})
		end)
	end

	task.spawn(viewportSizeChanged)

	camera:GetPropertyChangedSignal("ViewportSize"):Connect(viewportSizeChanged)
end

return Controller
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="198">
          <Properties>
            <string name="Name">Input</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0MzRTg2MkEyLTdCNDktNEVEQy1BRUFFLUZCQkQxNTlENDIyOX0=]]></BinaryString>
            <string name="Source"><![CDATA[-- InputController
-- 0_1195
-- May 09, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInput = game:GetService("UserInputService")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Input = require(ReplicatedStorage.Packages.Input)
local State = require(ReplicatedStorage.Game.Modules.State)
local DataDefaults = require(ReplicatedStorage.Game.Shared.DataDefaults)
local Sift = require(ReplicatedStorage.Packages.sift)
local RoduxWatcher = require(ReplicatedStorage.Game.Shared.RoduxWatcher)

local PreferredInput = Input.PreferredInput

local keybinds = Sift.Dictionary.copyDeep(DataDefaults.Keybinds)

local actions = {}

local watcher = RoduxWatcher(State)

local Controller = Knit.CreateController({
	Name = "InputController",
})

local function updateKeybinds(newKeybinds)
	local preferredInput = Controller:GetPreferredInput()
	for _, action in actions do
		-- print(action.name)
		action.keybind = newKeybinds[preferredInput][action.name] or keybinds[preferredInput][action.name]
	end
end

function Controller:Add(actionName: string, callback: () -> ())
	if actions[actionName] then
		warn(string.format("%s action already added", actionName))
		return nil
	end

	local keybind = self:GetKeyFromAction(actionName)

	local action = {
		name = actionName,
		callback = callback,
		enabled = true,
		keybind = keybind,
	}

	actions[actionName] = action

	return action
end

function Controller:SetEnabled(actionName: string, enabled: boolean)
	local action = actions[actionName]
	if not action then
		warn(string.format("%s action does not exist", actionName))
		return
	end

	action.enabled = enabled
end

function Controller:GetPreferredInput(): string
	return State:getState().input.preferredInput
end

function Controller:GetKeyFromAction(actionName: string): string?
	local preferredInput = self:GetPreferredInput()
	return keybinds[preferredInput][actionName]
end

local camera = workspace.CurrentCamera
local Mouse = Input.Mouse

local params = RaycastParams.new()
params.IgnoreWater = true
function Controller:CastInWorld(distance: number, ignore: { Instance })
	local overridePos: Vector2

	local preferredInput = self:GetPreferredInput()
	if preferredInput ~= "Keyboard" then
		overridePos = camera.ViewportSize / 2
	end
	local viewportMouseRay = Mouse:GetRay(overridePos)
	local origin = viewportMouseRay.Origin
	local direction = viewportMouseRay.Direction * distance
	params.FilterDescendantsInstances = ignore
	local raycastResult = workspace:Raycast(origin, direction, params)
	return { raycastResult = raycastResult, Origin = origin, Direction = direction }
end

function Controller:KnitStart() end

function Controller:KnitInit()
	local preferredMap = {
		["MouseKeyboard"] = "Keyboard",
		["Gamepad"] = "Gamepad",
		["Touch"] = "Touch",
	}
	PreferredInput.Observe(function(preferred)
		local preferredName = preferredMap[preferred.Name]
		State:dispatch({
			type = "SetPreferred",
			preferredInput = preferredName,
		})
	end)
	-- watch for keybinds changed
	watcher(function(state)
		return state.data.Keybinds
	end, function(newKeybinds)
		updateKeybinds(newKeybinds)
	end)

	local function inputBegan(inputObject: InputObject, gameProcessedEvent: boolean)
		if gameProcessedEvent then
			return
		end

		local key = inputObject.KeyCode.Name
		local inputType = inputObject.UserInputType

		if string.match(inputType.Name, "^Mouse") then
			key = inputType.Name
		elseif inputType == Enum.UserInputType.Touch then
			key = "Touch"
		end

		if key == "Unknown" then
			return
		end

		-- different actions can have the same key
		local actionsToRun = {}
		for _, action in actions do
			if (action.keybind == key) and action.enabled then
				table.insert(actionsToRun, action)
			end
		end

		for _, action in actionsToRun do
			if not (action and typeof(action.callback) == "function") then
				continue
			end
			action.callback(action.name, inputObject.UserInputState, inputObject)
		end

		-- print(key)
	end

	--[[
	https://devforum.roblox.com/t/inputbegan-doesnt-work-for-io-but-inputended-does/1509584
	local ContextAction = game:GetService("ContextActionService")
	ContextAction:BindActionAtPriority("INPUT", function(actionName: string, inputState: Enum.UserInputState, inputObject: InputObject)
		if inputState == Enum.UserInputState.Begin then
			local key = inputObject.KeyCode.Name
			local inputType = inputObject.UserInputType
			print(key)
			if string.match(inputType.Name, "^Mouse") then
				key = inputType.Name
			elseif inputType == Enum.UserInputType.Touch then
				key = "Touch"
			end

			if key == "Unknown" then
				return Enum.ContextActionResult.Pass
			end

		end
		return Enum.ContextActionResult.Pass
	end, false, 10000, unpack(Enum.KeyCode:GetEnumItems()))
]]

	UserInput.InputBegan:Connect(inputBegan)
end

return Controller
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="199">
          <Properties>
            <string name="Name">Build</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezhBNzIzNjdELUQxNjUtNDBCOC04NkZFLTA3Q0ZERTMzRDhGNX0=]]></BinaryString>
            <string name="Source"><![CDATA[-- BuildController
-- 0_1195
-- May 11, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Run = game:GetService("RunService")
local Players = game:GetService("Players")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Fusion = require(ReplicatedStorage.Packages.Fusion)
local State = require(ReplicatedStorage.Game.Modules.State)
local UI = require(ReplicatedStorage.Game.Modules.UI)
local ItemData = require(ReplicatedStorage.Game.Shared.ItemData)
local Janitor = require(ReplicatedStorage.Packages.Janitor)
local Timer = require(ReplicatedStorage.Packages.Timer)
local GridUtil = require(ReplicatedStorage.Game.Shared.Grid).GridUtil
local Sift = require(ReplicatedStorage.Packages.sift)
local RoduxWatcher = require(ReplicatedStorage.Game.Shared.RoduxWatcher)
local PlotController
local PlotService

local PREFAB_SPEED = 15
-- id of items
local items = { 1, 2, 3 }

local adorneeState = Fusion.State()
local canPlaceState = Fusion.State(false)
Fusion.New("Highlight")({
	Adornee = adorneeState,
	DepthMode = Enum.HighlightDepthMode.AlwaysOnTop,
	FillColor = Fusion.Computed(function()
		return canPlaceState:get() and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 38, 0)
	end),
	FillTransparency = 0.5,
	OutlineColor = Color3.fromRGB(255, 255, 255),
	OutlineTransparency = 1,
	Parent = workspace.CurrentCamera,
})

local _janitor = Janitor.new()

local watcher = RoduxWatcher(State)

local Controller = Knit.CreateController({
	Name = "BuildController",
})

function Controller:CheckCanPlace(grid: Grid, position: Vector2, id: number): boolean
	local baseItemData: ItemData.ItemData = ItemData[id]

	local buildState = State:getState().build
	local rotation: number = buildState.rotation

	local gridPositionList = GridUtil.GetGridPositionList(baseItemData.Id, position, GridUtil.Directions[rotation + 1])
	return GridUtil.CanPlaceObjectInGrid(grid, gridPositionList)
end

function Controller:StartBuild(itemId: number)
	self:StopBuild()

	local baseItemData: ItemData.ItemData = ItemData[itemId]
	if not baseItemData then
		return
	end

	if PlotController.MyPlot == nil then
		return
	end
	--[[
		does it need to be like this?
		this does keep hotbar state and build state seperate....
		hotbarselected -> dispatch -> watch selected -> dispatch -> watch itemId
	]]
	State:dispatch({
		type = "SetBuild",
		itemId = itemId,
	})
end

function Controller:StopBuild()
	State:dispatch({
		type = "SetBuild",
		itemId = Sift.None,
	})
end

function Controller:_updatePrefabPosition(delta: number)
	debug.profilebegin("UPDATE PREFAB")
	if PlotController.MyPlot == nil then
		return
	end

	local prefab: Model = _janitor:Get("Prefab")
	prefab.PrimaryPart.PivotOffset = CFrame.new(-prefab.PrimaryPart.Size / 2)

	local grid = PlotController.MyPlot.Grid

	local buildState = State:getState().build
	local itemId: number = buildState.itemId

	if itemId == nil then
		return
	end

	local baseItemData: ItemData.ItemData = ItemData[itemId]

	local rotation: number = buildState.rotation
	local rotationOffset = GridUtil.GetRotationOffset(baseItemData.Id, GridUtil.Directions[rotation + 1])
	local position: Vector2 = buildState.position
	local placedObjectWorldCFrame: CFrame = grid:GetWorldCFrame(position)
		* CFrame.new(Vector3.new(rotationOffset.X, 0, rotationOffset.Y) * grid.cellSize)
		* CFrame.Angles(0, math.pi / 2 * rotation, 0)

	local goal = prefab:GetPivot():Lerp(placedObjectWorldCFrame, delta * PREFAB_SPEED)
	prefab:PivotTo(goal)
	debug.profileend()
end

function Controller:KnitStart()
	-- populate hotbar
	State:dispatch({
		type = "SetItems",
		items = items,
	})
	-- inputs
	local InputController = Knit.GetController("InputController")
	for i = 1, 9 do
		InputController:Add(string.format("Hotbar%i", i), function()
			State:dispatch({
				type = "SetSelected",
				selected = i,
			})
		end)
	end
	InputController:Add("Rotate", function()
		local buildState = State:getState().build
		local itemId: number = buildState.itemId

		if itemId == nil then
			return
		end

		local rotation: number = buildState.rotation
		State:dispatch({
			type = "SetRotation",
			rotation = (rotation + 1) % #GridUtil.Directions,
		})
	end)
	InputController:Add("Activate", function() -- TODO delete tool/mode
		if PlotController.MyPlot == nil then
			return
		end

		local state = State:getState()

		local buildState = state.build
		local itemId: number = buildState.itemId

		if itemId == nil then
			return
		end

		local canPlace: boolean = buildState.canPlace
		if not canPlace then
			return
		end

		local rotation: number = buildState.rotation
		local position: Vector2 = buildState.position
		local serialized = GridUtil.SerializeCell(itemId, position, rotation)
		-- update plot
		State:dispatch({
			type = "AddObject",
			serialized = serialized, 
		})
		-- tell the server
		PlotService.PlaceObject:Fire(itemId, position, rotation)

		-- update data for client
		local dataState = state.data
		State:dispatch({
			type = "SetPlayerData",
			key = "GridObjects",
			value = Sift.Array.push(dataState.GridObjects, serialized),
		})
	end)
	-- every 1/10 second check which grid position mouse is in
	Timer.Simple(1 / 10, function()
		if PlotController.MyPlot == nil then
			return
		end

		local ignore = { _janitor:Get("Prefab") }
		for _, v in Players:GetPlayers() do
			table.insert(ignore, v.Character)
		end

		local castResult = InputController:CastInWorld(100, ignore)
		local raycastResult: RaycastResult = castResult.raycastResult
		local cframe = CFrame.new(castResult.Origin + castResult.Direction)
		if raycastResult then
			cframe = CFrame.new(raycastResult.Position)
		end

		local grid = PlotController.MyPlot.Grid
		local position: Vector2 = grid:GetXY(cframe)

		State:dispatch({
			type = "SetPosition",
			position = position,
		})

		local itemId = State:getState().build.itemId
		if itemId ~= nil then
			local canPlace = self:CheckCanPlace(grid, position, itemId)
			State:dispatch({
				type = "SetCanPlace",
				canPlace = canPlace,
			})
		end
	end, false, Run.RenderStepped)
end

function Controller:KnitInit()
	PlotController = Knit.GetController("PlotController")
	PlotService = Knit.GetService("PlotService")

	local function itemIdChanged(id: number)
		local baseItemData: ItemData.ItemData = ItemData[id]
		local prefab = baseItemData.Prefab
		prefab = prefab:Clone()
		_janitor:Add(prefab, nil, "Prefab")
		for _, part: BasePart in prefab:GetDescendants() do
			if not part:IsA("BasePart") then
				continue
			end
			part.CanCollide = false
			part.CanQuery = false
			part.CanTouch = false
		end

		Run:UnbindFromRenderStep("UpdatePrefabPosition") -- just in case
		Run:BindToRenderStep("UpdatePrefabPosition", Enum.RenderPriority.Camera.Value, function(delta: number)
			self:_updatePrefabPosition(delta)
		end)
		_janitor:Add(function()
			adorneeState:set(nil)
			Run:UnbindFromRenderStep("UpdatePrefabPosition")
		end)

		self:_updatePrefabPosition(1 / PREFAB_SPEED)
		adorneeState:set(prefab)

		prefab.Parent = workspace.CurrentCamera
	end
	-- this has to go before watching hotbar.selected otherwise it will bug out. TODO fix?
	do
		watcher(function(state)
			return state.build.itemId
		end, function(itemId)
			if itemId == nil then
				_janitor:Cleanup()
			else
				itemIdChanged(itemId)
			end
		end)
	end

	local function selectedChanged(slot: number)
		if slot == nil then
			self:StopBuild()
		else
			local itemId: number = items[slot]
			self:StartBuild(itemId)
		end
	end

	local selectedSlot = Fusion.State()
	-- watch for hotbar selected
	do
		watcher(function(state)
			return state.hotbar.selected
		end, function(selected)
			selectedSlot:set(selected)
			selectedChanged(selected)
		end)
	end
	-- watch for hotbar items
	local hotbarItems = Fusion.State({})
	do
		local function onChange(newItems)
			hotbarItems:set(newItems)
		end

		local function selector(state)
			return state.hotbar.items
		end

		local value = selector(State:getState())

		State.changed:connect(function(newState, _oldState)
			local newValue = selector(newState)
			if Sift.Array.equalsDeep(newValue, value) then
				return
			end
			value = newValue
			onChange(value)
		end)

		onChange(value)
	end
	-- watch for canPlace
	do
		watcher(function(state)
			return state.build.canPlace
		end, function(canPlace)
			canPlaceState:set(canPlace)
		end)
	end
	-- create hotbar ui
	local hotbarFrame: Frame = UI.Hotbar({
		hotbarItems = hotbarItems,
		selectedSlot = selectedSlot,
		onSelected = function(i)
			State:dispatch({
				type = "SetSelected",
				selected = i,
			})
		end,
	})
	hotbarFrame.Parent = UI.Gui
end

return Controller
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="200">
          <Properties>
            <string name="Name">Plot</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0I1OEE2MjFBLUY4Q0MtNEQ4Ny04NzRDLTlCOTVFQzkxRTE4Qn0=]]></BinaryString>
            <string name="Source"><![CDATA[-- PlotController
-- 0_1195
-- May 13, 2022

--[[

is there a better way to get current plot for localplayer?

]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)
local State = require(ReplicatedStorage.Game.Modules.State)

local Controller = Knit.CreateController({
	Name = "PlotController",

	MyPlot = nil,
})

function Controller:KnitStart()
	local DataController = Knit.GetController("DataController")

	-- feels jank
	DataController.DataChanged:Connect(function(key, value)
		if key == "GridObjects" then
			if self.MyPlot == nil then
				return
			end

			State:dispatch({
				type = "SetObjects",
				objects = value,
			})
		end
	end)
end

function Controller:KnitInit() end

return Controller
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="201">
        <Properties>
          <string name="Name">Modules</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="202">
          <Properties>
            <string name="Name">State</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezc1REI1QzZDLTFCQkItNDM4Ni1BNTBDLUU3M0FDMzA3RkNGRH0=]]></BinaryString>
            <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- local Silo = require(ReplicatedStorage.Packages.Silo)
-- local DataSilo = require(script.Silos.Data)
-- local ScaleSilo = require(script.Silos.Scale)
-- local HotbarSilo = require(script.Silos.Hotbar)
-- local InputSilo = require(script.Silos.Input)
-- local BuildSilo = require(script.Silos.Build)
-- local PlotSilo =  require(script.Silos.Plot)

-- return {
-- 	State = Silo.combine({
-- 		data = DataSilo,
-- 		scale = ScaleSilo,
-- 		hotbar = HotbarSilo,
-- 		input = InputSilo,
-- 		build = BuildSilo,
-- 		plot = PlotSilo,
-- 	}, {}),

-- 	Data = DataSilo,
-- 	Scale = ScaleSilo,
-- 	Hotbar = HotbarSilo,
-- 	Input = InputSilo,
-- 	Build = BuildSilo,
-- 	Plot = PlotSilo,
-- }

local Rodux = require(ReplicatedStorage.Game.Rodux)

local reducer = Rodux.combineReducers({
	build = require(script.Reducers.Build),
	data = require(script.Reducers.Data),
	hotbar = require(script.Reducers.Hotbar),
	input = require(script.Reducers.Input),
	plot = require(script.Reducers.Plot),
	scale = require(script.Reducers.Scale),
})

local store = Rodux.Store.new(reducer, {}, {
	Rodux.thunkMiddleware, --Rodux.loggerMiddleware,
})

return store
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="Folder" referent="203">
            <Properties>
              <string name="Name">Reducers</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="204">
              <Properties>
                <string name="Name">Build</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0I3NkQ1QUNFLUQ0RTUtNEQyOC04Njc5LTJFMDIzQjdFQkU5N30=]]></BinaryString>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Rodux = require(ReplicatedStorage.Game.Rodux)
local Sift = require(ReplicatedStorage.Packages.sift)

local initialState = {
	itemId = nil,

	rotation = 0,
	position = Vector2.new(0, 0),

	canPlace = false,

	mode = "build",
}

local reducer = Rodux.createReducer(initialState, {
	SetBuild = function(state, action)
		return Sift.Dictionary.merge(state, {
			itemId = action.itemId,
		})
	end,

	SetRotation = function(state, action)
		return Sift.Dictionary.merge(state, {
			rotation = action.rotation,
		})
	end,

	SetPosition = function(state, action)
		return Sift.Dictionary.merge(state, {
			position = action.position,
		})
	end,

	SetCanPlace = function(state, action)
		return Sift.Dictionary.merge(state, {
			canPlace = action.canPlace,
		})
	end,
})

return reducer
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="205">
              <Properties>
                <string name="Name">Data</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0VBREI4NDZGLTM3RjctNDY4Ny1BMTA4LTEyOUFGN0E0Q0JCMH0=]]></BinaryString>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Rodux = require(ReplicatedStorage.Game.Rodux)
local Sift = require(ReplicatedStorage.Packages.sift)
local DataTemplate = require(ReplicatedStorage.Game.Shared.DataTemplate)

local initialState = Sift.Dictionary.copyDeep(DataTemplate)

local reducer = Rodux.createReducer(initialState, {
	SetPlayerData = function(state, action)
		return Sift.Dictionary.merge(state, {
			[action.key] = action.value,
		})
	end,
})

return reducer
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="206">
              <Properties>
                <string name="Name">Hotbar</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezRBMDJCMEY3LUI0RjYtNENGNC1CQzUzLTMxODE2Q0UxQkEwNX0=]]></BinaryString>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Rodux = require(ReplicatedStorage.Game.Rodux)
local Sift = require(ReplicatedStorage.Packages.sift)

local initialState = {
	items = {},
	selected = nil,
}

local reducer = Rodux.createReducer(initialState, {
	SetSelected = function(state, action)
		local currentSelected = state.selected
		local i = action.selected
		local selected = (currentSelected == i) and Sift.None or i
		return Sift.Dictionary.merge(state, {
			selected = selected,
		})
	end,

	SetItems = function(state, action)
		return Sift.Dictionary.merge(state, {
			items = action.items,
		})
	end,
})

return reducer
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="207">
              <Properties>
                <string name="Name">Input</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0Q4NjdGOTI4LTM1QjQtNDhFNi04MTI0LUFEQTdGNkY1NDUwMH0=]]></BinaryString>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Rodux = require(ReplicatedStorage.Game.Rodux)
local Sift = require(ReplicatedStorage.Packages.sift)

local initialState = {
	preferredInput = "Keyboard",
}

local reducer = Rodux.createReducer(initialState, {
	SetPreferred = function(state, action)
		return Sift.Dictionary.merge(state, {
			preferredInput = action.preferredInput,
		})
	end,
})

return reducer
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="208">
              <Properties>
                <string name="Name">Plot</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezhFMkM5MUNDLTFGRkItNERDMi1BMEY3LUVDMTM5NjE1NTRGOX0=]]></BinaryString>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Rodux = require(ReplicatedStorage.Game.Rodux)
local Sift = require(ReplicatedStorage.Packages.sift)
local DataTemplate = require(ReplicatedStorage.Game.Shared.DataTemplate)

local initialState = Sift.Dictionary.copy(DataTemplate.GridObjects)

local reducer = Rodux.createReducer(initialState, {
	SetObjects = function(_state, action)
		return Sift.Array.copyDeep(action.objects)
	end,

	AddObject = function(state, action)
		return Sift.Array.push(state, action.serialized)
	end,

	RemoveObject = function(state, action)
		return Sift.Array.removeValue(state, action.serialized)
	end,
})

return reducer
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="209">
              <Properties>
                <string name="Name">Scale</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezczMTgwM0RBLTgwMEYtNDE1Mi05RjdGLTdFMDU1MUQ2NTZDQn0=]]></BinaryString>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Rodux = require(ReplicatedStorage.Game.Rodux)
local Sift = require(ReplicatedStorage.Packages.sift)

local initialState = {
	scale = 1,
}

local reducer = Rodux.createReducer(initialState, {
	SetScale = function(state, action)
		return Sift.Dictionary.merge(state, {
			scale = action.scale,
		})
	end,
})

return reducer
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="210">
          <Properties>
            <string name="Name">UI</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0M1Q0ZCNkU4LTg0RkMtNDVDMy1BMkMyLURBQUU1M0NBOEE3RX0=]]></BinaryString>
            <string name="Source"><![CDATA[local ScreenGui = require(script.ScreenGui)

return {
	Back = ScreenGui({
		DisplayOrder = 1,
	}),

	Gui = ScreenGui({
		DisplayOrder = 5,
	}),

	Front = ScreenGui({
		DisplayOrder = 10,
	}),

	ScreenGui = ScreenGui,
	UIScale = require(script.UIScale),
	Hotbar = require(script.Hotbar),
	ScaledCircleButton = require(script.ScaledCircleButton),
	HotbarButton = require(script.HotbarButton),
	CircleFrame = require(script.CircleFrame),
	CircleFrameIcon = require(script.CircleFrameIcon),
	CircleButton = require(script.CircleButton),
	ImageFrame = require(script.ImageFrame),
	ScaledFrame = require(script.ScaledFrame),
	Viewport = require(script.Viewport),
}
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="211">
            <Properties>
              <string name="Name">Hotbar</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezcxMkRBOTJBLTU3RDgtNEI0Qi1CRTJGLTZEQTI0OEM2Nzk2N30=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)
local UIScale = require(script.Parent.UIScale)
local HotbarButton = require(script.Parent.HotbarButton)
-- local ImageFrame = require(script.Parent.ImageFrame)
local Viewport = require(script.Parent.Viewport)
local ItemData = require(ReplicatedStorage.Game.Shared.ItemData)

return function(props)
	local hotbarItems = props.hotbarItems
	local selectedSlot = props.selectedSlot
	local onSelected: (index: number) -> () = props.onSelected

	return Fusion.New("Frame")({
		AnchorPoint = Vector2.new(0.5, 1),
		BackgroundTransparency = 1,
		Position = UDim2.new(0.5, 0, 1, -20),
		Size = UDim2.new(1, 0, 0, 100),

		[Fusion.Children] = {
			Fusion.New("UIListLayout")({
				Padding = UDim.new(0, 20),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			UIScale({}),

			Fusion.ComputedPairs(hotbarItems, function(index: number, id: number)
				local baseItemData = ItemData[id]
				local prefab = baseItemData.Prefab
				prefab = prefab:Clone()

				local Icon: ViewportFrame = Viewport({
					Current = Fusion.State(prefab),
					Fov = Fusion.State(20),
				})

				return HotbarButton({
					LayoutOrder = index,
					selected = Fusion.Computed(function()
						return index == selectedSlot:get()
					end),
					onSelected = onSelected,

					Icon = Icon,
					ButtonColor = Color3.fromRGB(151, 184, 255),
				})
			end),
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="212">
            <Properties>
              <string name="Name">UIScale</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezlCQTY2RkI1LTBEQzktNDYzMy04NTMwLUI1ODc5MEJGM0UyNX0=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)
local State = require(ReplicatedStorage.Game.Modules.State)
local RoduxWatcher = require(ReplicatedStorage.Game.Shared.RoduxWatcher)

local watcher = RoduxWatcher(State)

local scaleState = Fusion.State(1)

watcher(function(state)
	return state.scale.scale
end, function(scale)
	scaleState:set(scale)
end)

return function()
	return Fusion.New("UIScale")({
		Scale = Fusion.Computed(function()
			return scaleState:get()
		end),
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="213">
            <Properties>
              <string name="Name">ScreenGui</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezExODRBODVELUM2MjItNDU0RS1BQ0I5LURFMjkxNDhFQUM1Mn0=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Knit = require(ReplicatedStorage.Packages.Knit)
local Fusion = require(ReplicatedStorage.Packages.Fusion)

return function(props)
	return Fusion.New("ScreenGui")({
		DisplayOrder = props.DisplayOrder or 1,
		IgnoreGuiInset = true,
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
		Parent = Knit.Player.PlayerGui,
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="214">
            <Properties>
              <string name="Name">HotbarButton</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezk2Q0UyRkM0LUY5OEItNDE1Ri04OEQwLTUwQzg4MzY2NzE1NH0=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)
local CircleButton = require(script.Parent.CircleButton)

return function(props)
	local layoutOrder: number = props.LayoutOrder

	local selected = props.selected
	local onSelected = props.onSelected

	local offsetGoal = Fusion.Computed(function()
		return selected:get() and UDim2.fromScale(0.5, 0.3) or UDim2.fromScale(0.5, 0.5)
	end)
	local offsetSpring = Fusion.Spring(offsetGoal, 30, 1)

	local Icon: Frame = props.Icon
	local BorderColor: Color3 = props.BorderColor
	local ButtonColor: Color3 = props.ButtonColor

	return Fusion.New("Frame")({
		BackgroundTransparency = 1,
		Size = UDim2.fromScale(1, 1),
		LayoutOrder = layoutOrder,

		[Fusion.Children] = {
			Fusion.New("UIAspectRatioConstraint")({
				AspectRatio = 1,
				AspectType = Enum.AspectType.FitWithinMaxSize,
				DominantAxis = Enum.DominantAxis.Height,
			}),

			CircleButton({
				position = offsetSpring,

				Icon = Icon,
				BorderColor = BorderColor,
				ButtonColor = ButtonColor,

				Activated = function(_inputObject: InputObject)
					onSelected(layoutOrder)
				end,
			}),
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="215">
            <Properties>
              <string name="Name">ScaledCircleButton</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0MxRjVENTgyLUQ2QzktNDU4Ni1CNTVFLTEyNjE3MDI5RjBFN30=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)

return function(props)
	local buttonScale = props.buttonScale

	local InputBegan: (inputObject: InputObject) -> () = props.InputBegan
	local InputEnded: (inputObject: InputObject) -> () = props.InputEnded
	local Activated: (inputObject: InputObject) -> () = props.Activated

	return Fusion.New("Frame")({
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 1),
		ZIndex = 10,

		[Fusion.Children] = {
			Fusion.New("UIScale")({
				Scale = 1.15,
			}),

			Fusion.New("TextButton")({
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundTransparency = 1,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(1, 1),

				[Fusion.OnEvent("Activated")] = function(inputObject: InputObject)
					if Activated then
						Activated(inputObject)
					end
				end,

				[Fusion.OnEvent("InputBegan")] = function(inputObject: InputObject)
					if
						(inputObject.UserInputType == Enum.UserInputType.MouseButton1)
						or (inputObject.UserInputType == Enum.UserInputType.Touch)
					then
						buttonScale:set(0.9)
					elseif inputObject.UserInputType == Enum.UserInputType.MouseMovement then
						buttonScale:set(1.05)
					end

					if InputBegan then
						InputBegan(inputObject)
					end
				end,

				[Fusion.OnEvent("InputEnded")] = function(inputObject: InputObject)
					buttonScale:set(1)
					if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
						buttonScale:set(1)
					end

					if InputEnded then
						InputEnded(inputObject)
					end
				end,

				[Fusion.Children] = {
					Fusion.New("UICorner")({
						CornerRadius = UDim.new(0.5, 0),
					}),
				},
			}),
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="216">
            <Properties>
              <string name="Name">CircleFrame</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezc4QTU1M0ZDLTc3OTctNEMzMS05OEZFLTRENkM3OENGOUZENX0=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)

return function(props)
	local buttonScale = props.buttonScale

	local Icon: Frame = props.Icon
	local BorderColor: Color3 = props.BorderColor or Color3.fromRGB(255, 255, 255)
	local ButtonColor: Color3 = props.ButtonColor or Color3.fromRGB(0, 0, 0)

	local scaleGoal = Fusion.Computed(function()
		return buttonScale:get()
	end)
	local scaleSpring = Fusion.Spring(scaleGoal, 30, 1)

	return Fusion.New("Frame")({
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 1),

		[Fusion.Children] = {
			-- tooltip/badge
			Fusion.New("Frame")({
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundTransparency = 1,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(1, 1),
				ZIndex = 2,

				[Fusion.Children] = {
					-- badge?
					Fusion.New("Frame")({
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundTransparency = 1,
						Position = UDim2.fromScale(0.1, 0.1),
						Size = UDim2.fromScale(0.4, 0.4),
						ZIndex = 5,

						[Fusion.Children] = {},
					}),
					-- tooltip?
					Fusion.New("Frame")({
						AnchorPoint = Vector2.new(0.5, 1),
						BackgroundTransparency = 1,
						Position = UDim2.fromScale(0.5, -0.1),
						Size = UDim2.fromScale(1, 0.3),
						ZIndex = 5,

						[Fusion.Children] = {},
					}),
				},
			}),
			-- scale circle
			Fusion.New("Frame")({
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundTransparency = 1,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(1, 1),
				ZIndex = 1,

				[Fusion.Children] = {
					-- for scaling the frame
					Fusion.New("UIScale")({
						Scale = scaleSpring,
					}),
					-- shadow
					Fusion.New("ImageLabel")({
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundTransparency = 1,
						Position = UDim2.fromScale(0.5, 0.7),
						Size = UDim2.fromScale(1, 1),
						Image = "rbxasset://textures/particles/explosion01_implosion_main.dds",
						ImageColor3 = Color3.fromRGB(0, 0, 0),

						[Fusion.Children] = {
							Fusion.New("UIScale")({
								Scale = 2,
							}),
						},
					}),

					Fusion.New("Frame")({
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = BorderColor, -- border color maybe change if selected
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(1, 1),
						ZIndex = 2,

						[Fusion.Children] = {
							Fusion.New("UICorner")({
								CornerRadius = UDim.new(0.5, 0),
							}),

							Fusion.New("Frame")({
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundTransparency = 1,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(1, 1),

								[Fusion.Children] = {
									Fusion.New("UIPadding")({
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),

									Fusion.New("Frame")({
										AnchorPoint = Vector2.new(0.5, 0.5),
										BackgroundColor3 = ButtonColor, -- button background color
										Position = UDim2.fromScale(0.5, 0.5),
										Size = UDim2.fromScale(1, 1),

										[Fusion.Children] = {
											Fusion.New("UICorner")({
												CornerRadius = UDim.new(0.5, 0),
											}),
										},
									}),
								},
							}),
							-- icon holder
							Fusion.New("Frame")({
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundTransparency = 1,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(1, 1),
								ZIndex = 2,

								[Fusion.Children] = {
									Icon,
								},
							}),
						},
					}),
				},
			}),
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="217">
            <Properties>
              <string name="Name">CircleFrameIcon</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezkwNjEyRjc4LUFBMTAtNDlFQy1CRDk2LTQyNTM4MkE4M0Y2Mn0=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)

return function(props)
	return Fusion.New("Frame")({
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 1),

		[Fusion.Children] = {
			Fusion.New("UIScale")({
				Scale = 0.5,
			}),

			Fusion.New("ImageLabel")({
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundTransparency = 1,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(1, 1),
				Image = props.Image or "rbxasset://textures/ui/GuiImagePlaceholder.png",
				ScaleType = Enum.ScaleType.Fit,
			}),
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="218">
            <Properties>
              <string name="Name">CircleButton</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezQ2ODNCRjkwLTI3MUMtNDA2MS04MDhFLTRFNzcwMDNBQzkwMX0=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)
local ScaledCircleButton = require(script.Parent.ScaledCircleButton)
local CircleFrame = require(script.Parent.CircleFrame)

return function(props)
	local position = props.position

	local InputBegan: (inputObject: InputObject) -> () = props.InputBegan
	local InputEnded: (inputObject: InputObject) -> () = props.InputEnded
	local Activated: (inputObject: InputObject) -> () = props.Activated

	local Icon: Frame = props.Icon
	local BorderColor: Color3 = props.BorderColor
	local ButtonColor: Color3 = props.ButtonColor

	local buttonScale = Fusion.State(1)

	return Fusion.New("Frame")({
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		Position = position, -- for positioning the button
		Size = UDim2.fromScale(1, 1),

		[Fusion.Children] = {
			CircleFrame({
				buttonScale = buttonScale,

				Icon = Icon,
				BorderColor = BorderColor,
				ButtonColor = ButtonColor,
			}),

			ScaledCircleButton({
				buttonScale = buttonScale,

				Activated = Activated,
				InputBegan = InputBegan,
				InputEnded = InputEnded,
			}),
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="219">
            <Properties>
              <string name="Name">ImageFrame</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0Y1Q0IwODM5LUJCMkItNDkwMy1BNDlCLTk0MDI1OEI1MkM1Q30=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)

return function(props)
	local image: string = props.Image

	return Fusion.New("Frame")({
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 1),

		[Fusion.Children] = {
			Fusion.New("UIScale")({
				Scale = 0.6,
			}),

			Fusion.New("ImageLabel")({
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundTransparency = 1,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(1, 1),

				Image = image,
				ScaleType = Enum.ScaleType.Fit,
			}),
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="220">
            <Properties>
              <string name="Name">ScaledFrame</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0U0MkUyNjQ5LUY2NEMtNDA5NS04OUFDLThGQ0I2OTczRDhFM30=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)
local UIScale = require(script.Parent.UIScale)

return function(props)
	local AnchorPoint: Vector2 = props.AnchorPoint or Vector2.new(0.5, 0.5)
	local Position: UDim2 = props.Position or UDim2.fromScale(0.5, 0.5)
	local Size: UDim2 = props.Size or UDim2.fromScale(1, 1)

	local BorderColor: Color3 = props.BorderColor or Color3.fromRGB(255, 255, 255)
	local FrameColor: Color3 = props.FrameColor or Color3.fromRGB(0, 0, 0)

	return Fusion.New("Frame")({
		AnchorPoint = AnchorPoint,
		BackgroundTransparency = 1,
		Position = Position,
		Size = Size,

		[Fusion.Children] = {
			UIScale({}),

			Fusion.New("Frame")({
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundTransparency = 1,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(1, 1),

				[Fusion.Children] = {
					Fusion.New("Frame")({ -- container
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = BorderColor,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(1, 1),
						ZIndex = 2,

						[Fusion.Children] = {
							Fusion.New("UICorner")({
								CornerRadius = UDim.new(0, 20),
							}),

							Fusion.New("UIPadding")({
								PaddingBottom = UDim.new(0, 5),
								PaddingLeft = UDim.new(0, 5),
								PaddingRight = UDim.new(0, 5),
								PaddingTop = UDim.new(0, 5),
							}),

							Fusion.New("Frame")({ -- frame color
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = FrameColor,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(1, 1),

								[Fusion.Children] = {
									Fusion.New("UICorner")({
										CornerRadius = UDim.new(0, 15),
									}),
								},
							}),

							Fusion.New("Frame")({ -- container
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundTransparency = 1,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(1, 1),
								ZIndex = 2,

								[Fusion.Children] = {}, -- put content here
							}),
						},
					}),

					Fusion.New("Frame")({ -- shadow
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundTransparency = 1,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(1, 1),

						[Fusion.Children] = {
							Fusion.New("UIPadding")({
								PaddingBottom = UDim.new(0, -80),
								PaddingLeft = UDim.new(0, -80),
								PaddingRight = UDim.new(0, -80),
								PaddingTop = UDim.new(0, -60),
							}),

							Fusion.New("ImageLabel")({
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundTransparency = 1,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(1, 1),
								Image = "rbxasset://textures/particles/explosion01_implosion_main.dds",
								ImageColor3 = Color3.fromRGB(0, 0, 0),
								ScaleType = Enum.ScaleType.Slice,
								SliceCenter = Rect.new(128, 128, 128, 128),
							}),
						},
					}),
				},
			}),
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="221">
            <Properties>
              <string name="Name">Viewport</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0U3NkQ2NDRFLUYyNzYtNEM3OS1BNjRELTkyRDcwNDg5MDU3OH0=]]></BinaryString>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)

-- https://github.com/Quenty/NevermoreEngine/blob/main/src/viewport/src/Shared/Viewport.lua

local function fitSphereToCamera(radius, fovDeg, aspectRatio)
	local halfFov = 0.5 * math.rad(fovDeg)
	if aspectRatio < 1 then
		halfFov = math.atan(aspectRatio * math.tan(halfFov))
	end

	return radius / math.sin(halfFov)
end

local function getCubeoidDiameter(size)
	return math.sqrt(size.x ^ 2 + size.y ^ 2 + size.z ^ 2)
end

local function fitBoundingBoxToCamera(size, fovDeg, aspectRatio)
	local radius = getCubeoidDiameter(size) / 2
	return fitSphereToCamera(radius, fovDeg, aspectRatio)
end

return function(props)
	local current = props.Current or Fusion.State()
	local fov = props.Fov or Fusion.State(20)

	local absoluteSize = Fusion.State(Vector2.new())
	local rotationYaw = Fusion.State(math.pi / 4)
	-- local rotationYawSpring = Spring(rotationYaw)
	local rotationPitch = Fusion.State(-math.pi / 6)
	-- local rotationPitchSpring = Spring(rotationPitch)

	local camera = Fusion.New("Camera")({
		FieldOfView = fov,
		CFrame = Fusion.Computed(function()
			if not current:get() then
				return CFrame.new()
			end

			local aspectRatio = absoluteSize:get().X / absoluteSize:get().Y
			local bbCFrame, bbSize = current:get():GetBoundingBox()
			if not bbCFrame then
				return CFrame.new()
			end

			local fit = fitBoundingBoxToCamera(bbSize, fov:get(), aspectRatio)
			return CFrame.new(bbCFrame.p)
				* CFrame.Angles(0, rotationYaw:get(), 0)
				* CFrame.Angles(rotationPitch:get(), 0, 0)
				* CFrame.new(0, 0, fit)
		end),
	})

	return Fusion.New("ViewportFrame")({
		LightColor = Color3.fromRGB(255, 255, 255),
		Ambient = Color3.fromRGB(255, 255, 255),
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		BackgroundColor3 = Color3.fromRGB(95, 95, 95),
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 1),
		CurrentCamera = camera,

		[Fusion.OnChange("AbsoluteSize")] = function(size)
			absoluteSize:set(size)
		end,

		[Fusion.Children] = {
			current,
			camera,
		},
	})
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="222">
        <Properties>
          <string name="Name">Shared</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="223">
          <Properties>
            <string name="Name">DataTemplate</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezcxRjA4RjgxLTVBODEtNEZCQy05MjYyLUIwNzk1RkZCNjY4RH0=]]></BinaryString>
            <string name="Source"><![CDATA[return {
	Version = 1,

	GridObjects = {
		"1|1|10|0",
		"1|10|2|2",
		"3|1|2|1",
	},
	Keybinds = {
		Keyboard = {},
		Gamepad = {},
		Touch = {},
	},
}
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="224">
          <Properties>
            <string name="Name">Grid</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezBGMjQ1RkFBLUEwQkEtNEI2Ny1CMjQwLTg0MDVDRjc2QkI5OH0=]]></BinaryString>
            <string name="Source"><![CDATA[return {
	Grid = require(script.Grid),
	GridUtil = require(script.GridUtil),
	Cell = require(script.Cell),
	CellObject = require(script.CellObject),
}
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="225">
            <Properties>
              <string name="Name">Grid</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0QzMUJGNzk1LTc3OTQtNEI2QS04ODQ2LTlBQTc3NzFDNDg1Nn0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Class
-- 0_1195
-- January 22, 2022

--[[

Grid > Cell > CellObject

]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Janitor = require(ReplicatedStorage.Packages.Janitor)
local Signal = require(ReplicatedStorage.Packages.Signal)
local Cell = require(script.Parent.Cell)
local GridUtil = require(script.Parent.GridUtil)

local Class = {}
Class.__index = Class

function Class.new(origin: CFrame, size: Vector2, cellSize: number)
	assert(typeof(origin) == "CFrame", string.format("Argument 1 CFrame expected. Got %s", typeof(origin)))
	assert(typeof(size) == "Vector2", string.format("Argument 2 Vector2 expected. Got %s", typeof(size)))
	assert(typeof(cellSize) == "number", string.format("Argument 3 number expected. Got %s", typeof(cellSize)))

	local width = math.round(size.X / cellSize)
	local length = math.round(size.Y / cellSize)

	local self = setmetatable({
		X = width,
		Y = length,

		cellSize = cellSize,

		gridArray = nil,

		origin = origin,
		size = Vector2.new(width, length),

		CellChanged = Signal.new(),

		_janitor = Janitor.new(),
	}, Class)

	local gridArray = GridUtil.Array2D(width, length)
	for x = 1, self.X do
		for y = 1, self.Y do
			gridArray[x][y] = Cell.new(self, x, y)
		end
	end
	self.gridArray = gridArray

	self._janitor:Add(self.CellChanged)
	self._janitor:Add(function()
		for x = 1, self.X do
			for y = 1, self.Y do
				gridArray[x][y]:Destroy()
			end
			table.clear(gridArray[x])
		end
		self.gridArray = nil
	end)

	return self
end

function Class:__tostring()
	return string.format("Grid<%d, %d>", self.X, self.Y)
end

function Class:_isValid(position: Vector2): boolean
	local width: number = self.X
	local length: number = self.Y
	return (position.X > 0) and (position.Y > 0) and (position.X <= width) and (position.Y <= length)
end

-- function Class:Debug(parent: Instance)
-- 	local gridArray = self.gridArray
-- 	local debugArray = GridUtil.Array2D(self.width, self.length)

-- 	-- local debugPart = GridUtil.CreateDebugPart(parent, self.origin, self.size)
-- 	-- for x = 1, self.width do
-- 	-- 	for y = 1, self.length do
-- 	-- 		debugArray[x][y] = GridUtil.CreateDebugCell(debugPart.SurfaceGui.Frame, gridArray[x][y])
-- 	-- 	end
-- 	-- end

-- 	local octree = Octree.new()
-- 	local previous = {}

-- 	for x = 1, self.width do
-- 		for y = 1, self.length do
-- 			local part = GridUtil.CreateDebugPart(
-- 				parent,
-- 				self:GetWorldCFrame(x, y) * CFrame.new(self.cellSize / 2, 0, self.cellSize / 2),
-- 				gridArray[x][y]
-- 			)
-- 			octree:CreateNode(part.Position, part)
-- 			debugArray[x][y] = part
-- 		end
-- 	end

-- 	local timer = Timer.new(0.1)
-- 	self._janitor:Add(timer)
-- 	timer.Tick:Connect(function()
-- 		for _, part in ipairs(previous) do
-- 			part.SurfaceGui.Enabled = false
-- 		end

-- 		local parts = octree:RadiusSearch(workspace.CurrentCamera.CFrame.Position, 50)
-- 		for _, part in ipairs(parts) do
-- 			part.SurfaceGui.Enabled = true
-- 		end

-- 		previous = parts
-- 	end)
-- 	timer:Start()

-- 	self._debugArray = debugArray

-- 	self._janitor:Add(function()
-- 		table.clear(debugArray)
-- 	end)

-- 	self._janitor:Add(self.CellChanged:Connect(function(x, y, value)
-- 		local text = string.format("[%d,%d]<br />%s", x, y, tostring(value))
-- 		debugArray[x][y].SurfaceGui.Frame.TextLabel.Text = text
-- 	end))
-- end

function Class:GetWorldCFrame(position: Vector2): CFrame
	local origin: CFrame = self.origin
	local cellSize: number = self.cellSize
	local x, y = position.X, position.Y
	x -= 1
	y -= 1
	return origin * CFrame.new(x * cellSize, 0, y * cellSize)
end

function Class:GetXY(cframe: CFrame): Vector2
	local origin: CFrame = self.origin
	local cellSize: number = self.cellSize
	local position = origin:Inverse() * cframe.Position
	local x = math.floor(position.X / cellSize) + 1
	local y = math.floor(position.Z / cellSize) + 1
	return Vector2.new(x, y)
end

function Class:SetCell_XY(position: Vector2, value)
	local gridArray = self.gridArray
	if self:_isValid(position) then
		gridArray[position.X][position.Y] = value
	else
		print(string.format("Tried to place %s at invalid location: [%s]", tostring(value), tostring(position)))
	end
end

function Class:SetCell_CFrame(cframe: CFrame, value)
	local position = self:GetXY(cframe)
	self:SetCell_XY(position, value)
end

function Class:GetCell_XY(position: Vector2)
	local gridArray = self.gridArray
	if self:_isValid(position) then
		return gridArray[position.X][position.Y]
	end
	return nil
end

function Class:GetCell_CFrame(cframe: CFrame)
	local position = self:GetXY(cframe)
	return self:GetCell_XY(position)
end

-- function Class:GetObjects()
-- 	local objects = {}

-- 	for x, row in ipairs(self.gridArray) do
-- 		for y, cellObject in ipairs(row) do
-- 			local placedObject = cellObject:Get()
-- 			if placedObject then
-- 				local objectData = {
-- 					X = x,
-- 					Y = y,
-- 					R = placedObject.Direction,
-- 					Id = placedObject.Id,
-- 				}

-- 				table.insert(objects, objectData)
-- 			end
-- 		end
-- 	end

-- 	return objects
-- end

function Class:Clear()
	local gridArray = self.gridArray
	for x = 1, self.X do
		for y = 1, self.Y do
			local cellObject = gridArray[x][y]
			if cellObject then
				cellObject:Clear()
			end
		end
	end
end

function Class:Destroy()
	self._janitor:Destroy()
end

return Class
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="226">
            <Properties>
              <string name="Name">GridUtil</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezI2N0IyRTQwLUQ4NDItNDk5RS1BMUIyLURBQjQ3NjNCOTQyRH0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Generic
-- 0_1195
-- January 22, 2022

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Fusion = require(ReplicatedStorage.Packages.Fusion)
local ItemData = require(ReplicatedStorage.Game.Shared.ItemData)

local debugPart: Part = Fusion.New("Part")({
	Transparency = 1,
	Size = Vector3.new(4, 1, 4),
	CastShadow = false,
	Anchored = true,
	CanCollide = false,
	CanTouch = false,
	CanQuery = false,
	PivotOffset = CFrame.new(0, 0.5, 0),
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
})

Fusion.New("SurfaceGui")({
	Adornee = debugPart,
	AlwaysOnTop = true,
	Enabled = false,
	Face = Enum.NormalId.Top,
	LightInfluence = 0,
	ResetOnSpawn = false,
	PixelsPerStud = 150,
	ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
	SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
	Parent = debugPart,

	[Fusion.Children] = {
		Fusion.New("Frame")({
			BackgroundTransparency = 1,
			Rotation = 90,
			Size = UDim2.fromScale(1, 1),

			[Fusion.Children] = {
				Fusion.New("TextLabel")({
					BackgroundTransparency = 1,
					Size = UDim2.fromScale(1, 1),
					RichText = true,
					TextColor3 = Color3.fromRGB(0, 0, 0),
					Font = Enum.Font.GothamBlack,
					Text = "",
					TextSize = 100,
					TextStrokeColor3 = Color3.fromRGB(255, 255, 255),
					TextStrokeTransparency = 0,
					TextWrapped = true,
				}),
			},
		}),
	},
})

local Generic = {}

Generic.Directions = { "Down", "Left", "Up", "Right" }

function Generic.CreateDebugPart(parent: Instance, cframe: CFrame, object: Cell): BasePart
	local text = string.format("[%d,%d]<br />%s", object.x, object.y, tostring(object))
	local part = debugPart:Clone()
	part.SurfaceGui.Frame.TextLabel.Text = text
	part:PivotTo(cframe)
	part.Parent = parent
	return part
end

-- function Generic.CreateDebugPart(parent, cframe, size)
-- 	local part = debugPart:Clone()
-- 	part.Size = Vector3.new(size.X, 1, size.Y)
-- 	part.PivotOffset = CFrame.new(-size.X/2, 0.5, -size.Y/2)
-- 	part:PivotTo(cframe)
-- 	part.Parent = parent
-- 	return part
-- end

-- function Generic.CreateDebugCell(parent, object)
-- 	local label = frame:Clone()
-- 	local text = string.format("[%d,%d]<br />%s", object.x, object.y, tostring(object))
-- 	label.TextLabel.Text = text
-- 	label.Parent = parent
-- 	return label
-- end

function Generic.Array2D(x, y)
	-- return table.create(x, table.create(y)) -- apparently this doesnt work

	local array = table.create(x)
	for i = 1, x do
		table.insert(array, i, table.create(y))
	end
	return array
end

function Generic.GetGridPositionList(id: number, offset: Vector2, dir: string): table
	local gridPositionList = {}
	local baseItemData: ItemData.ItemData = ItemData[id]

	local size = baseItemData.Size
	local width = size.X
	local length = size.Y

	if dir == "Down" or dir == "Up" then
		for x = 0, width - 1 do
			for y = 0, length - 1 do
				table.insert(gridPositionList, offset + Vector2.new(x, y))
			end
		end
	elseif dir == "Left" or dir == "Right" then
		for x = 0, length - 1 do
			for y = 0, width - 1 do
				table.insert(gridPositionList, offset + Vector2.new(x, y))
			end
		end
	end
	return gridPositionList
end

function Generic.GetRotationOffset(id: number, dir: string): Vector2
	local baseItemData: ItemData.ItemData = ItemData[id]

	local size = baseItemData.Size
	local width = size.X
	local length = size.Y

	if dir == "Left" then
		return Vector2.new(0, width)
	elseif dir == "Up" then
		return Vector2.new(width, length)
	elseif dir == "Right" then
		return Vector2.new(length, 0)
	end
	return Vector2.new()
end

function Generic.CanPlaceObjectInGrid(grid, gridPositionList): boolean
	local canSet = true
	for _, gridPosition: Vector2 in gridPositionList do
		local cell = grid:GetCell_XY(gridPosition)
		if not cell or not cell:CanSet() then
			canSet = false
			break
		end
	end
	return canSet
end

function Generic.PlaceObjectInGrid(grid, gridPositionList, cellObject)
	for _, gridPosition: Vector2 in gridPositionList do
		local cell = grid:GetCell_XY(gridPosition)
		if cell then
			cell:Set(cellObject)
		end
	end
end

function Generic.RemoveObjectFromGrid(grid, gridPositionList)
	for _, gridPosition in ipairs(gridPositionList) do
		local cell = grid:GetCell_XY(gridPosition)
		if cell then
			cell:Clear()
		end
	end
end

function Generic.SerializeCell(id: number, position: Vector2, rotation: number): string
	local x, y = position.X, position.Y
	return string.format("%i|%i|%i|%i", id, x, y, rotation)
	-- return {id = id, x = x, y = y, r = rotation}
end

function Generic.DeserializeCell(serialized: string): (number, Vector2, number)
	local id: string, x: string, y: string, rotation: string = string.match(serialized, "(%d+)|(%d+)|(%d+)|(%d+)")
	id = tonumber(id)
	local position = Vector2.new(tonumber(x), tonumber(y))
	rotation = tonumber(rotation)
	return id, position, rotation
	-- local id, x, y, rotation = serialized.id, serialized.x, serialized.y, serialized.r
	-- return id, Vector2.new(x, y), rotation
end

return Generic
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="227">
            <Properties>
              <string name="Name">Cell</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0YwOEUyNDg1LTYyMDctNDg2Ni1CREU1LTUxMTc1QjY5QjhERX0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Class
-- 0_1195
-- January 10, 2021

--[[



]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Janitor = require(ReplicatedStorage.Packages.Janitor)

local Class = {}
Class.__index = Class

function Class.new(grid, x: number, y: number)
	local self = setmetatable({
		Grid = grid,

		X = x,
		Y = y,

		_janitor = Janitor.new(),
	}, Class)

	return self
end

function Class:__tostring()
	local object = self._janitor:Get("Object")
	return string.format("Cell<%d, %d>%s", self.X, self.Y, tostring(object))
end

function Class:Set(object)
	local oldObject: any = self._janitor:Get("Object")
	if oldObject ~= object then
		if object ~= nil then
			self._janitor:Add(object, nil, "Object")
		else
			self._janitor:Remove("Object")
		end
		self.Grid.CellChanged:Fire(self.X, self.Y, object)
	end
end

function Class:Get()
	return self._janitor:Get("Object")
end

function Class:Clear()
	self:Set(nil)
end

function Class:CanSet()
	return self._janitor:Get("Object") == nil
end

function Class:Destroy()
	self.Grid = nil
	self._janitor:Destroy()
end

return Class
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="228">
            <Properties>
              <string name="Name">CellObject</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0E3NzRBNkRCLTdCN0UtNDlDNy05RTA2LTA5MzZFRDVEMkM4Rn0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Class
-- 0_1195
-- January 10, 2021

--[[



]]

local Class = {}
Class.__index = Class

function Class.new(value: any, origin: Vector2, direction: number)
	local self = setmetatable({
		Value = value,
		Origin = origin,
		Direction = direction,
	}, Class)

	return self
end

function Class:Get()
	return self.Value
end

function Class:__tostring()
	return string.format("CellObject<%s>", tostring(self.Value))
end

function Class:Destroy()
	local typeOf = typeof(self.Value)
	if typeOf == "Instance" then
		self.Value:Destroy()
	end
	self.Value = nil
end

return Class
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="229">
          <Properties>
            <string name="Name">ItemData</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezU4MkExODNBLTI4NzgtNDhEMS05NEZCLTZEQUM3OUY3NUQzMX0=]]></BinaryString>
            <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
export type ItemData = {
	Id: number,
	Name: string,

	Size: Vector2,

	Module: ModuleScript,
	Prefab: Model,
}

local itemData: {[number]: ItemData} = {}

local function initPrefab(baseItemData: ItemData): Model?
	local prefab: Model? = ReplicatedStorage.Assets:FindFirstChild(baseItemData.Name)
	if prefab then
		-- TODO setup model?
		prefab:SetAttribute("Id", baseItemData.Id)
		return prefab
	else
		return
	end
end

for _, module: ModuleScript in script:GetChildren() do
	local baseItemData: ItemData = require(module)
	baseItemData.Module = module

	local prefab = initPrefab(baseItemData)
	baseItemData.Prefab = prefab

	if itemData[baseItemData.Id] then
		warn(string.format("Conflicting Ids: %d %s %s", baseItemData.Id, baseItemData.Name, itemData[baseItemData.Id].Name))
	end

	itemData[baseItemData.Id] = baseItemData
end

return itemData</string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="230">
            <Properties>
              <string name="Name">Lamp</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezYyOEZGQjRGLTM0RjAtNDc0RS05MkNGLTZDRDc1QjI3MDcxN30=]]></BinaryString>
              <string name="Source">return {
	Id = 1,
	Name = "Lamp",

	Size = Vector2.new(1, 1),
}</string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="231">
            <Properties>
              <string name="Name">Table</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezJEQzQyNURFLTk5QzYtNEUxMy05QTJGLThBMjY3NjRGMjI1MH0=]]></BinaryString>
              <string name="Source">return {
	Id = 2,
	Name = "Table",

	Size = Vector2.new(1, 2),
}</string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="232">
            <Properties>
              <string name="Name">Tree</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezA5NzcwNUYyLTc3RUUtNDNEMi05RkFBLUU2QzUwOEU2Qjg4RH0=]]></BinaryString>
              <string name="Source">return {
	Id = 3,
	Name = "Tree",

	Size = Vector2.new(3, 3),
}</string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="233">
          <Properties>
            <string name="Name">DataDefaults</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0NFMUZGNTkxLUJDMkItNDc2NS04RDg2LTM3QkIyNDlDOUZEQ30=]]></BinaryString>
            <string name="Source"><![CDATA[return {
	Keybinds = {
		Keyboard = {
			["Hotbar1"] = "One",
			["Hotbar2"] = "Two",
			["Hotbar3"] = "Three",
			["Hotbar4"] = "Four",
			["Hotbar5"] = "Five",
			["Hotbar6"] = "Six",
			["Hotbar7"] = "Seven",
			["Hotbar8"] = "Eight",
			["Hotbar9"] = "Nine",

			["Rotate"] = "R",
			["Activate"] = "MouseButton1"
		},
		Gamepad = {},
		Touch = {},
	},
}
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="234">
          <Properties>
            <string name="Name">RoduxWatcher</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezgzOTY5N0ZFLTJENkYtNENDMi1CNUQ4LTI4MENDMzY4ODgwMn0=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Rodux = require(ReplicatedStorage.Game.Rodux)

return function(store: Rodux.Store)
	return function<T>(selector: (any) -> (T), onChange: (any) -> ()): () -> ()
		local value = selector(store:getState())

		local connection = store.changed:connect(function(newState, _oldState)
			local newValue = selector(newState)
			if newValue == value then
				return
			end
			value = newValue
			onChange(value)
		end)

		onChange(value)

		return connection.disconnect
	end
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="235">
        <Properties>
          <string name="Name">Rodux</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0RFMzIyNzhELTBDNUYtNEQ1NS05MkNELUYwQ0Q3OTcxNTFGNX0=]]></BinaryString>
          <string name="Source"><![CDATA[--!strict
local Store = require(script.Store)
local createReducer = require(script.createReducer)
local combineReducers = require(script.combineReducers)
local makeActionCreator = require(script.makeActionCreator)
local loggerMiddleware = require(script.loggerMiddleware)
local thunkMiddleware = require(script.thunkMiddleware)
local makeThunkMiddleware = require(script.makeThunkMiddleware)

local actions = require(script.types.actions)
local reducers = require(script.types.reducers)
local store = require(script.types.store)
local thunks = require(script.types.thunks)

export type Action<Type = any> = actions.Action<Type>
export type AnyAction = actions.AnyAction
export type ActionCreator<Type, Action, Args...> = actions.ActionCreator<Type, Action, Args...>

export type Reducer<State = any, Action = AnyAction> = reducers.Reducer<State, Action>

export type Store<State = any> = store.Store<State>

export type ThunkAction<ReturnType, State = any> = thunks.ThunkAction<ReturnType, State>
export type ThunkfulStore<State = any> = thunks.ThunkfulStore<State>

return {
	Store = Store,
	createReducer = createReducer,
	combineReducers = combineReducers,
	makeActionCreator = makeActionCreator,
	loggerMiddleware = loggerMiddleware.middleware,
	thunkMiddleware = thunkMiddleware,
	makeThunkMiddleware = makeThunkMiddleware,
}
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="236">
          <Properties>
            <string name="Name">NoYield</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0MyMjQ2QUQxLTE3RUUtNEEwOS1CNzExLUU2REFENTU2RDdDQ30=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co: thread, ok: boolean, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "Attempted to yield inside changed event!"), 2)
	end

	return ...
end

local function NoYield(callback, ...)
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return NoYield
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="237">
          <Properties>
            <string name="Name">NoYield.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0MxQUFGNjE4LTIyMEItNENDNi1CMTBFLTAxRUVCMEUzOThEOH0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	local NoYield = require(script.Parent.NoYield)

	it("should call functions normally", function()
		local callCount = 0

		local function test(a, b)
			expect(a).to.equal(5)
			expect(b).to.equal(6)

			callCount = callCount + 1

			return 11, "hello"
		end

		local a, b = NoYield(test, 5, 6)

		expect(a).to.equal(11)
		expect(b).to.equal("hello")
	end)

	it("should throw on yield", function()
		local preCount = 0
		local postCount = 0

		local function testMethod()
			preCount = preCount + 1
			wait()
			postCount = postCount + 1
		end

		local ok, err = pcall(NoYield, testMethod)

		expect(preCount).to.equal(1)
		expect(postCount).to.equal(0)

		expect(ok).to.equal(false)
		expect(err:find("Attempted to yield inside changed event!")).to.be.ok()
		expect(err:find("NoYield.spec")).to.be.ok()
	end)

	it("should propagate error messages", function()
		local count = 0

		local function test()
			count = count + 1
			error("foo")
		end

		local ok, err = pcall(NoYield, test)

		expect(ok).to.equal(false)
		expect(err:find("foo")).to.be.ok()
		expect(err:find("NoYield.spec")).to.be.ok()
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="238">
          <Properties>
            <string name="Name">Signal</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0UyMUM2RkMyLTI5NTUtNENDMC05MkQwLUQ0MTE0MUVCQjMxQn0=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
--[[
	A limited, simple implementation of a Signal.

	Handlers are fired in order, and (dis)connections are properly handled when
	executing an event.
]]
local function immutableAppend(list, ...)
	local new = {}
	local len = #list

	for key = 1, len do
		new[key] = list[key]
	end

	for i = 1, select("#", ...) do
		new[len + i] = select(i, ...)
	end

	return new
end

local function immutableRemoveValue(list, removeValue)
	local new = {}

	for i = 1, #list do
		if list[i] ~= removeValue then
			table.insert(new, list[i])
		end
	end

	return new
end

type Listener = {
	callback: (...any) -> (),
	disconnected: boolean,
	connectTraceback: string,
	disconnectTraceback: string?,
}

type Store = {
	_isDispatching: boolean,
}

local Signal = {}

Signal.__index = Signal

function Signal.new(store: Store?)
	local self = {
		_listeners = {},
		_store = store,
	}

	setmetatable(self, Signal)

	return self
end

function Signal:connect(callback)
	if typeof(callback) ~= "function" then
		error("Expected the listener to be a function.")
	end

	if self._store and self._store._isDispatching then
		error(
			"You may not call store.changed:connect() while the reducer is executing. "
				.. "If you would like to be notified after the store has been updated, subscribe from a "
				.. "component and invoke store:getState() in the callback to access the latest state. "
		)
	end

	local listener: Listener = {
		callback = callback,
		disconnected = false,
		connectTraceback = debug.traceback(),
		disconnectTraceback = nil,
	}

	self._listeners = immutableAppend(self._listeners, listener)

	local function disconnect()
		if listener.disconnected then
			error(
				("Listener connected at: \n%s\n" .. "was already disconnected at: \n%s\n"):format(
					tostring(listener.connectTraceback),
					tostring(listener.disconnectTraceback)
				)
			)
		end

		if self._store and self._store._isDispatching then
			error("You may not unsubscribe from a store listener while the reducer is executing.")
		end

		listener.disconnected = true
		listener.disconnectTraceback = debug.traceback()
		self._listeners = immutableRemoveValue(self._listeners, listener)
	end

	return {
		disconnect = disconnect,
	}
end

function Signal:fire(...)
	for _, listener in ipairs(self._listeners) do
		if not listener.disconnected then
			listener.callback(...)
		end
	end
end

return Signal
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="239">
          <Properties>
            <string name="Name">Signal.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezNBNURFREVCLTU2QjYtNDlGQy04QjZELTlDRUQ0NDk4Nzk4OX0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	local Signal = require(script.Parent.Signal)

	it("should construct from nothing", function()
		local signal = Signal.new()

		expect(signal).to.be.ok()
	end)

	it("should fire connected callbacks", function()
		local callCount = 0
		local value1 = "Hello World"
		local value2 = 7

		local callback = function(arg1, arg2)
			expect(arg1).to.equal(value1)
			expect(arg2).to.equal(value2)
			callCount = callCount + 1
		end

		local signal = Signal.new()

		local connection = signal:connect(callback)
		signal:fire(value1, value2)

		expect(callCount).to.equal(1)

		connection:disconnect()
		signal:fire(value1, value2)

		expect(callCount).to.equal(1)
	end)

	it("should disconnect handlers", function()
		local callback = function()
			error("Callback was called after disconnect!")
		end

		local signal = Signal.new()

		local connection = signal:connect(callback)
		connection:disconnect()

		signal:fire()
	end)

	it("should fire handlers in order", function()
		local signal = Signal.new()
		local x = 0
		local y = 0

		local callback1 = function()
			expect(x).to.equal(0)
			expect(y).to.equal(0)
			x = x + 1
		end

		local callback2 = function()
			expect(x).to.equal(1)
			expect(y).to.equal(0)
			y = y + 1
		end

		signal:connect(callback1)
		signal:connect(callback2)
		signal:fire()

		expect(x).to.equal(1)
		expect(y).to.equal(1)
	end)

	it("should continue firing despite mid-event disconnection", function()
		local signal = Signal.new()
		local countA = 0
		local countB = 0

		local connectionA
		connectionA = signal:connect(function()
			connectionA:disconnect()
			countA = countA + 1
		end)

		signal:connect(function()
			countB = countB + 1
		end)

		signal:fire()

		expect(countA).to.equal(1)
		expect(countB).to.equal(1)
	end)

	it("should skip listeners that were disconnected during event evaluation", function()
		local signal = Signal.new()
		local countA = 0
		local countB = 0

		local connectionB

		signal:connect(function()
			countA = countA + 1
			connectionB:disconnect()
		end)

		connectionB = signal:connect(function()
			countB = countB + 1
		end)

		signal:fire()

		expect(countA).to.equal(1)
		expect(countB).to.equal(0)
	end)

	it("should throw an error if the argument to `connect` is not a function", function()
		local signal = Signal.new()
		expect(function()
			signal:connect("not a function" :: any)
		end).to.throw()
	end)

	it("should throw an error when disconnecting more than once", function()
		local signal = Signal.new()

		local connection = signal:connect(function() end)
		-- Okay to disconnect once
		expect(connection.disconnect).never.to.throw()

		-- Throw an error if we disconnect twice
		expect(connection.disconnect).to.throw()
	end)

	it("should throw an error when subscribing during dispatch", function()
		local mockStore = {
			_isDispatching = false,
		}
		local signal = Signal.new(mockStore)

		signal:connect(function()
			-- Subscribe while listeners are being fired
			signal:connect(function() end)
		end)

		mockStore._isDispatching = true
		expect(function()
			signal:fire()
		end).to.throw()
	end)

	it("should throw an error when unsubscribing during dispatch", function()
		local mockStore = {
			_isDispatching = false,
		}
		local signal = Signal.new(mockStore)

		local connection
		connection = signal:connect(function()
			connection.disconnect()
		end)

		mockStore._isDispatching = true
		expect(function()
			signal:fire()
		end).to.throw()
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="240">
          <Properties>
            <string name="Name">Store</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezAyODYwQjkzLTVEOUUtNDg2MS1COUE1LTE0REVDQkE1MkZDOX0=]]></BinaryString>
            <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)
local NoYield = require(script.Parent.NoYield)

local ACTION_LOG_LENGTH = 3

local rethrowErrorReporter = {
	reportReducerError = function(prevState, action, errorResult)
		error(string.format("Received error: %s\n\n%s", errorResult.message, errorResult.thrownValue))
	end,
	reportUpdateError = function(prevState, currentState, lastActions, errorResult)
		error(string.format("Received error: %s\n\n%s", errorResult.message, errorResult.thrownValue))
	end,
}

local function tracebackReporter(message)
	return debug.traceback(tostring(message))
end

local Store = {}

-- This value is exposed as a private value so that the test code can stay in
-- sync with what event we listen to for dispatching the Changed event.
-- It may not be Heartbeat in the future.
Store._flushEvent = RunService.Heartbeat

Store.__index = Store

--[[
	Create a new Store whose state is transformed by the given reducer function.

	Each time an action is dispatched to the store, the new state of the store
	is given by:

		state = reducer(state, action)

	Reducers do not mutate the state object, so the original state is still
	valid.
]]
function Store.new(reducer, initialState, middlewares, errorReporter)
	assert(typeof(reducer) == "function", "Bad argument #1 to Store.new, expected function.")
	assert(middlewares == nil or typeof(middlewares) == "table", "Bad argument #3 to Store.new, expected nil or table.")
	if middlewares ~= nil then
		for i = 1, #middlewares, 1 do
			assert(
				typeof(middlewares[i]) == "function",
				("Expected the middleware ('%s') at index %d to be a function."):format(tostring(middlewares[i]), i)
			)
		end
	end

	local self = {}

	self._errorReporter = errorReporter or rethrowErrorReporter
	self._isDispatching = false
	self._reducer = reducer
	local initAction = {
		type = "@@INIT",
	}
	self._actionLog = { initAction }
	local ok, result = xpcall(function()
		self._state = reducer(initialState, initAction)
	end, tracebackReporter)
	if not ok then
		self._errorReporter.reportReducerError(initialState, initAction, {
			message = "Caught error in reducer with init",
			thrownValue = result,
		})
		self._state = initialState
	end
	self._lastState = self._state

	self._mutatedSinceFlush = false
	self._connections = {}

	self.changed = Signal.new(self)

	setmetatable(self, Store)

	local connection = self._flushEvent:Connect(function()
		self:flush()
	end)
	table.insert(self._connections, connection)

	if middlewares then
		local unboundDispatch = self.dispatch
		local dispatch = function(...)
			return unboundDispatch(self, ...)
		end

		for i = #middlewares, 1, -1 do
			local middleware = middlewares[i]
			dispatch = middleware(dispatch, self)
		end

		self.dispatch = function(_self, ...)
			return dispatch(...)
		end
	end

	return self
end

--[[
	Get the current state of the Store. Do not mutate this!
]]
function Store:getState()
	if self._isDispatching then
		error(
			(
				"You may not call store:getState() while the reducer is executing. "
				.. "The reducer (%s) has already received the state as an argument. "
				.. "Pass it down from the top reducer instead of reading it from the store."
			):format(tostring(self._reducer))
		)
	end

	return self._state
end

--[[
	Dispatch an action to the store. This allows the store's reducer to mutate
	the state of the application by creating a new copy of the state.

	Listeners on the changed event of the store are notified when the state
	changes, but not necessarily on every Dispatch.
]]
function Store:dispatch(action)
	if typeof(action) ~= "table" then
		error(("Actions must be tables. " .. "Use custom middleware for %q actions."):format(typeof(action)), 2)
	end

	if action.type == nil then
		error(
			"Actions may not have an undefined 'type' property. "
				.. "Have you misspelled a constant? \n"
				.. tostring(action),
			2
		)
	end

	if self._isDispatching then
		error("Reducers may not dispatch actions.")
	end

	local ok, result = pcall(function()
		self._isDispatching = true
		self._state = self._reducer(self._state, action)
		self._mutatedSinceFlush = true
	end)

	self._isDispatching = false

	if not ok then
		self._errorReporter.reportReducerError(self._state, action, {
			message = "Caught error in reducer",
			thrownValue = result,
		})
	end

	if #self._actionLog == ACTION_LOG_LENGTH then
		table.remove(self._actionLog, 1)
	end
	table.insert(self._actionLog, action)
end

--[[
	Marks the store as deleted, disconnecting any outstanding connections.
]]
function Store:destruct()
	for _, connection in ipairs(self._connections) do
		connection:Disconnect()
	end

	self._connections = nil
end

--[[
	Flush all pending actions since the last change event was dispatched.
]]
function Store:flush()
	if not self._mutatedSinceFlush then
		return
	end

	self._mutatedSinceFlush = false

	-- On self.changed:fire(), further actions may be immediately dispatched, in
	-- which case self._lastState will be set to the most recent self._state,
	-- unless we cache this value first
	local state = self._state

	local ok, errorResult = xpcall(function()
		-- If a changed listener yields, *very* surprising bugs can ensue.
		-- Because of that, changed listeners cannot yield.
		NoYield(function()
			self.changed:fire(state, self._lastState)
		end)
	end, tracebackReporter)

	if not ok then
		self._errorReporter.reportUpdateError(self._lastState, state, self._actionLog, {
			message = "Caught error flushing store updates",
			thrownValue = errorResult,
		})
	end

	self._lastState = state
end

return Store
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="241">
          <Properties>
            <string name="Name">Store.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0Y0OUJBNTlDLTc5MTYtNDlFMS05RDcwLTgwRDg0MEU4RTg5MX0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)

	describe("new", function()
		it("should instantiate with a reducer", function()
			local store = Store.new(function(state, action)
				return "hello, world"
			end)

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("hello, world")

			store:destruct()
		end)

		it("should instantiate with a reducer and an initial state", function()
			local store = Store.new(function(state, action)
				return state
			end, "initial state")

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("initial state")

			store:destruct()
		end)

		it("should instantiate with a reducer, initial state, and middlewares", function()
			local store = Store.new(function(state, action)
				return state
			end, "initial state", {})

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("initial state")

			store:destruct()
		end)

		it("should modify the dispatch method when middlewares are passed", function()
			local middlewareInstantiateCount = 0
			local middlewareInvokeCount = 0
			local passedDispatch
			local passedStore
			local passedAction

			local function reducer(state, action)
				if action.type == "test" then
					return "test state"
				end

				return state
			end

			local function testMiddleware(nextDispatch, store)
				middlewareInstantiateCount = middlewareInstantiateCount + 1
				passedDispatch = nextDispatch
				passedStore = store

				return function(action)
					middlewareInvokeCount = middlewareInvokeCount + 1
					passedAction = action

					nextDispatch(action)
				end
			end

			local store = Store.new(reducer, "initial state", { testMiddleware })

			expect(middlewareInstantiateCount).to.equal(1)
			expect(middlewareInvokeCount).to.equal(0)
			expect(passedDispatch).to.be.a("function")
			expect(passedStore).to.equal(store)

			store:dispatch({
				type = "test",
			})

			expect(middlewareInstantiateCount).to.equal(1)
			expect(middlewareInvokeCount).to.equal(1)
			expect(passedAction.type).to.equal("test")

			store:flush()

			expect(store:getState()).to.equal("test state")

			store:destruct()
		end)

		it("should execute middleware left-to-right", function()
			local events = {}

			local function reducer(state)
				return state
			end

			local function middlewareA(nextDispatch, store)
				table.insert(events, "instantiate a")
				return function(action)
					table.insert(events, "execute a")
					return nextDispatch(action)
				end
			end

			local function middlewareB(nextDispatch, store)
				table.insert(events, "instantiate b")
				return function(action)
					table.insert(events, "execute b")
					return nextDispatch(action)
				end
			end

			local store = Store.new(reducer, 5, { middlewareA, middlewareB })

			expect(#events).to.equal(2)
			expect(events[1]).to.equal("instantiate b")
			expect(events[2]).to.equal("instantiate a")

			store:dispatch({
				type = "test",
			})

			expect(#events).to.equal(4)
			expect(events[3]).to.equal("execute a")
			expect(events[4]).to.equal("execute b")

			store:destruct()
		end)

		it("should send an initial action with a 'type' field", function()
			local lastAction
			local callCount = 0

			local store = Store.new(function(state, action)
				lastAction = action
				callCount = callCount + 1

				return state
			end)

			expect(callCount).to.equal(1)
			expect(lastAction).to.be.a("table")
			expect(lastAction.type).to.be.ok()

			store:destruct()
		end)

		it("should report a reducer error thrown when handling the INIT action", function()
			local caughtState, caughtAction, caughtErrorResult
			local mockErrorReporter = {
				reportReducerError = function(state, action, errorResult)
					caughtState = state
					caughtAction = action
					caughtErrorResult = errorResult
				end,
				reportUpdateError = function()
					-- no op
				end,
			}

			local innerErrorMessage = "Z4PH0D"
			local reducerThatErrors = function(state, action)
				error(innerErrorMessage)
			end

			local store
			store = Store.new(reducerThatErrors, {
				Value = 1,
			}, nil, mockErrorReporter)

			expect(caughtState.Value).to.equal(1)
			expect(caughtAction.type).to.equal("@@INIT")
			expect(caughtErrorResult.message).to.equal("Caught error in reducer with init")
			local found = string.find(caughtErrorResult.thrownValue, innerErrorMessage)
			expect(found).to.be.ok()
			-- We want to verify that this is a stacktrace without caring too
			-- much about the format, so we look for the stack frame associated
			-- with this test file
			found = string.find(caughtErrorResult.thrownValue, script.Name)
			expect(found).to.be.ok()

			store:destruct()
		end)

		it("should report a reducer error thrown when handling a subsequent action", function()
			local caughtState, caughtAction, caughtErrorResult
			local mockErrorReporter = {
				reportReducerError = function(state, action, errorResult)
					caughtState = state
					caughtAction = action
					caughtErrorResult = errorResult
				end,
				reportUpdateError = function()
					-- no op
				end,
			}

			local innerErrorMessage = "Z4PH0D"
			local reducerThatErrorsAfterInit = function(state, action)
				if action.type == "ThrowError" then
					error(innerErrorMessage)
				elseif action.type == "Increment" then
					return {
						Value = state.Value + 1,
					}
				end
				return state
			end

			local store
			store = Store.new(reducerThatErrorsAfterInit, {
				Value = 1,
			}, nil, mockErrorReporter)

			expect(caughtState).to.equal(nil)
			expect(caughtAction).to.equal(nil)
			expect(caughtErrorResult).to.equal(nil)

			store:dispatch({ type = "Increment" })
			store:dispatch({ type = "ThrowError" })

			expect(caughtState.Value).to.equal(2)
			expect(caughtAction.type).to.equal("ThrowError")
			expect(caughtErrorResult.message).to.equal("Caught error in reducer")
			local found = string.find(caughtErrorResult.thrownValue, innerErrorMessage)
			expect(found).to.be.ok()
			-- We want to verify that this is a stacktrace without caring too
			-- much about the format, so we look for the stack frame associated
			-- with this test file
			found = string.find(caughtErrorResult.thrownValue, script.Name)
			expect(found).to.be.ok()

			store:destruct()
		end)
	end)

	describe("getState", function()
		it("should get the current state", function()
			local store = Store.new(function(state, action)
				return "foo"
			end)

			local state = store:getState()

			expect(state).to.equal("foo")

			store:destruct()
		end)

		it("should throw errors if triggered during dispatches", function()
			local store
			store = Store.new(function(state, action)
				if action.type ~= "@@INIT" then
					store:getState()
				end
			end)

			expect(function()
				store:dispatch({ type = "SomeAction" })
			end).to.throw()

			store:destruct()
		end)
	end)

	describe("dispatch", function()
		it("should be sent through the reducer", function()
			local store = Store.new(function(state, action)
				state = state or "foo"

				if action.type == "act" then
					return "bar"
				end

				return state
			end)

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("foo")

			store:dispatch({
				type = "act",
			})

			store:flush()

			expect(store:getState()).to.equal("bar")

			store:destruct()
		end)

		it("should trigger the changed event after a flush", function()
			local store = Store.new(function(state, action)
				state = state or 0

				if action.type == "increment" then
					return state + 1
				end

				return state
			end)

			local callCount = 0

			store.changed:connect(function(state, oldState)
				expect(oldState).to.equal(0)
				expect(state).to.equal(1)

				callCount = callCount + 1
			end)

			store:dispatch({
				type = "increment",
			})

			store:flush()

			expect(callCount).to.equal(1)

			store:destruct()
		end)

		it("should handle actions dispatched within the changed event", function()
			local store = Store.new(function(state, action)
				state = state or {
					value = 0,
				}

				if action.type == "increment" then
					return {
						value = state.value + 1,
					}
				elseif action.type == "decrement" then
					return {
						value = state.value - 1,
					}
				end

				return state
			end)

			local changeCount = 0

			store.changed:connect(function(state, oldState)
				expect(state).never.to.equal(oldState)

				if state.value > 0 then
					store:dispatch({
						type = "decrement",
					})
				end

				changeCount = changeCount + 1
			end)

			store:dispatch({
				type = "increment",
			})
			store:flush()
			store:flush()

			expect(changeCount).to.equal(2)

			store:destruct()
		end)

		it("should prevent yielding from changed handler", function()
			local reportedErrorMessage, reportedErrorError
			local mockErrorReporter = {
				reportUpdateError = function(_, _, _, errorResult)
					reportedErrorMessage = errorResult.message
					reportedErrorError = errorResult.thrownValue
				end,
				reportReducerError = function()
					-- noop
				end,
			}
			local preCount = 0
			local postCount = 0

			local store = Store.new(function(state, action)
				state = state or 0
				return state + 1
			end, nil, nil, mockErrorReporter)

			store.changed:connect(function(state, oldState)
				preCount = preCount + 1
				wait()
				postCount = postCount + 1
			end)

			store:dispatch({
				type = "increment",
			})

			store:flush()

			expect(preCount).to.equal(1)
			expect(postCount).to.equal(0)

			expect(reportedErrorMessage).to.equal("Caught error flushing store updates")
			-- We want to verify that this is a stacktrace without caring too
			-- much about the format, so we look for the stack frame associated
			-- with this test file
			local found = string.find(reportedErrorError, script.Name)
			expect(found).to.be.ok()
			-- In vanilla lua, we get this message:
			--   "attempt to yield across metamethod/C-call boundary"
			-- In luau, we should end up wrapping our own NoYield message:
			--   "Attempted to yield inside changed event!"
			-- For convenience's sake, we just look for the common substring
			local caughtErrorSubstring = "to yield"
			found = string.find(reportedErrorError, caughtErrorSubstring)
			expect(found).to.be.ok()

			store:destruct()
		end)

		it("should throw if an action is dispatched without a type field", function()
			local store = Store.new(function(state, action)
				return state
			end)

			expect(function()
				store:dispatch({})
			end).to.throw()

			store:destruct()
		end)

		it("should throw if the action is not a function or table", function()
			local store = Store.new(function(state, action)
				return state
			end)

			expect(function()
				store:dispatch(1)
			end).to.throw()

			store:destruct()
		end)

		it("should report an error if the listeners error when flushing", function()
			local caughtPrevState, caughtState, caughtActionLog, caughtErrorResult
			local mockErrorReporter = {
				reportReducerError = function()
					-- no op
				end,
				reportUpdateError = function(prevState, state, actionLog, errorResult)
					caughtPrevState = prevState
					caughtState = state
					caughtActionLog = actionLog
					caughtErrorResult = errorResult
				end,
			}

			local reducer = function(state, action)
				if action.type == "Increment" then
					return {
						Value = state.Value + action.amount,
					}
				end
				return state
			end
			local store = Store.new(reducer, {
				Value = 1,
			}, nil, mockErrorReporter)

			local innerErrorMessage = "Z4PH0D"
			store.changed:connect(function(state, prevState)
				if state.Value == 15 then
					error(innerErrorMessage)
				end
			end)

			local actions = {
				{ type = "Increment", amount = 1 },
				{ type = "Increment", amount = 3 },
				{ type = "Increment", amount = 10 },
			}
			for _, action in ipairs(actions) do
				store:dispatch(action)
			end
			store:flush()

			expect(caughtErrorResult.message).to.equal("Caught error flushing store updates")
			-- We want to verify that this is a stacktrace without caring too
			-- much about the format, so we look for the stack frame associated
			-- with this test file
			local found = string.find(caughtErrorResult.thrownValue, script.Name)
			expect(found).to.be.ok()

			expect(caughtActionLog[1]).to.equal(actions[1])
			expect(caughtActionLog[2]).to.equal(actions[2])
			expect(caughtActionLog[3]).to.equal(actions[3])

			-- This is before any of the actions were processed; the flush will
			-- apply the new state from all three actions
			expect(caughtPrevState.Value).to.equal(1)
			expect(caughtState.Value).to.equal(15)

			store:destruct()
		end)

		it("should throw errors if dispatching while a dispatch is already happening", function()
			local store
			store = Store.new(function(state, action)
				if action.type == "SomeAction" then
					store:dispatch({ type = "MidDispatchAction" })
				end
			end)

			expect(function()
				store:dispatch({ type = "SomeAction" })
			end).to.throw()

			store:destruct()
		end)
	end)

	describe("flush", function()
		it("should not fire a changed event if there were no dispatches", function()
			local store = Store.new(function() end)

			local count = 0
			store.changed:connect(function()
				count = count + 1
			end)

			store:flush()

			expect(count).to.equal(0)

			store:dispatch({
				type = "increment",
			})
			store:flush()

			expect(count).to.equal(1)

			store:flush()

			expect(count).to.equal(1)

			store:destruct()
		end)
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="242">
          <Properties>
            <string name="Name">combineReducers</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0I5RDAyRkQyLTE1OEYtNERENi04RDUxLTg1MTIyQzRFQjc1Nn0=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
--[[
	Create a composite reducer from a map of keys and sub-reducers.
]]

local actions = require(script.Parent.types.actions)
local reducers = require(script.Parent.types.reducers)
local store = require(script.Parent.types.store)

type AnyAction = actions.AnyAction

export type Reducer<State = any, Action = AnyAction> = reducers.Reducer<State, Action>
export type ReducersMapObject<State = any, Action = AnyAction> = reducers.ReducersMapObject<State, Action>

type CombinedState<State> = store.CombinedState<State>

local function combineReducers<State>(map: ReducersMapObject): Reducer<CombinedState<State>>
	-- FIXME LUAU: Remove any cast here once we can constrain the generic type State to a table type
	return function(state, action)
		-- If state is nil, substitute it with a blank table.
		if state == nil then
			state = {}
		end

		local newState = {}

		for key, reducer in pairs(map) do
			-- Each reducer gets its own state, not the entire state table
			newState[key] = reducer(state[key], action)
		end

		return newState
	end :: any
end

return combineReducers
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="243">
          <Properties>
            <string name="Name">combineReducers.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezI0QzM1MTQzLTQ5ODUtNEZDNC05MjBGLUY4QjQwRjVBODJFNX0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	local combineReducers = require(script.Parent.combineReducers)

	it("should invoke each sub-reducer for every action", function()
		local aCount = 0
		local bCount = 0

		local reducer = combineReducers({
			a = function(state, action)
				aCount = aCount + 1
			end,
			b = function(state, action)
				bCount = bCount + 1
			end,
		})

		-- Mock reducer invocation
		reducer({}, {})
		expect(aCount).to.equal(1)
		expect(bCount).to.equal(1)
	end)

	it("should assign each sub-reducer's value to the new state", function()
		local reducer = combineReducers({
			a = function(state, action)
				return (state or 0) + 1
			end,
			b = function(state, action)
				return (state or 0) + 3
			end,
		})

		local newState = reducer({}, {})
		expect(newState.a).to.equal(1)
		expect(newState.b).to.equal(3)
	end)

	it("should not throw when state is nil", function()
		local reducer = combineReducers({
			a = function(state, action)
				return (state or 0) + 1
			end,
			b = function(state, action)
				return (state or 0) + 3
			end,
		})

		expect(function()
			reducer(nil, {})
		end).to.never.throw()
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="244">
          <Properties>
            <string name="Name">createReducer</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0ZDQzNGNkUyLTk5NDYtNDFFMi1BNzk2LTVFQUY0QzQwQUI4Qn0=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
local actions = require(script.Parent.types.actions)
local reducers = require(script.Parent.types.reducers)

type AnyAction = actions.AnyAction

export type Reducer<State = any, Action = AnyAction> = reducers.Reducer<State, Action>

return function<State>(initialState, handlers): Reducer<State>
	-- FIXME LUAU: Prefer any cast to avoid assert runtime overhead until typechecker can narrow type of _state_ to be non-nil
	return function(state: any, action)
		if state == nil then
			state = initialState
		end

		local handler = handlers[action.type]

		if handler then
			return handler(state, action)
		end

		return state
	end
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="245">
          <Properties>
            <string name="Name">createReducer.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezQ5REI4QkQ3LUZBNzUtNENFOS1CNTNFLTdDMTExOTgyRDg4OH0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	local createReducer = require(script.Parent.createReducer)

	it("should handle actions", function()
		local reducer = createReducer({
			a = 0,
			b = 0,
		}, {
			a = function(state, action)
				return {
					a = state.a + 1,
					b = state.b,
				}
			end,
			b = function(state, action)
				return {
					a = state.a,
					b = state.b + 2,
				}
			end,
		})

		local newState = reducer({
			a = 0,
			b = 0,
		}, {
			type = "a",
		})

		expect(newState.a).to.equal(1)

		newState = reducer(newState, {
			type = "b",
		})

		expect(newState.b).to.equal(2)
	end)

	it("should return the initial state if the state is nil", function()
		local reducer = createReducer({
			a = 0,
			b = 0,
			-- We don't care about the actions here
		}, {})

		local newState = reducer(nil, {})
		expect(newState).to.be.ok()
		expect(newState.a).to.equal(0)
		expect(newState.b).to.equal(0)
	end)

	it("should still run action handlers if the state is nil", function()
		local callCount = 0

		local reducer = createReducer(0, {
			foo = function(state, action)
				callCount = callCount + 1
				return nil
			end,
		})

		expect(callCount).to.equal(0)

		local newState = reducer(nil, {
			type = "foo",
		})

		expect(callCount).to.equal(1)
		expect(newState).to.equal(nil)

		newState = reducer(newState, {
			type = "foo",
		})

		expect(callCount).to.equal(2)
		expect(newState).to.equal(nil)
	end)

	it("should return the same state if the action is not handled", function()
		local initialState = {
			a = 0,
			b = 0,
		}

		local reducer = createReducer(initialState, {
			a = function(state, action)
				return {
					a = state.a + 1,
					b = state.b,
				}
			end,
			b = function(state, action)
				return {
					a = state.a,
					b = state.b + 2,
				}
			end,
		})

		local newState = reducer(initialState, {
			type = "c",
		})

		expect(newState).to.equal(initialState)
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="246">
          <Properties>
            <string name="Name">init.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0EwN0U1QTI2LUI4NTItNDJDRi05RjgwLUYxMEZGNjNCM0JCQn0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	describe("Rodux", function()
		it("should load", function()
			local Rodux = require(script.Parent)

			expect(Rodux.Store).to.be.ok()
		end)
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="247">
          <Properties>
            <string name="Name">loggerMiddleware</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0E0RTE0RjU1LUI0MkQtNDE3NC05NzQ5LUNCQ0Y3RDFBOEU1Nn0=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
-- We want to be able to override outputFunction in tests, so the shape of this
-- module is kind of unconventional.
--
-- We fix it this weird shape in init.lua.
type OutputFunction = (...any) -> ()

local prettyPrint = require(script.Parent.prettyPrint)
local loggerMiddleware = {
	outputFunction = (print :: any) :: OutputFunction,
}

function loggerMiddleware.middleware(nextDispatch, store)
	return function(action)
		local result = nextDispatch(action)

		loggerMiddleware.outputFunction(
			("Action dispatched: %s\nState changed to: %s"):format(prettyPrint(action), prettyPrint(store:getState()))
		)

		return result
	end
end

return loggerMiddleware
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="248">
          <Properties>
            <string name="Name">loggerMiddleware.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezFCRTg3Njc2LURCQUQtNEMzRi05OUI3LUQzQTE5MkM0M0JDRX0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)
	local loggerMiddleware = require(script.Parent.loggerMiddleware)

	it("should print whenever an action is dispatched", function()
		local outputCount = 0
		local outputMessage

		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {
			fooValue = 12345,
			barValue = {
				bazValue = "hiBaz",
			},
		}, {
			loggerMiddleware.middleware,
		})

		loggerMiddleware.outputFunction = function(message)
			outputCount = outputCount + 1
			outputMessage = message
		end

		store:dispatch({
			type = "testActionType",
		})

		expect(outputCount).to.equal(1)
		expect(outputMessage:find("testActionType")).to.be.ok()
		expect(outputMessage:find("fooValue")).to.be.ok()
		expect(outputMessage:find("12345")).to.be.ok()
		expect(outputMessage:find("barValue")).to.be.ok()
		expect(outputMessage:find("bazValue")).to.be.ok()
		expect(outputMessage:find("hiBaz")).to.be.ok()

		loggerMiddleware.outputFunction = print
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="249">
          <Properties>
            <string name="Name">makeActionCreator</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezI3QUQxQzMzLTQwQUEtNEVGMi05MjBDLUU3MkI4NEIyMTQxM30=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
--[[
	A helper function to define a Rodux action creator with an associated name.
]]

local actions = require(script.Parent.types.actions)

export type ActionCreator<Type, Action, Args...> = actions.ActionCreator<Type, Action, Args...>

local function makeActionCreator<Type, Action, Args...>(
	name: Type,
	fn: (Args...) -> Action
): ActionCreator<Type, Action, Args...>
	assert(type(name) == "string", "Bad argument #1: Expected a string name for the action creator")

	assert(type(fn) == "function", "Bad argument #2: Expected a function that creates action objects")

	return setmetatable({
		name = name,
	}, {
		__call = function(_self: any, ...: Args...): Action & { type: Type }
			local result = fn(...)

			assert(type(result) == "table", "Invalid action: An action creator must return a table")

			result.type = name

			return result
		end,
	})
end

return makeActionCreator
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="250">
          <Properties>
            <string name="Name">makeActionCreator.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezEyQzVDNUZBLTM4MUUtNEFFNS04MzczLTQwOTZBQjg0NUJDNX0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	local makeActionCreator = require(script.Parent.makeActionCreator)

	it("should set the name of the actionCreator creator", function()
		local FooAction = makeActionCreator("foo", function()
			return {}
		end)

		expect(FooAction.name).to.equal("foo")
	end)

	it("should return a table when called as a function", function()
		local FooAction = makeActionCreator("foo", function()
			return {}
		end)

		expect(FooAction()).to.be.a("table")
	end)

	it("should set the type of the action creator", function()
		local FooAction = makeActionCreator("foo", function()
			return {}
		end)

		expect(FooAction().type).to.equal("foo")
	end)

	it("should set values", function()
		local FooAction = makeActionCreator("foo", function(value)
			return {
				value = value,
			}
		end)

		expect(FooAction(100).value).to.equal(100)
	end)

	it("should throw when its result does not return a table", function()
		local FooAction = makeActionCreator("foo", function()
			return function() end
		end)

		expect(FooAction).to.throw()
	end)

	it("should throw if the first argument is not a string", function()
		expect(function()
			makeActionCreator(nil, function()
				return {}
			end)
		end).to.throw()

		expect(function()
			makeActionCreator(100, function()
				return {}
			end)
		end).to.throw()
	end)

	it("should throw if the second argument is not a function", function()
		expect(function()
			makeActionCreator("foo", nil :: any)
		end).to.throw()

		expect(function()
			makeActionCreator("foo", {} :: any)
		end).to.throw()
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="251">
          <Properties>
            <string name="Name">makeThunkMiddleware</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezRFOUQ1OUMyLUY0NzItNDY5Qi1CNkFBLUI4OUJERTJEQ0Q2Qn0=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
--[[
	A middleware that allows for functions to be dispatched with an extra
	argument for convenience. Functions will receive two arguments:
	the store itself and the extra argument provided initially to makeThunkMiddleware.

	This middleware consumes the function; middleware further down the chain
	will not receive it.
]]
local function tracebackReporter(message)
	return debug.traceback(message)
end

local function makeThunkMiddleware(extraArgument)
	local function thunkMiddleware(nextDispatch, store)
		return function(action)
			if typeof(action) == "function" then
				local ok, result = xpcall(function()
					return action(store, extraArgument)
				end, tracebackReporter)

				if not ok then
					-- report the error and move on so it's non-fatal app
					store._errorReporter.reportReducerError(store:getState(), action, {
						message = "Caught error in thunk",
						thrownValue = result,
					})
					return nil
				end

				return result
			end

			return nextDispatch(action)
		end
	end

	return thunkMiddleware
end

return makeThunkMiddleware
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="252">
          <Properties>
            <string name="Name">prettyPrint</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezgxQTlFMjNBLTlFREYtNEEzQi1CRDAzLTM2NTY1OEE3RkVBRn0=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
local indent = "    "

local function prettyPrint(value, _indentLevel: number?)
	local indentLevel = _indentLevel or 0
	local output = {}

	if typeof(value) == "table" then
		table.insert(output, "{\n")

		for tableKey, tableValue in pairs(value) do
			table.insert(output, indent:rep(indentLevel + 1))
			table.insert(output, tostring(tableKey))
			table.insert(output, " = ")

			table.insert(output, prettyPrint(tableValue, indentLevel + 1))
			table.insert(output, "\n")
		end

		table.insert(output, indent:rep(indentLevel))
		table.insert(output, "}")
	elseif typeof(value) == "string" then
		table.insert(output, string.format("%q", value))
		table.insert(output, " (string)")
	else
		table.insert(output, tostring(value))
		table.insert(output, " (")
		table.insert(output, typeof(value))
		table.insert(output, ")")
	end

	return table.concat(output, "")
end

return prettyPrint
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="253">
          <Properties>
            <string name="Name">thunkMiddleware</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[ezkyQTY0RkQ5LTZFMTItNDFDNS04OUY1LUYxMkUyMTEyN0E2OH0=]]></BinaryString>
            <string name="Source"><![CDATA[--!strict
--[[
	A middleware that allows for functions to be dispatched.
	Functions will receive a single argument, the store itself.
	This middleware consumes the function; middleware further down the chain
	will not receive it.
]]
local makeThunkMiddleware = require(script.Parent.makeThunkMiddleware)

return makeThunkMiddleware(nil) -- no extra argument
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="254">
          <Properties>
            <string name="Name">thunkMiddleware.spec</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <Content name="LinkedSource">
              <null>
              </null>
            </Content>
            <BinaryString name="ScriptGuid"><![CDATA[e0U4M0QwRkJFLTg2QkEtNEQ1NC05QUVCLUEyM0FEMzdDN0RDRX0=]]></BinaryString>
            <string name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)
	local thunkMiddleware = require(script.Parent.thunkMiddleware)
	local makeThunkMiddleware = require(script.Parent.makeThunkMiddleware)

	it("should dispatch thunks", function()
		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })
		local thunkCount = 0

		local function thunk(_store)
			thunkCount = thunkCount + 1
		end

		store:dispatch(thunk)

		expect(thunkCount).to.equal(1)
	end)

	it("should allow normal actions to pass through", function()
		local reducerCount = 0

		local function reducer(state, action)
			reducerCount = reducerCount + 1
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })

		store:dispatch({
			type = "test",
		})

		-- Reducer will be invoked twice:
		-- Once when creating the store (@@INIT action)
		-- Once when the test action is dispatched
		expect(reducerCount).to.equal(2)
	end)

	it("should return the value from the thunk", function()
		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })
		local thunkValue = "test"

		local function thunk(_store)
			return thunkValue
		end

		local result = store:dispatch(thunk)

		expect(result).to.equal(thunkValue)
	end)

	it("should report errors captured in thunks via the provided error reporter", function()
		local caughtState, caughtAction, caughtErrorResult
		local errorReporter = {
			reportReducerError = function(state, action, errorResult)
				caughtState = state
				caughtAction = action
				caughtErrorResult = errorResult
			end,
		}

		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {
			Value = 1,
		}, { thunkMiddleware }, errorReporter)

		local innerErrorMessage = "thunk failed"
		local function thunk(_store)
			error(innerErrorMessage)
		end

		store:dispatch(thunk)

		expect(caughtState.Value).to.equal(1)
		expect(caughtAction).to.equal(thunk)
		expect(caughtErrorResult.message).to.equal("Caught error in thunk")
	end)

	it("should recover and continue to update after a thunk errors", function()
		local caughtErrorResult
		local errorReporter = {
			reportReducerError = function(_state, _action, errorResult)
				caughtErrorResult = errorResult
			end,
		}

		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {
			Value = 1,
		}, { thunkMiddleware }, errorReporter)

		local innerErrorMessage = "thunk failed"
		local function errorThunk(_store)
			error(innerErrorMessage)
		end
		local ranSafeThunk = false
		local function safeThunk(_store)
			ranSafeThunk = true
		end

		store:dispatch(errorThunk)
		expect(caughtErrorResult.message).to.equal("Caught error in thunk")

		store:dispatch(safeThunk)
		expect(ranSafeThunk).to.equal(true)
	end)

	it("should send extra argument to thunks when provided", function()
		local function reducer(state, action)
			return state
		end

		local myExtraArg = { What = "MyExtraArg" }
		local store = Store.new(reducer, {}, { makeThunkMiddleware(myExtraArg) })
		local thunkCount = 0
		local extraArgParam = nil

		local function thunk(_store, extraArg)
			thunkCount = thunkCount + 1
			extraArgParam = extraArg
		end

		store:dispatch(thunk)

		expect(thunkCount).to.equal(1)
		expect(extraArgParam).to.equal(myExtraArg)
	end)
end
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="Folder" referent="255">
          <Properties>
            <string name="Name">types</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="256">
            <Properties>
              <string name="Name">actions</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezlDNDU5RTE5LTZGN0EtNDkxNy04QTJGLTY3MUEwNjg1M0M2Q30=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict
export type Action<Type = any> = {
	type: Type,
}

export type AnyAction = Action & {
	[string]: any,
}

export type ActionCreator<Type, Action, Args...> = typeof(setmetatable(
	{} :: { name: Type },
	{} :: { __call: (any, Args...) -> (Action & { type: Type }) }
))

return nil
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="257">
            <Properties>
              <string name="Name">reducers</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezM2NTA2RkFFLUI5NjEtNDYwRC1CMDAzLUFFQUY1RjMzOEI4QX0=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict
local actions = require(script.Parent.actions)

type AnyAction = actions.AnyAction

export type Reducer<State = any, Action = AnyAction> = (State?, Action) -> State

export type ReducersMapObject<State = any, Action = AnyAction> = {
	-- TODO Luau: used to be [K in keyof S]: K[S]
	[string]: Reducer<State, Action>,
}

return nil
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="258">
            <Properties>
              <string name="Name">store</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezhBMzBDNkJFLUMyMUEtNEQ0Qi04MDZCLUI0NzFFNUM3OTQxOX0=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict
local actions = require(script.Parent.actions)

type BaseAction = actions.Action<string>

type EmptyObject = {}

export type CombinedState<State> = EmptyObject & State

export type IDispatch<Store> = <Action>(self: Store, action: Action & BaseAction) -> ()
export type Dispatch<State = any> = IDispatch<Store<State>>

export type IStore<State, Dispatch> = {
	dispatch: Dispatch,
	getState: (self: IStore<State, Dispatch>) -> State,
	destruct: (self: IStore<State, Dispatch>) -> (),
	flush: (self: IStore<State, Dispatch>) -> (),
	changed: RBXScriptSignal,
}
export type Store<State = any> = IStore<State, Dispatch<State>>

return nil
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="259">
            <Properties>
              <string name="Name">thunks</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezlDQzAzN0Y3LTkyMEEtNDQ2My1BNjA2LTE0NjE1MjQ3OTdBNn0=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict
local store = require(script.Parent.store)

type IStore<State, Dispatch> = store.IStore<State, Dispatch>
type IDispatch<Store> = store.IDispatch<Store>

export type IThunkAction<ReturnType, Store> = (store: Store) -> ReturnType
export type ThunkAction<ReturnType, State = any> = IThunkAction<ReturnType, ThunkfulStore<State>>

export type IThunkDispatch<Store> = <ReturnType>(
	self: Store,
	thunkAction: IThunkAction<ReturnType, Store>
) -> ReturnType
export type ThunkDispatch<State = any> = IDispatch<ThunkfulStore<State>> & IThunkDispatch<ThunkfulStore<State>>

export type ThunkfulStore<State = any> = IStore<State, ThunkDispatch<State>>

return nil
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="260">
      <Properties>
        <string name="Name">Assets</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="Model" referent="261">
        <Properties>
          <string name="Name">Lamp</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <token name="LevelOfDetail">0</token>
          <CoordinateFrame name="ModelMeshCFrame">
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
            <R00>1</R00>
            <R01>0</R01>
            <R02>0</R02>
            <R10>0</R10>
            <R11>1</R11>
            <R12>0</R12>
            <R20>0</R20>
            <R21>0</R21>
            <R22>1</R22>
          </CoordinateFrame>
          <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
          <Vector3 name="ModelMeshSize">
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
          </Vector3>
          <bool name="NeedsPivotMigration">false</bool>
          <Ref name="PrimaryPart">262</Ref>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
          <OptionalCoordinateFrame name="WorldPivotData">
          </OptionalCoordinateFrame>
        </Properties>
        <Item class="Part" referent="263">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>0.20000148</Y>
              <Z>2</Z>
              <R00>0.99999976</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>0.99999976</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">1780277</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">256</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>1.4</X>
              <Y>0.4</Y>
              <Z>1.4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="264">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>3.1999986</Y>
              <Z>2.0000005</Z>
              <R00>0.99999976</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>0.99999976</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10724005</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">256</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>0.2</X>
              <Y>5.599999</Y>
              <Z>0.2</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="265">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>7</Y>
              <Z>2</Z>
              <R00>0.99999976</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>0.99999976</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">16640653</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">256</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>2</X>
              <Y>2</Y>
              <Z>2</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="262">
          <Properties>
            <string name="Name">RootPart</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>4.0000005</Y>
              <Z>2</Z>
              <R00>0.99999976</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>0.99999976</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">false</bool>
            <bool name="CanQuery">false</bool>
            <bool name="CanTouch">false</bool>
            <bool name="CastShadow">false</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10724005</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">true</bool>
            <token name="Material">256</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>-3.999998</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>7.999996</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">1</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
      </Item>
      <Item class="Model" referent="266">
        <Properties>
          <string name="Name">Table</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <token name="LevelOfDetail">0</token>
          <CoordinateFrame name="ModelMeshCFrame">
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
            <R00>1</R00>
            <R01>0</R01>
            <R02>0</R02>
            <R10>0</R10>
            <R11>1</R11>
            <R12>0</R12>
            <R20>0</R20>
            <R21>0</R21>
            <R22>1</R22>
          </CoordinateFrame>
          <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
          <Vector3 name="ModelMeshSize">
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
          </Vector3>
          <bool name="NeedsPivotMigration">false</bool>
          <Ref name="PrimaryPart">267</Ref>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
          <OptionalCoordinateFrame name="WorldPivotData">
          </OptionalCoordinateFrame>
        </Properties>
        <Item class="Part" referent="268">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>20.500002</X>
              <Y>0.8000011</Y>
              <Z>-11.499994</Z>
              <R00>0.99999905</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>0.99999905</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">6897704</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>0.4</X>
              <Y>1.6</Y>
              <Z>0.4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="269">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>0.60000014</Y>
              <Z>-7.999996</Z>
              <R00>0.99999905</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>0.99999905</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">6897704</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>3.4</X>
              <Y>0.4</Y>
              <Z>6.6</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="270">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>1.8000002</Y>
              <Z>-7.999996</Z>
              <R00>0.99999905</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>0.99999905</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">6897704</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>0.4</Y>
              <Z>8</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="271">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>23.499998</X>
              <Y>0.80000204</Y>
              <Z>-11.499994</Z>
              <R00>0.99999905</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>0.99999905</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">6897704</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>0.4</X>
              <Y>1.6</Y>
              <Z>0.4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="272">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>20.500004</X>
              <Y>0.80000025</Y>
              <Z>-4.5</Z>
              <R00>0.99999905</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>0.99999905</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">6897704</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>0.4</X>
              <Y>1.6</Y>
              <Z>0.4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="273">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>23.5</X>
              <Y>0.8000011</Y>
              <Z>-4.5</Z>
              <R00>0.99999905</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>0.99999905</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">6897704</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>0.4</X>
              <Y>1.6</Y>
              <Z>0.4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="267">
          <Properties>
            <string name="Name">RootPart</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>2.0000002</Y>
              <Z>-7.999996</Z>
              <R00>0.99999905</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>0.99999905</R22>
            </CoordinateFrame>
            <bool name="CanCollide">false</bool>
            <bool name="CanQuery">false</bool>
            <bool name="CanTouch">false</bool>
            <bool name="CastShadow">false</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10724005</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">true</bool>
            <token name="Material">256</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>-2</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>3.9999924</X>
              <Y>4</Y>
              <Z>7.9999847</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">1</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
      </Item>
      <Item class="Model" referent="274">
        <Properties>
          <string name="Name">Tree</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <token name="LevelOfDetail">0</token>
          <CoordinateFrame name="ModelMeshCFrame">
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
            <R00>1</R00>
            <R01>0</R01>
            <R02>0</R02>
            <R10>0</R10>
            <R11>1</R11>
            <R12>0</R12>
            <R20>0</R20>
            <R21>0</R21>
            <R22>1</R22>
          </CoordinateFrame>
          <SharedString name="ModelMeshData">rxNJufX5oaagQE3qNtzJSQ==</SharedString>
          <Vector3 name="ModelMeshSize">
            <X>0</X>
            <Y>0</Y>
            <Z>0</Z>
          </Vector3>
          <bool name="NeedsPivotMigration">false</bool>
          <Ref name="PrimaryPart">275</Ref>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
          <OptionalCoordinateFrame name="WorldPivotData">
          </OptionalCoordinateFrame>
        </Properties>
        <Item class="Part" referent="276">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>25.999996</X>
              <Y>7.9999814</Y>
              <Z>12</Z>
              <R00>1</R00>
              <R01>-0.0000013686804</R01>
              <R02>-0.0000000001134306</R02>
              <R10>0.0000013686804</R10>
              <R11>1</R11>
              <R12>0.0000052263713</R12>
              <R20>0.00000000010627736</R20>
              <R21>-0.0000052263713</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">16108848</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="277">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>26</X>
              <Y>12</Y>
              <Z>12</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">14850880</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="278">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>25</X>
              <Y>5</Y>
              <Z>14.000001</Z>
              <R00>-1</R00>
              <R01>0.000000000000000006938894</R01>
              <R02>-0.0000000000000005928304</R02>
              <R10>-0.0000000000000005928304</R10>
              <R11>0</R11>
              <R12>-1</R12>
              <R20>0.000000000000000006938894</R20>
              <R21>-1</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10510133</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">2</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">2</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>2</X>
              <Y>2</Y>
              <Z>2</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="279">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>12</Y>
              <Z>10</Z>
              <R00>0</R00>
              <R01>0</R01>
              <R02>1</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>-1</R20>
              <R21>0</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">16108848</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="280">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>11</Y>
              <Z>14</Z>
              <R00>-1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>-1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">16108848</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>10</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="281">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>5</Y>
              <Z>17</Z>
              <R00>0.000000000000000006938894</R00>
              <R01>1</R01>
              <R02>-0.0000000000000005928304</R02>
              <R10>0</R10>
              <R11>0.0000000000000005928304</R11>
              <R12>-1</R12>
              <R20>-1</R20>
              <R21>-0.000000000000000006938894</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10510133</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">2</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">2</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>2</X>
              <Y>2</Y>
              <Z>2</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="282">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>26</X>
              <Y>8</Y>
              <Z>16</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">14850880</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="283">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>3</Y>
              <Z>14.000001</Z>
              <R00>-1</R00>
              <R01>-0.000000000000000006938894</R01>
              <R02>0.0000000000000005928304</R02>
              <R10>-0.0000000000000005928304</R10>
              <R11>0</R11>
              <R12>1</R12>
              <R20>0.000000000000000006938894</R20>
              <R21>1</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10510133</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>6</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="284">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>8</Y>
              <Z>10</Z>
              <R00>0</R00>
              <R01>0</R01>
              <R02>1</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>-1</R20>
              <R21>0</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">14850880</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="285">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>5</Y>
              <Z>11.000001</Z>
              <R00>-0.000000000000000006938894</R00>
              <R01>-1</R01>
              <R02>-0.0000000000000005928304</R02>
              <R10>0</R10>
              <R11>-0.0000000000000005928304</R11>
              <R12>-1</R12>
              <R20>1</R20>
              <R21>0.000000000000000006938894</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10510133</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">2</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">2</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>2</X>
              <Y>2</Y>
              <Z>2</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="286">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>19</X>
              <Y>5</Y>
              <Z>14.000001</Z>
              <R00>1</R00>
              <R01>-0.000000000000000006938894</R01>
              <R02>-0.0000000000000005928304</R02>
              <R10>0.0000000000000005928304</R10>
              <R11>0</R11>
              <R12>-1</R12>
              <R20>-0.000000000000000006938894</R20>
              <R21>1</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10510133</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">2</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">512</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">2</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>2</X>
              <Y>2</Y>
              <Z>2</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="287">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>18.000002</X>
              <Y>7.9999814</Y>
              <Z>16</Z>
              <R00>-1</R00>
              <R01>0.0000013686804</R01>
              <R02>0.0000000001134306</R02>
              <R10>0.0000013686804</R10>
              <R11>1</R11>
              <R12>0.0000052263713</R12>
              <R20>-0.00000000010627736</R20>
              <R21>0.0000052263713</R21>
              <R22>-1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">16108848</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="288">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>12</Y>
              <Z>18</Z>
              <R00>0</R00>
              <R01>0</R01>
              <R02>-1</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>1</R20>
              <R21>0</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">16108848</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="289">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>18</X>
              <Y>12</Y>
              <Z>16</Z>
              <R00>-1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>-1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">14850880</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="290">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>18</X>
              <Y>8</Y>
              <Z>12</Z>
              <R00>-1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>-1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">14850880</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="291">
          <Properties>
            <string name="Name">Part</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>8</Y>
              <Z>18</Z>
              <R00>0</R00>
              <R01>0</R01>
              <R02>-1</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>1</R20>
              <R21>0</R21>
              <R22>0</R22>
            </CoordinateFrame>
            <bool name="CanCollide">true</bool>
            <bool name="CanQuery">true</bool>
            <bool name="CanTouch">true</bool>
            <bool name="CastShadow">true</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">14850880</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">2</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">false</bool>
            <token name="Material">800</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>4</X>
              <Y>4</Y>
              <Z>4</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">0</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
        <Item class="Part" referent="275">
          <Properties>
            <string name="Name">RootPart</string>
            <bool name="Anchored">true</bool>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <float name="BackParamA">-0.5</float>
            <float name="BackParamB">0.5</float>
            <token name="BackSurface">0</token>
            <token name="BackSurfaceInput">0</token>
            <float name="BottomParamA">-0.5</float>
            <float name="BottomParamB">0.5</float>
            <token name="BottomSurface">0</token>
            <token name="BottomSurfaceInput">0</token>
            <CoordinateFrame name="CFrame">
              <X>22</X>
              <Y>8</Y>
              <Z>14</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <bool name="CanCollide">false</bool>
            <bool name="CanQuery">false</bool>
            <bool name="CanTouch">false</bool>
            <bool name="CastShadow">false</bool>
            <int name="CollisionGroupId">0</int>
            <Color3uint8 name="Color3uint8">10724005</Color3uint8>
            <PhysicalProperties name="CustomPhysicalProperties">
              <CustomPhysics>false</CustomPhysics>
            </PhysicalProperties>
            <token name="formFactorRaw">1</token>
            <float name="FrontParamA">-0.5</float>
            <float name="FrontParamB">0.5</float>
            <token name="FrontSurface">0</token>
            <token name="FrontSurfaceInput">0</token>
            <float name="LeftParamA">-0.5</float>
            <float name="LeftParamB">0.5</float>
            <token name="LeftSurface">0</token>
            <token name="LeftSurfaceInput">0</token>
            <bool name="Locked">false</bool>
            <bool name="Massless">true</bool>
            <token name="Material">256</token>
            <BinaryString name="MaterialVariantSerialized">
            </BinaryString>
            <CoordinateFrame name="PivotOffset">
              <X>0</X>
              <Y>-8</Y>
              <Z>0</Z>
              <R00>1</R00>
              <R01>0</R01>
              <R02>0</R02>
              <R10>0</R10>
              <R11>1</R11>
              <R12>0</R12>
              <R20>0</R20>
              <R21>0</R21>
              <R22>1</R22>
            </CoordinateFrame>
            <float name="Reflectance">0</float>
            <float name="RightParamA">-0.5</float>
            <float name="RightParamB">0.5</float>
            <token name="RightSurface">0</token>
            <token name="RightSurfaceInput">0</token>
            <int name="RootPriority">0</int>
            <Vector3 name="RotVelocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
            <token name="shape">1</token>
            <Vector3 name="size">
              <X>12.000001</X>
              <Y>16</Y>
              <Z>12</Z>
            </Vector3>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
            <float name="TopParamA">-0.5</float>
            <float name="TopParamB">0.5</float>
            <token name="TopSurface">0</token>
            <token name="TopSurfaceInput">0</token>
            <float name="Transparency">1</float>
            <Vector3 name="Velocity">
              <X>0</X>
              <Y>0</Y>
              <Z>0</Z>
            </Vector3>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="292">
      <Properties>
        <string name="Name">Packages</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="ModuleScript" referent="293">
        <Properties>
          <string name="Name">Component</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezM3OUI0RDk5LUNCNjktNDFCNy04NjY2LTk4OTc5QjQ0RTM3QX0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_component@2.4.5"]["component"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="294">
        <Properties>
          <string name="Name">Fusion</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezFBOEI3MTY1LTdBMkUtNDNGMC05OTY3LTlBNTFDRjBBRDZGMX0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["elttob_fusion@0.1.1-beta"]["fusion"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="295">
        <Properties>
          <string name="Name">Input</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezYxNjQzQzVBLUY5M0MtNEE3OC1BMEFFLTEwRTgxODQ4MUI0Qn0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_input@1.3.3"]["input"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="296">
        <Properties>
          <string name="Name">Janitor</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezgyNzk4Mjg1LUJBMzctNDExNi05OTVELTNFMUJBQzU5MTkwQX0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["howmanysmall_janitor@1.14.1"]["janitor"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="297">
        <Properties>
          <string name="Name">Knit</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezM0MDFCMkM5LTM2ODYtNDRGMy1BQkFCLTJDN0UzNDk0QTlGQX0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_knit@1.4.7"]["knit"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="298">
        <Properties>
          <string name="Name">Loader</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezZDNDg2MTM2LTM2MkItNDY5RS1CNzBCLTdFMzQyMUM3MzAxMX0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_loader@1.0.2"]["loader"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="299">
        <Properties>
          <string name="Name">Promise</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0FGNEVGNThELTJCNzQtNDE5RS1CMjgxLTM5NkRDQjI0QTU5OH0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["evaera_promise@4.0.0"]["promise"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="300">
        <Properties>
          <string name="Name">Signal</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezlCOUQ3M0JBLTA3NTctNEZDNC05MTRFLUUyRTUzMUU5MzUyQn0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_signal@1.1.0"]["signal"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="301">
        <Properties>
          <string name="Name">Silo</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0E5OTUzNkRFLTczNTQtNEEyNC1CQTdCLTk2MjU0NjAxNUVGMH0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_silo@0.1.0"]["silo"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="302">
        <Properties>
          <string name="Name">Streamable</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezAxQUM5RUQ5LTlFNEItNDVGQy04MUQwLTg0RTkxMzFDNTlDNn0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_streamable@1.2.3"]["streamable"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="303">
        <Properties>
          <string name="Name">TableUtil</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0VDOTQ2QjBFLThCNDYtNDUwMS1CMTEzLThCODMzQjkzRjk4MX0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_table-util@1.1.1"]["table-util"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="304">
        <Properties>
          <string name="Name">Timer</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezI4OEE2ODY2LUI4RjctNDgxOS05QzhDLTgwOEFBMjkwMDhBQ30=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_timer@1.1.1"]["timer"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="Folder" referent="305">
        <Properties>
          <string name="Name">_Index</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="Folder" referent="306">
          <Properties>
            <string name="Name">sleitnick_comm@0.3.0</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="307">
            <Properties>
              <string name="Name">Option</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezQ4M0M4QTI3LUUzOEMtNEE1NS1CMzZBLUQzOUY4NzZBMTM0MX0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_option@1.0.3"]["option"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="308">
            <Properties>
              <string name="Name">Promise</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0IxNTY5RDU4LUI2ODQtNDVGQi1CMDk5LTEwNzNGMEZCNzQ1MH0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["evaera_promise@4.0.0"]["promise"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="309">
            <Properties>
              <string name="Name">Signal</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0VERTE5QkY3LTg5M0ItNEQ2MS05N0E1LTVCNTExRDlGMzdFOX0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_signal@1.1.0"]["signal"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="310">
            <Properties>
              <string name="Name">comm</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezAxOTA4NDcwLTdCNUEtNDg1QS05OUVCLUVCNkRBMEI1RUVEM30=]]></BinaryString>
              <string name="Source"><![CDATA[-- Comm
-- Stephen Leitnick
-- August 05, 2021


--[=[
	@class Comm
	Remote communication library.

	This exposes the raw functions that are used by the `ServerComm` and `ClientComm` classes.
	Those two classes should be preferred over accessing the functions directly through this
	Comm library.

	```lua
	-- Server
	local ServerComm = require(ReplicatedStorage.Packages.Comm).ServerComm
	local serverComm = ServerComm.new(somewhere, "MyComm")
	serverComm:BindFunction("Hello", function(player: Player)
		return "Hi"
	end)
	
	-- Client
	local ClientComm = require(ReplicatedStorage.Packages.Comm).ClientComm
	local clientComm = ClientComm.new(somewhere, false, "MyComm")
	local comm = clientComm:BuildObject()
	print(comm:Hello()) --> Hi
	```
]=]
local Comm = {
	Server = require(script.Server),
	Client = require(script.Client),
	ServerComm = require(script.Server.ServerComm),
	ClientComm = require(script.Client.ClientComm),
}

return Comm
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="311">
              <Properties>
                <string name="Name">Client</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0FCNUFENUUxLTNFNDAtNDZFMC05NUZELUI3MjI4REVGREY2RH0=]]></BinaryString>
                <string name="Source"><![CDATA[local Util = require(script.Parent.Util)
local Types = require(script.Parent.Types)
local Promise = require(script.Parent.Parent.Promise)
local ClientRemoteSignal = require(script.ClientRemoteSignal)
local ClientRemoteProperty = require(script.ClientRemoteProperty)

local Client = {}

function Client.GetFunction(parent: Instance, name: string, usePromise: boolean, inboundMiddleware: Types.ClientMiddleware?, outboundMiddleware: Types.ClientMiddleware?)
	assert(not Util.IsServer, "GetFunction must be called from the client")
	local folder = Util.GetCommSubFolder(parent, "RF"):Expect("Failed to get Comm RF folder")
	local rf = folder:WaitForChild(name, Util.WaitForChildTimeout)
	assert(rf ~= nil, "Failed to find RemoteFunction: " .. name)
	local hasInbound = type(inboundMiddleware) == "table" and #inboundMiddleware > 0
	local hasOutbound = type(outboundMiddleware) == "table" and #outboundMiddleware > 0
	local function ProcessOutbound(args)
		for _,middlewareFunc in ipairs(outboundMiddleware) do
			local middlewareResult = table.pack(middlewareFunc(args))
			if not middlewareResult[1] then
				return table.unpack(middlewareResult, 2, middlewareResult.n)
			end
			args.n = #args
		end
		return table.unpack(args, 1, args.n)
	end
	if hasInbound then
		if usePromise then
			return function(...)
				local args = table.pack(...)
				return Promise.new(function(resolve, reject)
					local success, res = pcall(function()
						if hasOutbound then
							return table.pack(rf:InvokeServer(ProcessOutbound(args)))
						else
							return table.pack(rf:InvokeServer(table.unpack(args, 1, args.n)))
						end
					end)
					if success then
						for _,middlewareFunc in ipairs(inboundMiddleware) do
							local middlewareResult = table.pack(middlewareFunc(res))
							if not middlewareResult[1] then
								return table.unpack(middlewareResult, 2, middlewareResult.n)
							end
							res.n = #res
						end
						resolve(table.unpack(res, 1, res.n))
					else
						reject(res)
					end
				end)
			end
		else
			return function(...)
				local res
				if hasOutbound then
					res = table.pack(rf:InvokeServer(ProcessOutbound(table.pack(...))))
				else
					res = table.pack(rf:InvokeServer(...))
				end
				for _,middlewareFunc in ipairs(inboundMiddleware) do
					local middlewareResult = table.pack(middlewareFunc(res))
					if not middlewareResult[1] then
						return table.unpack(middlewareResult, 2, middlewareResult.n)
					end
					res.n = #res
				end
				return table.unpack(res, 1, res.n)
			end
		end
	else
		if usePromise then
			return function(...)
				local args = table.pack(...)
				return Promise.new(function(resolve, reject)
					local success, res = pcall(function()
						if hasOutbound then
							return table.pack(rf:InvokeServer(ProcessOutbound(args)))
						else
							return table.pack(rf:InvokeServer(table.unpack(args, 1, args.n)))
						end
					end)
					if success then
						resolve(table.unpack(res, 1, res.n))
					else
						reject(res)
					end
				end)
			end
		else
			if hasOutbound then
				return function(...)
					return rf:InvokeServer(ProcessOutbound(table.pack(...)))
				end
			else
				return function(...)
					return rf:InvokeServer(...)
				end
			end
		end
	end
end


function Client.GetSignal(parent: Instance, name: string, inboundMiddleware: Types.ClientMiddleware?, outboundMiddleware: Types.ClientMiddleware?)
	assert(not Util.IsServer, "GetSignal must be called from the client")
	local folder = Util.GetCommSubFolder(parent, "RE"):Expect("Failed to get Comm RE folder")
	local re = folder:WaitForChild(name, Util.WaitForChildTimeout)
	assert(re ~= nil, "Failed to find RemoteEvent: " .. name)
	return ClientRemoteSignal.new(re, inboundMiddleware, outboundMiddleware)
end


function Client.GetProperty(parent: Instance, name: string, inboundMiddleware: Types.ClientMiddleware?, outboundMiddleware: Types.ClientMiddleware?)
	assert(not Util.IsServer, "GetProperty must be called from the client")
	local folder = Util.GetCommSubFolder(parent, "RP"):Expect("Failed to get Comm RP folder")
	local re = folder:WaitForChild(name, Util.WaitForChildTimeout)
	assert(re ~= nil, "Failed to find RemoteEvent for RemoteProperty: " .. name)
	return ClientRemoteProperty.new(re, inboundMiddleware, outboundMiddleware)
end

return Client
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="312">
                <Properties>
                  <string name="Name">ClientComm</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0EyQ0VBREZDLUNGNEUtNEJGMi05NzYxLUY0RjVDMDFERDgxRH0=]]></BinaryString>
                  <string name="Source"><![CDATA[-- ClientComm
-- Stephen Leitnick
-- December 20, 2021

local Comm = require(script.Parent)
local Util = require(script.Parent.Parent.Util)
local Types = require(script.Parent.Parent.Types)

--[=[
	@class ClientComm
	@client
]=]
local ClientComm = {}
ClientComm.__index = ClientComm

--[=[
	@within ClientComm
	@type ClientMiddlewareFn (args: {any}) -> (shouldContinue: boolean, ...: any)
	The middleware function takes the arguments (as a table array), and should
	return `true|false` to indicate if the process should continue.

	If returning `false`, the optional varargs after the `false` are used as the new return values
	to whatever was calling the middleware.
]=]
--[=[
	@within ClientComm
	@type ClientMiddleware {ClientMiddlewareFn}
	Array of middleware functions.
]=]

--[=[
	@return ClientComm
	Constructs a ClientComm object.

	If `usePromise` is set to `true`, then `GetFunction` will generate a function that returns a Promise
	that resolves with the server response. If set to `false`, the function will act like a normal
	call to a RemoteFunction and yield until the function responds.

	```lua
	local clientComm = ClientComm.new(game:GetService("ReplicatedStorage"), true)

	-- If using a unique namespace with ServerComm, include it as second argument:
	local clientComm = ClientComm.new(game:GetService("ReplicatedStorage"), true, "MyNamespace")
	```
]=]
function ClientComm.new(parent: Instance, usePromise: boolean, namespace: string?)
	assert(not Util.IsServer, "ClientComm must be constructed from the client")
	assert(typeof(parent) == "Instance", "Parent must be of type Instance")
	local ns = Util.DefaultCommFolderName
	if namespace then
		ns = namespace
	end
	local folder: Instance? = parent:WaitForChild(ns, Util.WaitForChildTimeout)
	assert(folder ~= nil, "Could not find namespace for ClientComm in parent: " .. ns)
	local self = setmetatable({}, ClientComm)
	self._instancesFolder = folder
	self._usePromise = usePromise
	return self
end

--[=[
	@param name string
	@param inboundMiddleware ClientMiddleware?
	@param outboundMiddleware ClientMiddleware?
	@return (...: any) -> any

	Generates a function on the matching RemoteFunction generated with ServerComm. The function
	can then be called to invoke the server. If this `ClientComm` object was created with
	the `usePromise` parameter set to `true`, then this generated function will return
	a Promise when called.

	```lua
	-- Server-side:
	local serverComm = ServerComm.new(someParent)
	serverComm:BindFunction("MyFunction", function(player, msg)
		return msg:upper()
	end)

	-- Client-side:
	local clientComm = ClientComm.new(someParent)
	local myFunc = clientComm:GetFunction("MyFunction")
	local uppercase = myFunc("hello world")
	print(uppercase) --> HELLO WORLD

	-- Client-side, using promises:
	local clientComm = ClientComm.new(someParent, true)
	local myFunc = clientComm:GetFunction("MyFunction")
	myFunc("hi there"):andThen(function(msg)
		print(msg) --> HI THERE
	end):catch(function(err)
		print("Error:", err)
	end)
	```
]=]
function ClientComm:GetFunction(name: string, inboundMiddleware: Types.ClientMiddleware?, outboundMiddleware: Types.ClientMiddleware?)
	return Comm.GetFunction(self._instancesFolder, name, self._usePromise, inboundMiddleware, outboundMiddleware)
end

--[=[
	@param name string
	@param inboundMiddleware ClientMiddleware?
	@param outboundMiddleware ClientMiddleware?
	@return ClientRemoteSignal
	Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by
	ServerComm with the same matching `name`.

	```lua
	local mySignal = clientComm:GetSignal("MySignal")

	-- Listen for data from the server:
	mySignal:Connect(function(message)
		print("Received message from server:", message)
	end)

	-- Send data to the server:
	mySignal:Fire("Hello!")
	```
]=]
function ClientComm:GetSignal(name: string, inboundMiddleware: Types.ClientMiddleware?, outboundMiddleware: Types.ClientMiddleware?)
	return Comm.GetSignal(self._instancesFolder, name, inboundMiddleware, outboundMiddleware)
end

--[=[
	@param name string
	@param inboundMiddleware ClientMiddleware?
	@param outboundMiddleware ClientMiddleware?
	@return ClientRemoteProperty
	Returns a new ClientRemoteProperty that mirrors the matching RemoteProperty created by
	ServerComm with the same matching `name`.

	Take a look at the ClientRemoteProperty documentation for more info, such as
	understanding how to wait for data to be ready.

	```lua
	local mapInfo = clientComm:GetProperty("MapInfo")

	-- Observe the initial value of mapInfo, and all subsequent changes:
	mapInfo:Observe(function(info)
		print("Current map info", info)
	end)

	-- Check to see if data is initially ready:
	if mapInfo:IsReady() then
		-- Get the data:
		local info = mapInfo:Get()
	end

	-- Get a promise that resolves once the data is ready (resolves immediately if already ready):
	mapInfo:OnReady():andThen(function(info)
		print("Map info is ready with info", info)
	end)

	-- Same as above, but yields thread:
	local success, info = mapInfo:OnReady():await()
	```
]=]
function ClientComm:GetProperty(name: string, inboundMiddleware: Types.ClientMiddleware?, outboundMiddleware: Types.ClientMiddleware?)
	return Comm.GetProperty(self._instancesFolder, name, inboundMiddleware, outboundMiddleware)
end

--[=[
	@param inboundMiddleware ClientMiddleware?
	@param outboundMiddleware ClientMiddleware?
	@return table
	Returns an object which maps RemoteFunctions as methods
	and RemoteEvents as fields.
	```lua
	-- Server-side:
	serverComm:BindFunction("Test", function(player) end)
	serverComm:CreateSignal("MySignal")
	serverComm:CreateProperty("MyProperty", 10)

	-- Client-side
	local obj = clientComm:BuildObject()
	obj:Test()
	obj.MySignal:Connect(function(data) end)
	obj.MyProperty:Observe(function(value) end)
	```
]=]
function ClientComm:BuildObject(inboundMiddleware: Types.ClientMiddleware?, outboundMiddleware: Types.ClientMiddleware?)
	local obj = {}
	local rfFolder = self._instancesFolder:FindFirstChild("RF")
	local reFolder = self._instancesFolder:FindFirstChild("RE")
	local rpFolder = self._instancesFolder:FindFirstChild("RP")
	if rfFolder then
		for _,rf in ipairs(rfFolder:GetChildren()) do
			if not rf:IsA("RemoteFunction") then continue end
			local f = self:GetFunction(rf.Name, inboundMiddleware, outboundMiddleware)
			obj[rf.Name] = function(_self, ...)
				return f(...)
			end
		end
	end
	if reFolder then
		for _,re in ipairs(reFolder:GetChildren()) do
			if not re:IsA("RemoteEvent") then continue end
			obj[re.Name] = self:GetSignal(re.Name, inboundMiddleware, outboundMiddleware)
		end
	end
	if rpFolder then
		for _,re in ipairs(rpFolder:GetChildren()) do
			if not re:IsA("RemoteEvent") then continue end
			obj[re.Name] = self:GetProperty(re.Name, inboundMiddleware, outboundMiddleware)
		end
	end
	return obj
end

--[=[
	Destroys the ClientComm object.
]=]
function ClientComm:Destroy()
end

return ClientComm
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="313">
                <Properties>
                  <string name="Name">ClientRemoteProperty</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0I5MEE5ODY1LTZBNjQtNENFQi1BRThBLTNDOTY4QTI4RTdEMX0=]]></BinaryString>
                  <string name="Source"><![CDATA[-- ClientRemoteProperty
-- Stephen Leitnick
-- December 20, 2021


local Promise = require(script.Parent.Parent.Parent.Promise)
local Signal = require(script.Parent.Parent.Parent.Signal)
local ClientRemoteSignal = require(script.Parent.ClientRemoteSignal)
local Types = require(script.Parent.Parent.Types)

--[=[
	@within ClientRemoteProperty
	@prop Changed Signal<any>

	Fires when the property receives an updated value
	from the server.

	```lua
	clientRemoteProperty.Changed:Connect(function(value)
		print("New value", value)
	end)
	```
]=]

--[=[
	@class ClientRemoteProperty
	@client
	Created via `ClientComm:GetProperty()`.
]=]
local ClientRemoteProperty = {}
ClientRemoteProperty.__index = ClientRemoteProperty

function ClientRemoteProperty.new(re: RemoteEvent, inboundMiddleware: Types.ClientMiddleware?, outboudMiddleware: Types.ClientMiddleware?)
	local self = setmetatable({}, ClientRemoteProperty)
	self._rs = ClientRemoteSignal.new(re, inboundMiddleware, outboudMiddleware)
	self._ready = false
	self._value = nil
	self.Changed = Signal.new()
	self._readyPromise = self:OnReady():andThen(function()
		self._readyPromise = nil
		self.Changed:Fire(self._value)
		self._changed = self._rs:Connect(function(value)
			if value == self._value then return end
			self._value = value
			self.Changed:Fire(value)
		end)
	end)
	self._rs:Fire()
	return self
end

--[=[
	Gets the value of the property object.

	:::caution
	This value might not be ready right away. Use `OnReady()` or `IsReady()`
	before calling `Get()`. If not ready, this value will return `nil`.
	:::
]=]
function ClientRemoteProperty:Get(): any
	return self._value
end

--[=[
	@return Promise<any>
	Returns a Promise which resolves once the property object is
	ready to be used. The resolved promise will also contain the
	value of the property.

	```lua
	-- Use andThen clause:
	clientRemoteProperty:OnReady():andThen(function(initialValue)
		print(initialValue)
	end)

	-- Use await:
	local success, initialValue = clientRemoteProperty:OnReady():await()
	if success then
		print(initialValue)
	end
	```
]=]
function ClientRemoteProperty:OnReady()
	if self._ready then
		return Promise.resolve(self._value)
	end
	return Promise.fromEvent(self._rs, function(value)
		self._value = value
		self._ready = true
		return true
	end):andThen(function()
		return self._value
	end)
end

--[=[
	Returns `true` if the property object is ready to be
	used. In other words, it has successfully gained
	connection to the server-side version and has synced
	in the initial value.

	```lua
	if clientRemoteProperty:IsReady() then
		local value = clientRemoteProperty:Get()
	end
	```
]=]
function ClientRemoteProperty:IsReady(): boolean
	return self._ready
end

--[=[
	@param observer (any) -> nil
	@return Connection
	Observes the value of the property. The observer will
	be called right when the value is first ready, and
	every time the value changes. This is safe to call
	immediately (i.e. no need to use `IsReady` or `OnReady`
	before using this method).

	Observing is essentially listening to `Changed`, but
	also sends the initial value right away (or at least
	once `OnReady` is completed).

	```lua
	local function ObserveValue(value)
		print(value)
	end

	clientRemoteProperty:Observe(ObserveValue)
	```
]=]
function ClientRemoteProperty:Observe(observer: (any) -> ())
	if self._ready then
		task.defer(observer, self._value)
	end
	return self.Changed:Connect(observer)
end

--[=[
	Destroys the ClientRemoteProperty object.
]=]
function ClientRemoteProperty:Destroy()
	self._rs:Destroy()
	if self._readyPromise then
		self._readyPromise:cancel()
	end
	if self._changed then
		self._changed:Disconnect()
	end
	self.Changed:Destroy()
end

return ClientRemoteProperty
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="314">
                <Properties>
                  <string name="Name">ClientRemoteSignal</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezZFNkIyNkFBLTc4NTUtNDhBRC05QjdCLTVEQzFBRUYyMTlEQn0=]]></BinaryString>
                  <string name="Source"><![CDATA[-- ClientRemoteSignal
-- Stephen Leitnick
-- December 20, 2021


local Signal = require(script.Parent.Parent.Parent.Signal)
local Types = require(script.Parent.Parent.Types)

--[=[
	@class ClientRemoteSignal
	@client
	Created via `ClientComm:GetSignal()`.
]=]
local ClientRemoteSignal = {}
ClientRemoteSignal.__index = ClientRemoteSignal

--[=[
	@within ClientRemoteSignal
	@interface Connection
	.Disconnect () -> ()
]=]

function ClientRemoteSignal.new(re: RemoteEvent, inboundMiddleware: Types.ClientMiddleware?, outboudMiddleware: Types.ClientMiddleware?)
	local self = setmetatable({}, ClientRemoteSignal)
	self._re = re
	if outboudMiddleware and #outboudMiddleware > 0 then
		self._hasOutbound = true
		self._outbound = outboudMiddleware
	else
		self._hasOutbound = false
	end
	if inboundMiddleware and #inboundMiddleware > 0 then
		self._directConnect = false
		self._signal = Signal.new()
		self._reConn = self._re.OnClientEvent:Connect(function(...)
			local args = table.pack(...)
			for _,middlewareFunc in ipairs(inboundMiddleware) do
				local middlewareResult = table.pack(middlewareFunc(args))
				if not middlewareResult[1] then
					return
				end
				args.n = #args
			end
			self._signal:Fire(table.unpack(args, 1, args.n))
		end)
	else
		self._directConnect = true
	end
	return self
end

function ClientRemoteSignal:_processOutboundMiddleware(...: any)
	local args = table.pack(...)
	for _,middlewareFunc in ipairs(self._outbound) do
		local middlewareResult = table.pack(middlewareFunc(args))
		if not middlewareResult[1] then
			return table.unpack(middlewareResult, 2, middlewareResult.n)
		end
		args.n = #args
	end
	return table.unpack(args, 1, args.n)
end

--[=[
	@param fn (...: any) -> ()
	@return Connection
	Connects a function to the remote signal. The function will be
	called anytime the equivalent server-side RemoteSignal is
	fired at this specific client that created this client signal.
]=]
function ClientRemoteSignal:Connect(fn: (...any) -> ())
	if self._directConnect then
		return self._re.OnClientEvent:Connect(fn)
	else
		return self._signal:Connect(fn)
	end
end

--[=[
	Fires the equivalent server-side signal with the given arguments.

	:::note Outbound Middleware
	All arguments pass through any outbound middleware before being
	sent to the server.
	:::
]=]
function ClientRemoteSignal:Fire(...: any)
	if self._hasOutbound then
		self._re:FireServer(self:_processOutboundMiddleware(...))
	else
		self._re:FireServer(...)
	end
end

--[=[
	Destroys the ClientRemoteSignal object.
]=]
function ClientRemoteSignal:Destroy()
	if self._signal then
		self._signal:Destroy()
	end
end

return ClientRemoteSignal
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="315">
              <Properties>
                <string name="Name">Server</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0Y0OTA5NTc5LTdBQkQtNDE3MS1CMTE2LUUwMDA5RDAxODRCQX0=]]></BinaryString>
                <string name="Source"><![CDATA[local Util = require(script.Parent.Util)
local RemoteSignal = require(script.RemoteSignal)
local RemoteProperty = require(script.RemoteProperty)
local Types = require(script.Parent.Types)

local Server = {}

--[=[
	@within Comm
	@prop ServerComm ServerComm
]=]
--[=[
	@within Comm
	@prop ClientComm ClientComm
]=]

--[=[
	@within Comm
	@private
	@interface Server
	.BindFunction (parent: Instance, name: string, fn: FnBind, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware?): RemoteFunction
	.WrapMethod (parent: Instance, tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware?): RemoteFunction
	.CreateSignal (parent: Instance, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware?): RemoteSignal
	.CreateProperty (parent: Instance, name: string, value: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware?): RemoteProperty
	Server Comm
]=]
--[=[
	@within Comm
	@private
	@interface Client
	.GetFunction (parent: Instance, name: string, usePromise: boolean, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware?): (...: any) -> any
	.GetSignal (parent: Instance, name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware?): ClientRemoteSignal
	.GetProperty (parent: Instance, name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware?): ClientRemoteProperty
	Client Comm
]=]


function Server.BindFunction(parent: Instance, name: string, func: Types.FnBind, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?): RemoteFunction
	assert(Util.IsServer, "BindFunction must be called from the server")
	local folder = Util.GetCommSubFolder(parent, "RF"):Expect("Failed to get Comm RF folder")
	local rf = Instance.new("RemoteFunction")
	rf.Name = name
	local hasInbound = type(inboundMiddleware) == "table" and #inboundMiddleware > 0
	local hasOutbound = type(outboundMiddleware) == "table" and #outboundMiddleware > 0
	local function ProcessOutbound(player, ...)
		local args = table.pack(...)
		for _,middlewareFunc in ipairs(outboundMiddleware) do
			local middlewareResult = table.pack(middlewareFunc(player, args))
			if not middlewareResult[1] then
				return table.unpack(middlewareResult, 2, middlewareResult.n)
			end
			args.n = #args
		end
		return table.unpack(args, 1, args.n)
	end
	if hasInbound and hasOutbound then
		local function OnServerInvoke(player, ...)
			local args = table.pack(...)
			for _,middlewareFunc in ipairs(inboundMiddleware) do
				local middlewareResult = table.pack(middlewareFunc(player, args))
				if not middlewareResult[1] then
					return table.unpack(middlewareResult, 2, middlewareResult.n)
				end
				args.n = #args
			end
			return ProcessOutbound(player, func(player, table.unpack(args, 1, args.n)))
		end
		rf.OnServerInvoke = OnServerInvoke
	elseif hasInbound then
		local function OnServerInvoke(player, ...)
			local args = table.pack(...)
			for _,middlewareFunc in ipairs(inboundMiddleware) do
				local middlewareResult = table.pack(middlewareFunc(player, args))
				if not middlewareResult[1] then
					return table.unpack(middlewareResult, 2, middlewareResult.n)
				end
				args.n = #args
			end
			return func(player, table.unpack(args, 1, args.n))
		end
		rf.OnServerInvoke = OnServerInvoke
	elseif hasOutbound then
		local function OnServerInvoke(player, ...)
			return ProcessOutbound(player, func(player, ...))
		end
		rf.OnServerInvoke = OnServerInvoke
	else
		rf.OnServerInvoke = func
	end
	rf.Parent = folder
	return rf
end


function Server.WrapMethod(parent: Instance, tbl: {}, name: string, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?): RemoteFunction
	assert(Util.IsServer, "WrapMethod must be called from the server")
	local fn = tbl[name]
	assert(type(fn) == "function", "Value at index " .. name .. " must be a function; got " .. type(fn))
	return Server.BindFunction(parent, name, function(...) return fn(tbl, ...) end, inboundMiddleware, outboundMiddleware)
end


function Server.CreateSignal(parent: Instance, name: string, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?)
	assert(Util.IsServer, "CreateSignal must be called from the server")
	local folder = Util.GetCommSubFolder(parent, "RE"):Expect("Failed to get Comm RE folder")
	local rs = RemoteSignal.new(folder, name, inboundMiddleware, outboundMiddleware)
	return rs
end


function Server.CreateProperty(parent: Instance, name: string, initialValue: any, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?)
	assert(Util.IsServer, "CreateProperty must be called from the server")
	local folder = Util.GetCommSubFolder(parent, "RP"):Expect("Failed to get Comm RP folder")
	local rp = RemoteProperty.new(folder, name, initialValue, inboundMiddleware, outboundMiddleware)
	return rp
end

return Server
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="316">
                <Properties>
                  <string name="Name">RemoteProperty</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezBCNzBCNEE3LUNGMDktNEM1NS1BMjgwLTVCMzJCQTk3Q0E0RX0=]]></BinaryString>
                  <string name="Source"><![CDATA[-- RemoteProperty
-- Stephen Leitnick
-- December 20, 2021


local Players = game:GetService("Players")

local Util = require(script.Parent.Parent.Util)
local Types = require(script.Parent.Parent.Types)
local RemoteSignal = require(script.Parent.RemoteSignal)

local None = Util.None

--[=[
	@class RemoteProperty
	@server
	Created via `ServerComm:CreateProperty()`.

	Values set can be anything that can pass through a
	[RemoteEvent](https://developer.roblox.com/en-us/articles/Remote-Functions-and-Events#parameter-limitations).

	Here is a cheat-sheet for the below methods:
	- Setting data
		- `Set`: Set "top" value for all current and future players. Overrides any custom-set data per player.
		- `SetTop`: Set the "top" value for all players, but does _not_ override any custom-set data per player.
		- `SetFor`: Set custom data for the given player. Overrides the "top" value. (_Can be nil_)
		- `SetForList`: Same as `SetFor`, but accepts a list of players.
		- `SetFilter`: Accepts a predicate function which checks for which players to set.
	- Clearing data
		- `ClearFor`: Clears the custom data set for a given player. Player will start using the "top" level value instead.
		- `ClearForList`: Same as `ClearFor`, but accepts a list of players.
		- `ClearFilter`: Accepts a predicate function which checks for which players to clear.
	- Getting data
		- `Get`: Retrieves the "top" value
		- `GetFor`: Gets the current value for the given player. If cleared, returns the top value.

	:::caution Network
	Calling any of the data setter methods (e.g. `Set()`) will
	fire the underlying RemoteEvent to replicate data to the
	clients. Therefore, setting data should only occur when it
	is necessary to change the data that the clients receive.
	:::

	:::caution Tables
	Tables _can_ be used with RemoteProperties. However, the
	RemoteProperty object will _not_ watch for changes within
	the table. Therefore, anytime changes are made to the table,
	the data must be set again using one of the setter methods.
	:::
]=]
local RemoteProperty = {}
RemoteProperty.__index = RemoteProperty

function RemoteProperty.new(parent: Instance, name: string, initialValue: any, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?)
	local self = setmetatable({}, RemoteProperty)
	self._rs = RemoteSignal.new(parent, name, inboundMiddleware, outboundMiddleware)
	self._value = initialValue
	self._perPlayer = {}
	self._playerRemoving = Players.PlayerRemoving:Connect(function(player)
		self._perPlayer[player] = nil
	end)
	self._rs:Connect(function(player)
		local playerValue = self._perPlayer[player]
		local value = if playerValue == nil then self._value elseif playerValue == None then nil else playerValue
		self._rs:Fire(player, value)
	end)
	return self
end

--[=[
	Sets the top-level value of all clients to the same value.
	
	:::note Override Per-Player Data
	This will override any per-player data that was set using
	`SetFor` or `SetFilter`. To avoid overriding this data,
	`SetTop` can be used instead.
	:::

	```lua
	-- Examples
	remoteProperty:Set(10)
	remoteProperty:Set({SomeData = 32})
	remoteProperty:Set("HelloWorld")
	```
]=]
function RemoteProperty:Set(value: any)
	self._value = value
	table.clear(self._perPlayer)
	self._rs:FireAll(value)
end

--[=[
	Set the top-level value of the property, but does not override
	any per-player data (e.g. set with `SetFor` or `SetFilter`).
	Any player without custom-set data will receive this new data.

	This is useful if certain players have specific values that
	should not be changed, but all other players should receive
	the same new value.

	```lua
	-- Using just 'Set' overrides per-player data:
	remoteProperty:SetFor(somePlayer, "CustomData")
	remoteProperty:Set("Data")
	print(remoteProperty:GetFor(somePlayer)) --> "Data"

	-- Using 'SetTop' does not override:
	remoteProperty:SetFor(somePlayer, "CustomData")
	remoteProperty:SetTop("Data")
	print(remoteProperty:GetFor(somePlayer)) --> "CustomData"
	```
]=]
function RemoteProperty:SetTop(value: any)
	self._value = value
	for _,player in ipairs(Players:GetPlayers()) do
		if self._perPlayer[player] == nil then
			self._rs:Fire(player, value)
		end
	end
end

--[=[
	@param value any -- Value to set for the clients (and to the predicate)
	Sets the value for specific clients that pass the `predicate`
	function test. This can be used to finely set the values
	based on more control logic (e.g. setting certain values
	per team).

	```lua
	-- Set the value of "NewValue" to players with a name longer than 10 characters:
	remoteProperty:SetFilter(function(player)
		return #player.Name > 10
	end, "NewValue")
	```
]=]
function RemoteProperty:SetFilter(predicate: (Player, any) -> boolean, value: any)
	for _,player in ipairs(Players:GetPlayers()) do
		if predicate(player, value) then
			self:SetFor(player, value)
		end
	end
end

--[=[
	Set the value of the property for a specific player. This
	will override the value used by `Set` (and the initial value
	set for the property when created).

	This value _can_ be `nil`. In order to reset the value for a
	given player and let the player use the top-level value held
	by this property, either use `Set` to set all players' data,
	or use `ClearFor`.

	```lua
	remoteProperty:SetFor(somePlayer, "CustomData")
	```
]=]
function RemoteProperty:SetFor(player: Player, value: any)
	if player.Parent then
		self._perPlayer[player] = if value == nil then None else value
	end
	self._rs:Fire(player, value)
end

--[=[
	Set the value of the property for specific players. This just
	loops through the players given and calls `SetFor`.

	```lua
	local players = {player1, player2, player3}
	remoteProperty:SetForList(players, "CustomData")
	```
]=]
function RemoteProperty:SetForList(players: {Player}, value: any)
	for _,player in ipairs(players) do
		self:SetFor(player, value)
	end
end

--[=[
	Clears the custom property value for the given player. When
	this occurs, the player will reset to use the top-level
	value held by this property (either the value set when the
	property was created, or the last value set by `Set`).

	```lua
	remoteProperty:Set("DATA")

	remoteProperty:SetFor(somePlayer, "CUSTOM_DATA")
	print(remoteProperty:GetFor(somePlayer)) --> "CUSTOM_DATA"

	-- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL:
	remoteProperty:SetFor(somePlayer, nil)
	print(remoteProperty:GetFor(somePlayer)) --> nil

	-- CLEAR:
	remoteProperty:ClearFor(somePlayer)
	print(remoteProperty:GetFor(somePlayer)) --> "DATA"
	```
]=]
function RemoteProperty:ClearFor(player: Player)
	if self._perPlayer[player] == nil then return end
	self._perPlayer[player] = nil
	self._rs:Fire(player, self._value)
end

--[=[
	Clears the custom value for the given players. This
	just loops through the list of players and calls
	the `ClearFor` method for each player.
]=]
function RemoteProperty:ClearForList(players: {Player})
	for _,player in ipairs(players) do
		self:ClearFor(player)
	end
end

--[=[
	The same as `SetFiler`, except clears the custom value
	for any player that passes the predicate.
]=]
function RemoteProperty:ClearFilter(predicate: (Player) -> boolean)
	for _,player in ipairs(Players:GetPlayers()) do
		if predicate(player) then
			self:ClearFor(player)
		end
	end
end

--[=[
	Returns the top-level value held by the property. This will
	either be the initial value set, or the last value set
	with `Set()`.

	```lua
	remoteProperty:Set("Data")
	print(remoteProperty:Get()) --> "Data"
	```
]=]
function RemoteProperty:Get(): any
	return self._value
end

--[=[
	Returns the current value for the given player. This value
	will depend on if `SetFor` or `SetFilter` has affected the
	custom value for the player. If so, that custom value will
	be returned. Otherwise, the top-level value will be used
	(e.g. value from `Set`).

	```lua
	-- Set top level data:
	remoteProperty:Set("Data")
	print(remoteProperty:GetFor(somePlayer)) --> "Data"

	-- Set custom data:
	remoteProperty:SetFor(somePlayer, "CustomData")
	print(remoteProperty:GetFor(somePlayer)) --> "CustomData"

	-- Set top level again, overriding custom data:
	remoteProperty:Set("NewData")
	print(remoteProperty:GetFor(somePlayer)) --> "NewData"

	-- Set custom data again, and set top level without overriding:
	remoteProperty:SetFor(somePlayer, "CustomData")
	remoteProperty:SetTop("Data")
	print(remoteProperty:GetFor(somePlayer)) --> "CustomData"

	-- Clear custom data to use top level data:
	remoteProperty:ClearFor(somePlayer)
	print(remoteProperty:GetFor(somePlayer)) --> "Data"
	```
]=]
function RemoteProperty:GetFor(player: Player): any
	local playerValue = self._perPlayer[player]
	local value = if playerValue == nil then self._value elseif playerValue == None then nil else playerValue
	return value
end

--[=[
	Destroys the RemoteProperty object.
]=]
function RemoteProperty:Destroy()
	self._rs:Destroy()
	self._playerRemoving:Disconnect()
end

return RemoteProperty
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="317">
                <Properties>
                  <string name="Name">RemoteSignal</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezEyMkM2MTdCLUVCM0UtNEMxMy04RDc2LTIwNDAxNzkzODE3Qn0=]]></BinaryString>
                  <string name="Source"><![CDATA[-- RemoteSignal
-- Stephen Leitnick
-- December 20, 2021


local Players = game:GetService("Players")

local Signal = require(script.Parent.Parent.Parent.Signal)
local Types = require(script.Parent.Parent.Types)


--[=[
	@class RemoteSignal
	@server
	Created via `ServerComm:CreateSignal()`.
]=]
local RemoteSignal = {}
RemoteSignal.__index = RemoteSignal

--[=[
	@within RemoteSignal
	@interface Connection
	.Disconnect () -> nil
	.Connected boolean
]=]

function RemoteSignal.new(parent: Instance, name: string, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?)
	local self = setmetatable({}, RemoteSignal)
	self._re = Instance.new("RemoteEvent")
	self._re.Name = name
	self._re.Parent = parent
	if outboundMiddleware and #outboundMiddleware > 0 then
		self._hasOutbound = true
		self._outbound = outboundMiddleware
	else
		self._hasOutbound = false
	end
	if inboundMiddleware and #inboundMiddleware > 0 then
		self._directConnect = false
		self._signal = Signal.new()
		self._re.OnServerEvent:Connect(function(player, ...)
			local args = table.pack(...)
			for _,middlewareFunc in ipairs(inboundMiddleware) do
				local middlewareResult = table.pack(middlewareFunc(player, args))
				if not middlewareResult[1] then
					return
				end
				args.n = #args
			end
			self._signal:Fire(player, table.unpack(args, 1, args.n))
		end)
	else
		self._directConnect = true
	end
	return self
end

--[=[
	@param fn (player: Player, ...: any) -> nil -- The function to connect
	@return Connection
	Connect a function to the signal. Anytime a matching ClientRemoteSignal
	on a client fires, the connected function will be invoked with the
	arguments passed by the client.
]=]
function RemoteSignal:Connect(fn)
	if self._directConnect then
		return self._re.OnServerEvent:Connect(fn)
	else
		return self._signal:Connect(fn)
	end
end

function RemoteSignal:_processOutboundMiddleware(player: Player?, ...: any)
	if not self._hasOutbound then
		return ...
	end
	local args = table.pack(...)
	for _,middlewareFunc in ipairs(self._outbound) do
		local middlewareResult = table.pack(middlewareFunc(player, args))
		if not middlewareResult[1] then
			return table.unpack(middlewareResult, 2, middlewareResult.n)
		end
		args.n = #args
	end
	return table.unpack(args, 1, args.n)
end

--[=[
	@param player Player -- The target client
	@param ... any -- Arguments passed to the client
	Fires the signal at the specified client with any arguments.

	:::note Outbound Middleware
	All arguments pass through any outbound middleware (if any)
	before being sent to the clients.
	:::
]=]
function RemoteSignal:Fire(player: Player, ...: any)
	self._re:FireClient(player, self:_processOutboundMiddleware(player, ...))
end

--[=[
	@param ... any
	Fires the signal at _all_ clients with any arguments.

	:::note Outbound Middleware
	All arguments pass through any outbound middleware (if any)
	before being sent to the clients.
	:::
]=]
function RemoteSignal:FireAll(...: any)
	self._re:FireAllClients(self:_processOutboundMiddleware(nil, ...))
end

--[=[
	@param ignorePlayer Player -- The client to ignore
	@param ... any -- Arguments passed to the other clients
	Fires the signal to all clients _except_ the specified
	client.

	:::note Outbound Middleware
	All arguments pass through any outbound middleware (if any)
	before being sent to the clients.
	:::
]=]
function RemoteSignal:FireExcept(ignorePlayer: Player, ...: any)
	self:FireFilter(function(plr)
		return plr ~= ignorePlayer
	end, ...)
end

--[=[
	@param predicate (player: Player, argsFromFire: ...) -> boolean
	@param ... any -- Arguments to pass to the clients (and to the predicate)
	Fires the signal at any clients that pass the `predicate`
	function test. This can be used to fire signals with much
	more control logic.

	:::note Outbound Middleware
	All arguments pass through any outbound middleware (if any)
	before being sent to the clients.
	:::

	:::caution Predicate Before Middleware
	The arguments sent to the predicate are sent _before_ getting
	transformed by any middleware.
	:::

	```lua
	-- Fire signal to players of the same team:
	remoteSignal:FireFilter(function(player)
		return player.Team.Name == "Best Team"
	end)
	```
]=]
function RemoteSignal:FireFilter(predicate: (Player, ...any) -> boolean, ...: any)
	for _,player in ipairs(Players:GetPlayers()) do
		if predicate(player, ...) then
			self._re:FireClient(player, self:_processOutboundMiddleware(nil, ...))
		end
	end
end

--[=[
	Fires a signal at the clients within the `players` table. This is
	useful when signals need to fire for a specific set of players.

	For more complex firing, see `FireFilter`.

	:::note Outbound Middleware
	All arguments pass through any outbound middleware (if any)
	before being sent to the clients.
	:::

	```lua
	local players = {somePlayer1, somePlayer2, somePlayer3}
	remoteSignal:FireFor(players, "Hello, players!")
	```
]=]
function RemoteSignal:FireFor(players: {Player}, ...: any)
	for _,player in ipairs(players) do
		self._re:FireClient(player, self:_processOutboundMiddleware(nil, ...))
	end
end

--[=[
	Destroys the RemoteSignal object.
]=]
function RemoteSignal:Destroy()
	self._re:Destroy()
	if self._signal then
		self._signal:Destroy()
	end
end

return RemoteSignal
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="318">
                <Properties>
                  <string name="Name">ServerComm</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0VBNjkxNzY2LTNCMzctNDY0Qi04MkFCLTUyM0E3NTcyNTMzMn0=]]></BinaryString>
                  <string name="Source"><![CDATA[-- ServerComm
-- Stephen Leitnick
-- December 20, 2021


local Comm = require(script.Parent)
local Util = require(script.Parent.Parent.Util)
local Types = require(script.Parent.Parent.Types)

--[=[
	@class ServerComm
	@server
]=]
local ServerComm = {}
ServerComm.__index = ServerComm

--[=[
	@within ServerComm
	@type ServerMiddlewareFn (player: Player, args: {any}) -> (shouldContinue: boolean, ...: any)
	The middleware function takes the client player and the arguments (as a table array), and should
	return `true|false` to indicate if the process should continue.

	If returning `false`, the optional varargs after the `false` are used as the new return values
	to whatever was calling the middleware.
]=]
--[=[
	@within ServerComm
	@type ServerMiddleware {ServerMiddlewareFn}
	Array of middleware functions.
]=]

--[=[
	@return ServerComm
	Constructs a ServerComm object. The `namespace` parameter is used
	in cases where more than one ServerComm object may be bound
	to the same object. Otherwise, a default namespace is used.

	```lua
	local serverComm = ServerComm.new(game:GetService("ReplicatedStorage"))

	-- If many might exist in the given parent, use a unique namespace:
	local serverComm = ServerComm.new(game:GetService("ReplicatedStorage"), "MyNamespace")
	```
]=]
function ServerComm.new(parent: Instance, namespace: string?)
	assert(Util.IsServer, "ServerComm must be constructed from the server")
	assert(typeof(parent) == "Instance", "Parent must be of type Instance")
	local ns = Util.DefaultCommFolderName
	if namespace then
		ns = namespace
	end
	assert(not parent:FindFirstChild(ns), "Parent already has another ServerComm bound to namespace " .. ns)
	local self = setmetatable({}, ServerComm)
	self._instancesFolder = Instance.new("Folder")
	self._instancesFolder.Name = ns
	self._instancesFolder.Parent = parent
	return self
end

--[=[
	@param name string
	@param fn (player: Player, ...: any) -> ...: any
	@param inboundMiddleware ServerMiddleware?
	@param outboundMiddleware ServerMiddleware?
	@return RemoteFunction
	Creates a RemoteFunction and binds the given function to it. Inbound
	and outbound middleware can be applied if desired.

	```lua
	local function GetSomething(player: Player)
		return "Something"
	end

	serverComm:BindFunction("GetSomething", GetSomething)
	```
]=]
function ServerComm:BindFunction(name: string, fn: Types.FnBind, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?): RemoteFunction
	return Comm.BindFunction(self._instancesFolder, name, fn, inboundMiddleware, outboundMiddleware)
end

--[=[
	@param tbl table
	@param name string
	@param inboundMiddleware ServerMiddleware?
	@param outboundMiddleware ServerMiddleware?
	@return RemoteFunction

	Binds a function to a table method. The name must match the
	name of the method in the table. The same name will be used
	on the client to access the given function.

	```lua
	local MyObject = {
		_Data = 10,
	}

	function MyObject:GetData(player: Player)
		return self._Data
	end

	serverComm:WrapMethod(MyObject, "GetData")
	```
]=]
function ServerComm:WrapMethod(tbl: {}, name: string, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?): RemoteFunction
	return Comm.WrapMethod(self._instancesFolder, tbl, name, inboundMiddleware, outboundMiddleware)
end

--[=[
	@param name string
	@param inboundMiddleware ServerMiddleware?
	@param outboundMiddleware ServerMiddleware?
	@return RemoteSignal

	Creates a signal that can be used to fire data to the clients
	or receive data from the clients.

	```lua
	local mySignal = serverComm:CreateSignal("MySignal")

	-- Examples of firing in different ways (see docs for RemoteSignal for further info):
	mySignal:Fire(somePlayer, "Hello world")
	mySignal:FireAll("Hi there")
	mySignal:FireExcept(somePlayer, "Hello everyone except " .. somePlayer.Name)
	mySignal:FireFilter(function(player) return player.Team == someCoolTeam end, "Hello cool team")

	-- Example of listening for clients to send data:
	mySignal:Connect(function(player, message)
		print("Got a message from " .. player.Name .. ":", message)
	end)
	```
]=]
function ServerComm:CreateSignal(name: string, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?)
	return Comm.CreateSignal(self._instancesFolder, name, inboundMiddleware, outboundMiddleware)
end

--[=[
	@param name string
	@param initialValue any
	@param inboundMiddleware ServerMiddleware?
	@param outboundMiddleware ServerMiddleware?
	@return RemoteProperty

	Create a property object which will replicate its property value to
	the clients. Optionally, specific clients can be targeted with
	different property values.

	```lua
	local comm = Comm.ServerComm.new(game:GetService("ReplicatedStorage"))

	local mapInfo = comm:CreateProperty("MapInfo", {
		MapName = "TheAwesomeMap",
		MapDuration = 60,
	})

	-- Change the data:
	mapInfo:Set({
		MapName = "AnotherMap",
		MapDuration = 30,
	})

	-- Change the data for one player:
	mapInfo:SetFor(somePlayer, {
		MapName = "ASpecialMapForYou",
		MapDuration = 90,
	})

	-- Change data based on a predicate function:
	mapInfo:SetFilter(function(player)
		return player.Team == game.Teams.SomeSpecialTeam
	end, {
		MapName = "TeamMap",
		MapDuration = 20,
	})
	```
]=]
function ServerComm:CreateProperty(name: string, initialValue: any, inboundMiddleware: Types.ServerMiddleware?, outboundMiddleware: Types.ServerMiddleware?)
	return Comm.CreateProperty(self._instancesFolder, name, initialValue, inboundMiddleware, outboundMiddleware)
end

--[=[
	Destroy the ServerComm object.
]=]
function ServerComm:Destroy()
	self._instancesFolder:Destroy()
end

return ServerComm
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="319">
              <Properties>
                <string name="Name">Types</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezUwOUJGNEVCLTUyQzItNDMyMi1CNTM1LTk4MDA5NEQ1Q0U5NX0=]]></BinaryString>
                <string name="Source"><![CDATA[-- Types
-- Stephen Leitnick
-- December 20, 2021


export type Args = {
	n: number,
	[any]: any,
}

export type FnBind = (Instance, ...any) -> ...any

export type ServerMiddlewareFn = (Instance, Args) -> (boolean, ...any)
export type ServerMiddleware = {ServerMiddlewareFn}

export type ClientMiddlewareFn = (Args) -> (boolean, ...any)
export type ClientMiddleware = {ClientMiddlewareFn}

return nil
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="320">
              <Properties>
                <string name="Name">Util</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0E5MUU3RTE4LUYyNjMtNDk3NS1CQjVFLTU3MjA1RjVCRTBENn0=]]></BinaryString>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Option = require(script.Parent.Parent.Option)

local Util = {}

Util.IsServer = RunService:IsServer()
Util.WaitForChildTimeout = 60
Util.DefaultCommFolderName = "__comm__"
Util.None = newproxy()

function Util.GetCommSubFolder(parent: Instance, subFolderName: string): Option.Option
	local subFolder: Instance = nil
	if Util.IsServer then
		subFolder = parent:FindFirstChild(subFolderName)
		if not subFolder then
			subFolder = Instance.new("Folder")
			subFolder.Name = subFolderName
			subFolder.Parent = parent
		end
	else
		subFolder = parent:WaitForChild(subFolderName, Util.WaitForChildTimeout)
	end
	return Option.Wrap(subFolder)
end

return Util
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="321">
          <Properties>
            <string name="Name">sleitnick_component@2.4.5</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="322">
            <Properties>
              <string name="Name">Promise</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0RGMThEMTM1LUMyOEUtNDIwQy1BRDJGLTM1Q0ZCNEEyNjc5Rn0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["evaera_promise@4.0.0"]["promise"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="323">
            <Properties>
              <string name="Name">Signal</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0RCQkM2RjdDLTA3QkEtNEE5Ni1CODVELUJDNzRDNTYyOTM0Q30=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_signal@1.1.0"]["signal"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="324">
            <Properties>
              <string name="Name">Symbol</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezYzMzI2NTUxLTgwODItNDAyQS1BQzNDLTIxRjU0MTVFRkZDQn0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_symbol@2.0.0"]["symbol"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="325">
            <Properties>
              <string name="Name">Trove</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezY4MzI4QjUwLTUzQzQtNENCRC04MzkwLUZFNzU1Q0VEMzFGNn0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_trove@0.4.0"]["trove"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="326">
            <Properties>
              <string name="Name">component</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0Q1QkY0RUVGLUE1OUUtNDJGMi1BNDQ0LTVEMTA0M0Y5NzU3Nn0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Component
-- Stephen Leitnick
-- November 26, 2021


type AncestorList = {Instance}

--[=[
	@type ExtensionFn (component) -> ()
	@within Component
]=]
type ExtensionFn = (any) -> ()

--[=[
	@type ExtensionShouldFn (component) -> boolean
	@within Component
]=]
type ExtensionShouldFn = (any) -> boolean


--[=[
	@interface Extension
	@within Component
	.ShouldExtend ExtensionShouldFn?
	.ShouldConstruct ExtensionShouldFn?
	.Constructing ExtensionFn?
	.Constructed ExtensionFn?
	.Starting ExtensionFn?
	.Started ExtensionFn?
	.Stopping ExtensionFn?
	.Stopped ExtensionFn?

	An extension allows the ability to extend the behavior of
	components. This is useful for adding injection systems or
	extending the behavior of components by wrapping around
	component lifecycle methods.

	The `ShouldConstruct` function can be used to indicate
	if the component should actually be created. This must
	return `true` or `false`. A component with multiple
	`ShouldConstruct` extension functions must have them _all_
	return `true` in order for the component to be constructed.
	The `ShouldConstruct` function runs _before_ all other
	extension functions and component lifecycle methods.

	The `ShouldExtend` function can be used to indicate if
	the extension itself should be used. This can be used in
	order to toggle an extension on/off depending on whatever
	logic is appropriate. If no `ShouldExtend` function is
	provided, the extension will always be used if provided
	as an extension to the component.

	As an example, an extension could be created to simply log
	when the various lifecycle stages run on the component:

	```lua
	local Logger = {}
	function Logger.Constructing(component) print("Constructing", component) end
	function Logger.Constructed(component) print("Constructed", component) end
	function Logger.Starting(component) print("Starting", component) end
	function Logger.Started(component) print("Started", component) end
	function Logger.Stopping(component) print("Stopping", component) end
	function Logger.Stopped(component) print("Stopped", component) end

	local MyComponent = Component.new({Tag = "MyComponent", Extensions = {Logger}})
	```

	Sometimes it is useful for an extension to control whether or
	not a component should be constructed. For instance, if a
	component on the client should only be instantiated for the
	local player, an extension might look like this, assuming the
	instance has an attribute linking it to the player's UserId:
	```lua
	local player = game:GetService("Players").LocalPlayer

	local OnlyLocalPlayer = {}
	function OnlyLocalPlayer.ShouldConstruct(component)
		local ownerId = component.Instance:GetAttribute("OwnerId")
		return ownerId == player.UserId
	end

	local MyComponent = Component.new({Tag = "MyComponent", Extensions = {OnlyLocalPlayer}})
	```

	It can also be useful for an extension itself to turn on/off
	depending on various contexts. For example, let's take the
	Logger from the first example, and only use that extension
	if the bound instance has a Log attribute set to `true`:
	```lua
	function Logger.ShouldExtend(component)
		return component.Instance:GetAttribute("Log") == true
	end
	```
]=]
type Extension = {
	ShouldExtend: ExtensionShouldFn?,
	ShouldConstruct: ExtensionShouldFn?,
	Constructing: ExtensionFn?,
	Constructed: ExtensionFn?,
	Starting: ExtensionFn?,
	Started: ExtensionFn?,
	Stopping: ExtensionFn?,
	Stopped: ExtensionFn?,
}

--[=[
	@interface ComponentConfig
	@within Component
	.Tag string -- CollectionService tag to use
	.Ancestors {Instance}? -- Optional array of ancestors in which components will be started
	.Extensions {Extension}? -- Optional array of extension objects

	Component configuration passed to `Component.new`.

	- If no Ancestors option is included, it defaults to `{workspace, game.Players}`.
	- If no Extensions option is included, it defaults to a blank table `{}`.
]=]
type ComponentConfig = {
	Tag: string,
	Ancestors: AncestorList?,
	Extensions: {Extension}?,
}

--[=[
	@within Component
	@prop Started Signal
	@tag Event
	@tag Component Class

	Fired when a new instance of a component is started.

	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})

	MyComponent.Started:Connect(function(component) end)
	```
]=]

--[=[
	@within Component
	@prop Stopped Signal
	@tag Event
	@tag Component Class

	Fired when an instance of a component is stopped.

	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})

	MyComponent.Stopped:Connect(function(component) end)
	```
]=]

--[=[
	@tag Component Instance
	@within Component
	@prop Instance Instance
	
	A reference back to the _Roblox_ instance from within a _component_ instance. When
	a component instance is created, it is bound to a specific Roblox instance, which
	will always be present through the `Instance` property.

	```lua
	MyComponent.Started:Connect(function(component)
		local robloxInstance: Instance = component.Instance
		print("Component is bound to " .. robloxInstance:GetFullName())
	end)
	```
]=]

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)
local Symbol = require(script.Parent.Symbol)
local Trove = require(script.Parent.Trove)
local Promise = require(script.Parent.Promise)

local IS_SERVER = RunService:IsServer()
local DEFAULT_ANCESTORS = {workspace, game:GetService("Players")}
local DEFAULT_TIMEOUT = 60

-- Symbol keys:
local KEY_ANCESTORS = Symbol("Ancestors")
local KEY_INST_TO_COMPONENTS = Symbol("InstancesToComponents")
local KEY_LOCK_CONSTRUCT = Symbol("LockConstruct")
local KEY_COMPONENTS = Symbol("Components")
local KEY_TROVE = Symbol("Trove")
local KEY_EXTENSIONS = Symbol("Extensions")
local KEY_ACTIVE_EXTENSIONS = Symbol("ActiveExtensions")
local KEY_STARTED = Symbol("Started")


local renderId = 0
local function NextRenderName(): string
	renderId += 1
	return "ComponentRender" .. tostring(renderId)
end


local function InvokeExtensionFn(component, fnName: string)
	for _,extension in ipairs(component[KEY_ACTIVE_EXTENSIONS]) do
		local fn = extension[fnName]
		if type(fn) == "function" then
			fn(component)
		end
	end
end


local function ShouldConstruct(component): boolean
	for _,extension in ipairs(component[KEY_ACTIVE_EXTENSIONS]) do
		local fn = extension.ShouldConstruct
		if type(fn) == "function" then
			local shouldConstruct = fn(component)
			if not shouldConstruct then
				return false
			end
		end
	end
	return true
end


local function GetActiveExtensions(component, extensionList)
	local activeExtensions = table.create(#extensionList)
	local allActive = true
	for _,extension in ipairs(extensionList) do
		local fn = extension.ShouldExtend
		local shouldExtend = type(fn) ~= "function" or not not fn(component)
		if shouldExtend then
			table.insert(activeExtensions, extension)
		else
			allActive = false
		end
	end
	return if allActive then extensionList else activeExtensions
end


--[=[
	@class Component

	Bind components to Roblox instances using the Component class and CollectionService tags.

	To avoid confusion of terms:
	- `Component` refers to this module.
	- `Component Class` (e.g. `MyComponent` through this documentation) refers to a class created via `Component.new`
	- `Component Instance` refers to an instance of a component class.
	- `Roblox Instance` refers to the Roblox instance to which the component instance is bound.

	Methods and properties are tagged with the above terms to help clarify the level at which they are used.
]=]
local Component = {}
Component.__index = Component


--[=[
	@tag Component
	@param config ComponentConfig
	@return ComponentClass

	Create a new custom Component class.

	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})
	```

	A full example might look like this:

	```lua
	local MyComponent = Component.new({
		Tag = "MyComponent",
		Ancestors = {workspace},
		Extensions = {Logger}, -- See Logger example within the example for the Extension type
	})

	local AnotherComponent = require(somewhere.AnotherComponent)

	-- Optional if UpdateRenderStepped should use BindToRenderStep:
	MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value

	function MyComponent:Construct()
		self.MyData = "Hello"
	end

	function MyComponent:Start()
		local another = self:GetComponent(AnotherComponent)
		another:DoSomething()
	end

	function MyComponent:Stop()
		self.MyData = "Goodbye"
	end

	function MyComponent:HeartbeatUpdate(dt)
	end

	function MyComponent:SteppedUpdate(dt)
	end
	
	function MyComponent:RenderSteppedUpdate(dt)
	end
	```
]=]
function Component.new(config: ComponentConfig)
	local customComponent = {}
	customComponent.__index = customComponent
	customComponent.__tostring = function()
		return "Component<" .. config.Tag .. ">"
	end
	customComponent[KEY_ANCESTORS] = config.Ancestors or DEFAULT_ANCESTORS
	customComponent[KEY_INST_TO_COMPONENTS] = {}
	customComponent[KEY_COMPONENTS] = {}
	customComponent[KEY_LOCK_CONSTRUCT] = {}
	customComponent[KEY_TROVE] = Trove.new()
	customComponent[KEY_EXTENSIONS] = config.Extensions or {}
	customComponent[KEY_STARTED] = false
	customComponent.Tag = config.Tag
	customComponent.Started = customComponent[KEY_TROVE]:Construct(Signal)
	customComponent.Stopped = customComponent[KEY_TROVE]:Construct(Signal)
	setmetatable(customComponent, Component)
	customComponent:_setup()
	return customComponent
end


function Component:_instantiate(instance: Instance)
	local component = setmetatable({}, self)
	component.Instance = instance
	component[KEY_ACTIVE_EXTENSIONS] = GetActiveExtensions(component, self[KEY_EXTENSIONS])
	if not ShouldConstruct(component) then
		return nil
	end
	InvokeExtensionFn(component, "Constructing")
	if type(component.Construct) == "function" then
		component:Construct()
	end
	InvokeExtensionFn(component, "Constructed")
	return component
end


function Component:_setup()
	
	local watchingInstances = {}
	
	local function StartComponent(component)
		InvokeExtensionFn(component, "Starting")
		component:Start()
		InvokeExtensionFn(component, "Started")
		local hasHeartbeatUpdate = typeof(component.HeartbeatUpdate) == "function"
		local hasSteppedUpdate = typeof(component.SteppedUpdate) == "function"
		local hasRenderSteppedUpdate = typeof(component.RenderSteppedUpdate) == "function"
		if hasHeartbeatUpdate then
			component._heartbeatUpdate = RunService.Heartbeat:Connect(function(dt)
				component:HeartbeatUpdate(dt)
			end)
		end
		if hasSteppedUpdate then
			component._steppedUpdate = RunService.Stepped:Connect(function(_, dt)
				component:SteppedUpdate(dt)
			end)
		end
		if hasRenderSteppedUpdate and not IS_SERVER then
			if component.RenderPriority then
				component._renderName = NextRenderName()
				RunService:BindToRenderStep(component._renderName, component.RenderPriority, function(dt)
					component:RenderSteppedUpdate(dt)
				end)
			else
				component._renderSteppedUpdate = RunService.RenderStepped:Connect(function(dt)
					component:RenderSteppedUpdate(dt)
				end)
			end
		end
		component[KEY_STARTED] = true
		self.Started:Fire(component)
	end
	
	local function StopComponent(component)
		if component._heartbeatUpdate then
			component._heartbeatUpdate:Disconnect()
		end
		if component._steppedUpdate then
			component._steppedUpdate:Disconnect()
		end
		if component._renderSteppedUpdate then
			component._renderSteppedUpdate:Disconnect()
		elseif component._renderName then
			RunService:UnbindFromRenderStep(component._renderName)
		end
		InvokeExtensionFn(component, "Stopping")
		component:Stop()
		InvokeExtensionFn(component, "Stopped")
		self.Stopped:Fire(component)
	end

	local function SafeConstruct(instance, id)
		if self[KEY_LOCK_CONSTRUCT][instance] ~= id then
			return nil
		end
		local component = self:_instantiate(instance)
		if self[KEY_LOCK_CONSTRUCT][instance] ~= id then
			return nil
		end
		return component
	end
	
	local function TryConstructComponent(instance)
		if self[KEY_INST_TO_COMPONENTS][instance] then return end
		local id = self[KEY_LOCK_CONSTRUCT][instance] or 0
		id += 1
		self[KEY_LOCK_CONSTRUCT][instance] = id
		task.defer(function()
			local component = SafeConstruct(instance, id)
			if not component then
				return
			end
			self[KEY_INST_TO_COMPONENTS][instance] = component
			table.insert(self[KEY_COMPONENTS], component)
			task.defer(function()
				if self[KEY_INST_TO_COMPONENTS][instance] == component then
					StartComponent(component)
				end
			end)
		end)
	end
	
	local function TryDeconstructComponent(instance)
		local component = self[KEY_INST_TO_COMPONENTS][instance]
		if not component then return end
		self[KEY_INST_TO_COMPONENTS][instance] = nil
		self[KEY_LOCK_CONSTRUCT][instance] = nil
		local components = self[KEY_COMPONENTS]
		local index = table.find(components, component)
		if index then
			local n = #components
			components[index] = components[n]
			components[n] = nil
		end
		if component[KEY_STARTED] then
			task.spawn(StopComponent, component)
		end
	end
	
	local function StartWatchingInstance(instance)
		if watchingInstances[instance] then return end
		local function IsInAncestorList(): boolean
			for _,parent in ipairs(self[KEY_ANCESTORS]) do
				if instance:IsDescendantOf(parent) then
					return true
				end
			end
			return false
		end
		local ancestryChangedHandle = self[KEY_TROVE]:Connect(instance.AncestryChanged, function(_, parent)
			if parent and IsInAncestorList() then
				TryConstructComponent(instance)
			else
				TryDeconstructComponent(instance)
			end
		end)
		watchingInstances[instance] = ancestryChangedHandle
		if IsInAncestorList() then
			TryConstructComponent(instance)
		end
	end
	
	local function InstanceTagged(instance: Instance)
		StartWatchingInstance(instance)
	end
	
	local function InstanceUntagged(instance: Instance)
		local watchHandle = watchingInstances[instance]
		if watchHandle then
			watchHandle:Disconnect()
			watchingInstances[instance] = nil
		end
		TryDeconstructComponent(instance)
	end
	
	self[KEY_TROVE]:Connect(CollectionService:GetInstanceAddedSignal(self.Tag), InstanceTagged)
	self[KEY_TROVE]:Connect(CollectionService:GetInstanceRemovedSignal(self.Tag), InstanceUntagged)
	
	local tagged = CollectionService:GetTagged(self.Tag)
	for _,instance in ipairs(tagged) do
		task.defer(InstanceTagged, instance)
	end
	
end


--[=[
	@tag Component Class
	@return {Component}
	Gets a table array of all existing component objects. For example,
	if there was a component class linked to the "MyComponent" tag,
	and three Roblox instances in your game had that same tag, then
	calling `GetAll` would return the three component instances.

	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})

	-- ...

	local components = MyComponent:GetAll()
	for _,component in ipairs(components) do
		component:DoSomethingHere()
	end
	```
]=]
function Component:GetAll()
	return self[KEY_COMPONENTS]
end


--[=[
	@tag Component Class
	@return Component?

	Gets an instance of a component class from the given Roblox
	instance. Returns `nil` if not found.

	```lua
	local MyComponent = require(somewhere.MyComponent)

	local myComponentInstance = MyComponent:FromInstance(workspace.SomeInstance)
	```
]=]
function Component:FromInstance(instance: Instance)
	return self[KEY_INST_TO_COMPONENTS][instance]
end


--[=[
	@tag Component Class
	@return Promise<ComponentInstance>

	Resolves a promise once the component instance is present on a given
	Roblox instance.

	An optional `timeout` can be provided to reject the promise if it
	takes more than `timeout` seconds to resolve. If no timeout is
	supplied, `timeout` defaults to 60 seconds.

	```lua
	local MyComponent = require(somewhere.MyComponent)

	MyComponent:WaitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance)
		-- Do something with the component class
	end)
	```
]=]
function Component:WaitForInstance(instance: Instance, timeout: number?)
	local componentInstance = self:FromInstance(instance)
	if componentInstance then
		return Promise.resolve(componentInstance)
	end
	return Promise.fromEvent(self.Started, function(c)
		local match = c.Instance == instance
		if match then
			componentInstance = c
		end
		return match
	end):andThen(function()
		return componentInstance
	end):timeout(if type(timeout) == "number" then timeout else DEFAULT_TIMEOUT)
end


--[=[
	@tag Component Class
	`Construct` is called before the component is started, and should be used
	to construct the component instance.

	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})

	function MyComponent:Construct()
		self.SomeData = 32
		self.OtherStuff = "HelloWorld"
	end
	```
]=]
function Component:Construct()
end


--[=[
	@tag Component Class
	`Start` is called when the component is started. At this point in time, it
	is safe to grab other components also bound to the same instance.

	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})
	local AnotherComponent = require(somewhere.AnotherComponent)

	function MyComponent:Start()
		-- e.g., grab another component:
		local another = self:GetComponent(AnotherComponent)
	end
	```
]=]
function Component:Start()
end


--[=[
	@tag Component Class
	`Stop` is called when the component is stopped. This occurs either when the
	bound instance is removed from one of the whitelisted ancestors _or_ when
	the matching tag is removed from the instance. This also means that the
	instance _might_ be destroyed, and thus it is not safe to continue using
	the bound instance (e.g. `self.Instance`) any longer.

	This should be used to clean up the component.

	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})

	function MyComponent:Stop()
		self.SomeStuff:Destroy()
	end
	```
]=]
function Component:Stop()
end


--[=[
	@tag Component Instance
	@param componentClass ComponentClass
	@return Component?

	Retrieves another component instance bound to the same
	Roblox instance.

	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})
	local AnotherComponent = require(somewhere.AnotherComponent)

	function MyComponent:Start()
		local another = self:GetComponent(AnotherComponent)
	end
	```
]=]
function Component:GetComponent(componentClass)
	return componentClass[KEY_INST_TO_COMPONENTS][self.Instance]
end


--[=[
	@tag Component Class
	@function HeartbeatUpdate
	@param dt number
	@within Component

	If this method is present on a component, then it will be
	automatically connected to `RunService.Heartbeat`.

	:::note Method
	This is a method, not a function. This is a limitation
	of the documentation tool which should be fixed soon.
	:::
	
	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})
	
	function MyComponent:HeartbeatUpdate(dt)
	end
	```
]=]
--[=[
	@tag Component Class
	@function SteppedUpdate
	@param dt number
	@within Component

	If this method is present on a component, then it will be
	automatically connected to `RunService.Stepped`.

	:::note Method
	This is a method, not a function. This is a limitation
	of the documentation tool which should be fixed soon.
	:::
	
	```lua
	local MyComponent = Component.new({Tag = "MyComponent"})
	
	function MyComponent:SteppedUpdate(dt)
	end
	```
]=]
--[=[
	@tag Component Class
	@function RenderSteppedUpdate
	@param dt number
	@within Component
	@client

	If this method is present on a component, then it will be
	automatically connected to `RunService.RenderStepped`. If
	the `[Component].RenderPriority` field is found, then the
	component will instead use `RunService:BindToRenderStep()`
	to bind the function.

	:::note Method
	This is a method, not a function. This is a limitation
	of the documentation tool which should be fixed soon.
	:::
	
	```lua
	-- Example that uses `RunService.RenderStepped` automatically:

	local MyComponent = Component.new({Tag = "MyComponent"})
	
	function MyComponent:RenderSteppedUpdate(dt)
	end
	```
	```lua
	-- Example that uses `RunService:BindToRenderStep` automatically:
	
	local MyComponent = Component.new({Tag = "MyComponent"})

	-- Defining a RenderPriority will force the component to use BindToRenderStep instead
	MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value
	
	function MyComponent:RenderSteppedUpdate(dt)
	end
	```
]=]


function Component:Destroy()
	self[KEY_TROVE]:Destroy()
end


return Component
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="327">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezRFRjc5REYyLTAzOUItNDgxRC05MkMyLTBCQzBEMjQzQ0JGQ30=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local Component = require(script.Parent)

	local CollectionService = game:GetService("CollectionService")
	local RunService = game:GetService("RunService")

	local TAG = "__KnitTestComponent__"

	local taggedInstanceFolder

	local function CreateTaggedInstance()
		local folder = Instance.new("Folder")
		CollectionService:AddTag(folder, TAG)
		folder.Name = "ComponentTest"
		folder.Archivable = false
		folder.Parent = taggedInstanceFolder
		return folder
	end

	local ExtensionTest = {}
	function ExtensionTest.ShouldConstruct(_component)
		return true
	end
	function ExtensionTest.Constructing(component)
		component.Data = "a"
		component.DidHeartbeat = false
		component.DidStepped = false
		component.DidRenderStepped = false
	end
	function ExtensionTest.Constructed(component)
		component.Data ..= "c"
	end
	function ExtensionTest.Starting(component)
		component.Data ..= "d"
	end
	function ExtensionTest.Started(component)
		component.Data ..= "f"
	end
	function ExtensionTest.Stopping(component)
		component.Data ..= "g"
	end
	function ExtensionTest.Stopped(component)
		component.Data ..= "i"
	end

	local TestComponentMain = Component.new({
		Tag = TAG,
		Ancestors = {workspace, game:GetService("Lighting")},
		Extensions = {ExtensionTest}
	})

	local AnotherComponent = Component.new({Tag = TAG})
	function AnotherComponent:GetData()
		return true
	end

	function TestComponentMain:Construct()
		self.Data ..= "b"
	end

	function TestComponentMain:Start()
		self.Another = self:GetComponent(AnotherComponent)
		self.Data ..= "e"
	end

	function TestComponentMain:Stop()
		self.Data ..= "h"
	end

	function TestComponentMain:HeartbeatUpdate(_dt)
		self.DidHeartbeat = true
	end

	function TestComponentMain:SteppedUpdate(_dt)
		self.DidStepped = true
	end

	function TestComponentMain:RenderSteppedUpdate(_dt)
		self.DidRenderStepped = true
	end

	beforeAll(function()
		taggedInstanceFolder = Instance.new("Folder")
		taggedInstanceFolder.Name = "KnitComponentTest"
		taggedInstanceFolder.Archivable = false
		taggedInstanceFolder.Parent = workspace
	end)

	afterEach(function()
		taggedInstanceFolder:ClearAllChildren()
	end)

	afterAll(function()
		taggedInstanceFolder:Destroy()
		TestComponentMain:Destroy()
	end)

	describe("Component", function()

		it("should capture start and stop events", function()
			local didStart = 0
			local didStop = 0
			local started = TestComponentMain.Started:Connect(function()
				didStart += 1
			end)
			local stopped = TestComponentMain.Stopped:Connect(function()
				didStop += 1
			end)
			local instance = CreateTaggedInstance()
			task.wait()
			instance:Destroy()
			task.wait()
			started:Disconnect()
			stopped:Disconnect()
			expect(didStart).to.equal(1)
			expect(didStop).to.equal(1)
		end)

		it("should be able to get component from the instance", function()
			local instance = CreateTaggedInstance()
			task.wait()
			local component = TestComponentMain:FromInstance(instance)
			expect(component).to.be.ok()
		end)

		it("should be able to get all component instances existing", function()
			local numComponents = 3
			local instances = table.create(numComponents)
			for i = 1,numComponents do
				local instance = CreateTaggedInstance()
				instances[i] = instance
			end
			task.wait()
			local components = TestComponentMain:GetAll()
			expect(components).to.be.a("table")
			expect(#components).to.equal(numComponents)
			for _,c in ipairs(components) do
				expect(table.find(instances, c.Instance)).to.be.ok()
			end
		end)

		it("should call lifecycle methods and extension functions", function()
			local instance = CreateTaggedInstance()
			task.wait(0.2)
			local component = TestComponentMain:FromInstance(instance)
			expect(component).to.be.ok()
			expect(component.Data).to.equal("abcdef")
			expect(component.DidHeartbeat).to.equal(true)
			expect(component.DidStepped).to.equal(RunService:IsRunning())
			expect(component.DidRenderStepped).to.never.equal(true)
			instance:Destroy()
			task.wait()
			expect(component.Data).to.equal("abcdefghi")
		end)

		it("should get another component linked to the same instance", function()
			local instance = CreateTaggedInstance()
			task.wait()
			local component = TestComponentMain:FromInstance(instance)
			expect(component).to.be.ok()
			expect(component.Another).to.be.ok()
			expect(component.Another:GetData()).to.equal(true)
		end)

		it("should use extension to decide whether or not to construct", function()

			local e1 = {c = true}
			function e1.ShouldConstruct(_component)
				return e1.c
			end

			local e2 = {c = true}
			function e2.ShouldConstruct(_component)
				return e2.c
			end

			local e3 = {c = true}
			function e3.ShouldConstruct(_component)
				return e3.c
			end

			local c1 = Component.new({Tag = TAG, Extensions = {e1}})
			local c2 = Component.new({Tag = TAG, Extensions = {e1, e2}})
			local c3 = Component.new({Tag = TAG, Extensions = {e1, e2, e3}})

			local function SetE(a, b, c)
				e1.c = a
				e2.c = b
				e3.c = c
			end

			local function Check(inst, comp, shouldExist)
				local c = comp:FromInstance(inst)
				if shouldExist then
					expect(c).to.be.ok()
				else
					expect(c).to.never.be.ok()
				end
			end

			local function CreateAndCheckAll(a, b, c)
				local instance = CreateTaggedInstance()
				task.wait()
				Check(instance, c1, a)
				Check(instance, c2, b)
				Check(instance, c3, c)
			end

			-- All green:
			SetE(true, true, true)
			CreateAndCheckAll(true, true, true)

			-- All red:
			SetE(false, false, false)
			CreateAndCheckAll(false, false, false)

			-- One red:
			SetE(true, false, true)
			CreateAndCheckAll(true, false, false)

			-- One green:
			SetE(false, false, true)
			CreateAndCheckAll(false, false, false)
			
		end)

		it("should decide whether or not to use extend", function()

			local e1 = {extend = true}
			function e1.ShouldExtend(_component)
				return e1.extend
			end
			function e1.Constructing(component)
				component.E1 = true
			end

			local e2 = {extend = true}
			function e2.ShouldExtend(_component)
				return e2.extend
			end
			function e2.Constructing(component)
				component.E2 = true
			end

			local TestComponent = Component.new({Tag = TAG, Extensions = {e1, e2}})

			local function SetAndCheck(ex1, ex2)
				e1.extend = ex1
				e2.extend = ex2
				local instance = CreateTaggedInstance()
				task.wait()
				local component = TestComponent:FromInstance(instance)
				expect(component).to.be.ok()
				if ex1 then
					expect(component.E1).to.equal(true)
				else
					expect(component.E1).to.never.be.ok()
				end
				if ex2 then
					expect(component.E2).to.equal(true)
				else
					expect(component.E2).to.never.be.ok()
				end
			end

			SetAndCheck(true, true)
			SetAndCheck(false, false)
			SetAndCheck(true, false)
			SetAndCheck(false, true)

		end)

		it("should allow yielding within construct", function()

			local CUSTOM_TAG = "CustomTag"

			local TestComponent = Component.new({Tag = CUSTOM_TAG})

			local numConstruct = 0

			function TestComponent:Construct()
				numConstruct += 1
				task.wait(0.5)
			end

			local p = Instance.new("Part")
			p.Anchored = true
			p.Parent = game:GetService("ReplicatedStorage")
			CollectionService:AddTag(p, CUSTOM_TAG)
			local newP = p:Clone()
			newP.Parent = workspace

			task.wait(0.6)

			expect(numConstruct).to.equal(1)
			p:Destroy()
			newP:Destroy()

		end)

		it("should wait for instance", function()
			local p = Instance.new("Part")
			p.Anchored = true
			p.Parent = workspace
			task.delay(0.1, function()
				CollectionService:AddTag(p, TAG)
			end)
			local success, c = TestComponentMain:WaitForInstance(p):timeout(1):await()
			expect(success).to.equal(true)
			expect(c).to.be.a("table")
			expect(c.Instance).to.equal(p)
			p:Destroy()
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="328">
          <Properties>
            <string name="Name">sleitnick_enum-list@2.0.0</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="329">
            <Properties>
              <string name="Name">enum-list</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezNFOTRCRjI2LUJDRjYtNEIxMy1BMjhELTVGODQ0NDA2ODdERX0=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict

-- EnumList
-- Stephen Leitnick
-- January 08, 2021


type EnumNames = {string}

--[=[
	@interface EnumItem
	.Name string
	.Value number
	.EnumType EnumList
	@within EnumList
]=]
type EnumItem = {
	Name: string,
	Value: number,
	EnumType: any,
}

local LIST_KEY = newproxy()
local NAME_KEY = newproxy()

local function CreateEnumItem(name: string, value: number, enum: any): EnumItem
	local enumItem = {
		Name = name;
		Value = value;
		EnumType = enum;
	}
	table.freeze(enumItem)
	return enumItem
end

--[=[
	@class EnumList
	Defines a new Enum.
]=]
local EnumList = {}
EnumList.__index = EnumList


--[=[
	@param name string
	@param enums {string}
	@return EnumList
	Constructs a new EnumList.

	```lua
	local directions = EnumList.new("Directions", {
		"Up",
		"Down",
		"Left",
		"Right",
	})

	local direction = directions.Up
	```
]=]
function EnumList.new(name: string, enums: EnumNames)
	assert(type(name) == "string", "Name string required")
	assert(type(enums) == "table", "Enums table required")
	local self = setmetatable({}, EnumList)
	self[LIST_KEY] = {}
	self[NAME_KEY] = name
	for i,enumName in ipairs(enums) do
		assert(type(enumName) == "string", "Enum name must be a string")
		local enumItem = CreateEnumItem(enumName, i, self)
		self[enumName] = enumItem
		table.insert(self[LIST_KEY], enumItem)
	end
	table.freeze(self)
	return self
end


--[=[
	@param obj any
	@return boolean
	Returns `true` if `obj` belongs to the EnumList.
]=]
function EnumList:BelongsTo(obj: any): boolean
	return type(obj) == "table" and obj.EnumType == self
end


--[=[
	Returns an array of all enum items.
	@return {EnumItem}
	@since v2.0.0
]=]
function EnumList:GetEnumItems()
	return self[LIST_KEY]
end


--[=[
	Get the name of the enum.
	@return string
	@since v2.0.0
]=]
function EnumList:GetName()
	return self[NAME_KEY]
end


export type EnumList = typeof(EnumList.new("", {""}))


return EnumList
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="330">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezMwMjExODIzLUVFMTAtNDMyRi1CMzFBLTVBNDlFODQ1NDM0Mn0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local EnumList = require(script.Parent)

	describe("Constructor", function()

		it("should create a new enumlist", function()
			expect(function()
				EnumList.new("Test", {"ABC", "XYZ"})
			end).never.to.throw()
		end)

		it("should fail to create a new enumlist with no name", function()
			expect(function()
				EnumList.new(nil, {"ABC", "XYZ"})
			end).to.throw()
		end)

		it("should fail to create a new enumlist with no enums", function()
			expect(function()
				EnumList.new("Test")
			end).to.throw()
		end)

		it("should fail to create a new enumlist with non string enums", function()
			expect(function()
				EnumList.new("Test", {true, false, 32, "ABC"})
			end).to.throw()
		end)

	end)

	describe("Access", function()

		it("should be able to access enum items", function()
			local test = EnumList.new("Test", {"ABC", "XYZ"})
			expect(function()
				local _item = test.ABC
			end).never.to.throw()
			expect(test:BelongsTo(test.ABC)).to.equal(true)
		end)

		it("should throw if trying to modify the enumlist", function()
			local test = EnumList.new("Test", {"ABC", "XYZ"})
			expect(function()
				test.Hello = 32
			end).to.throw()
			expect(function()
				test.ABC = 32
			end).to.throw()
		end)

		it("should throw if trying to modify an enumitem", function()
			local test = EnumList.new("Test", {"ABC", "XYZ"})
			expect(function()
				local abc = test.ABC
				abc.XYZ = 32
			end).to.throw()
			expect(function()
				local abc = test.ABC
				abc.Name = "NewName"
			end).to.throw()
		end)

		it("should get the name", function()
			local test = EnumList.new("Test", {"ABC", "XYZ"})
			local name = test:GetName()
			expect(name).to.equal("Test")
		end)

	end)

	describe("Get Items", function()

		it("should be able to get all enum items", function()
			local test = EnumList.new("Test", {"ABC", "XYZ"})
			local items = test:GetEnumItems()
			expect(items).to.be.a("table")
			expect(#items).to.equal(2)
			for i,enumItem in ipairs(items) do
				expect(enumItem).to.be.a("table")
				expect(enumItem.Name).to.be.a("string")
				expect(enumItem.Value).to.be.a("number")
				expect(enumItem.Value).to.equal(i)
				expect(enumItem.EnumType).to.equal(test)
			end
		end)
	
	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="331">
          <Properties>
            <string name="Name">sleitnick_input@1.3.3</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="332">
            <Properties>
              <string name="Name">EnumList</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezQ2RjlFQUE5LUYwRDEtNEM5OS1BMzg5LTgwNUJERUJFMUI3MH0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_enum-list@2.0.0"]["enum-list"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="333">
            <Properties>
              <string name="Name">Signal</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezZGODRDMjhDLTFFMUEtNDU0Ny1BMENBLTFBRTU3RjUyNjMwQ30=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_signal@1.1.0"]["signal"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="334">
            <Properties>
              <string name="Name">Trove</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezFEOEIzODY1LTM5NTAtNEYxNS04RjgwLTEyNjcwRkU1MEIyQn0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_trove@0.4.0"]["trove"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="335">
            <Properties>
              <string name="Name">input</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0NCMUYzODgyLTlDQjItNDM0Qy1BOEY2LTMyMjcwNTU5MjUyM30=]]></BinaryString>
              <string name="Source"><![CDATA[-- Input
-- Stephen Leitnick
-- October 10, 2021

--[=[
	@class Input

	The Input module provides access to various user input classes.

	- [PreferredInput](/api/PreferredInput)
	- [Mouse](/api/Mouse)
	- [Keyboard](/api/Keyboard)
	- [Touch](/api/Touch)
	- [Gamepad](/api/Gamepad)

	```lua
	local Input = require(packages.Input)

	local PreferredInput = Input.PreferredInput
	local Mouse = Input.Mouse
	local Keyboard = Input.Keyboard
	local Touch = Input.Touch
	local Gamepad = Input.Gamepad
	```
]=]
local Input = {
	PreferredInput = require(script.PreferredInput),
	Mouse = require(script.Mouse),
	Keyboard = require(script.Keyboard),
	Touch = require(script.Touch),
	Gamepad = require(script.Gamepad),
}

return Input
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="336">
              <Properties>
                <string name="Name">Gamepad</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0Y0RTUwMDEzLTBBQUEtNEY2OC1CMzY1LTYzQkIzQzkxOTIwQn0=]]></BinaryString>
                <string name="Source"><![CDATA[-- Gamepad
-- Stephen Leitnick
-- December 23, 2021


local Trove = require(script.Parent.Parent.Trove)
local Signal = require(script.Parent.Parent.Signal)

local UserInputService = game:GetService("UserInputService")
local HapticService = game:GetService("HapticService")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")

local function ApplyDeadzone(value: number, threshold: number): number
	if math.abs(value) < threshold then
		return 0
	end
	return ((math.abs(value) - threshold) / (1 - threshold)) * math.sign(value)
end

local function GetActiveGamepad(): Enum.UserInputType?
	local activeGamepad = nil
	local navGamepads = UserInputService:GetNavigationGamepads()
	if #navGamepads > 1 then
		for _,navGamepad in ipairs(navGamepads) do
			if activeGamepad == nil or navGamepad.Value < activeGamepad.Value then
				activeGamepad = navGamepad
			end
		end
	else
		local connectedGamepads = UserInputService:GetConnectedGamepads()
		for _,connectedGamepad in ipairs(connectedGamepads) do
			if activeGamepad == nil or connectedGamepad.Value < activeGamepad.Value then
				activeGamepad = connectedGamepad
			end
		end
	end
	if activeGamepad and not UserInputService:GetGamepadConnected(activeGamepad) then
		activeGamepad = nil
	end
	return activeGamepad
end

local function HeartbeatDelay(duration: number, callback: () -> nil): RBXScriptConnection
	local start = time()
	local connection
	connection = RunService.Heartbeat:Connect(function()
		local elapsed = time() - start
		if elapsed >= duration then
			connection:Disconnect()
			callback()
		end
	end)
	return connection
end

--[=[
	@class Gamepad
	@client

	The Gamepad class is part of the Input package.

	```lua
	local Gamepad = require(packages.Input).Gamepad

	local gamepad = Gamepad.new()
	```
]=]
local Gamepad = {}
Gamepad.__index = Gamepad

--[=[
	@within Gamepad
	@prop ButtonDown Signal<(button: Enum.KeyCode, processed: boolean)>
	@readonly
	The ButtonDown signal fires when a gamepad button is pressed
	down. The pressed KeyCode is passed to the signal, along with
	whether or not the event was processed.

	```lua
	gamepad.ButtonDown:Connect(function(button: Enum.KeyCode, processed: boolean)
		print("Button down", button, processed)
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop ButtonUp Signal<(button: Enum.KeyCode, processed: boolean)>
	@readonly
	The ButtonUp signal fires when a gamepad button is released.
	The released KeyCode is passed to the signal, along with
	whether or not the event was processed.

	```lua
	gamepad.ButtonUp:Connect(function(button: Enum.KeyCode, processed: boolean)
		print("Button up", button, processed)
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop Connected Signal
	@readonly
	Fires when the gamepad is connected. This will _not_ fire if the
	active gamepad is switched. To detect switching to different
	active gamepads, use the `GamepadChanged` signal.

	There is also a `gamepad:IsConnected()` method.

	```lua
	gamepad.Connected:Connect(function()
		print("Connected")
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop Disconnected Signal
	@readonly
	Fires when the gamepad is disconnected. This will _not_ fire if the
	active gamepad is switched. To detect switching to different
	active gamepads, use the `GamepadChanged` signal.

	There is also a `gamepad:IsConnected()` method.

	```lua
	gamepad.Disconnected:Connect(function()
		print("Disconnected")
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop GamepadChanged Signal<gamepad: Enum.UserInputType>
	@readonly
	Fires when the active gamepad switches. Internally, the gamepad
	object will always wrap around the active gamepad, so nothing
	needs to be changed.

	```lua
	gamepad.GamepadChanged:Connect(function(newGamepad: Enum.UserInputType)
		print("Active gamepad changed to:", newGamepad)
	end)
	```
]=]

--[=[
	@within Gamepad
	@prop DefaultDeadzone number

	:::info Default
	Defaults to `0.05`
	:::

	The default deadzone used for trigger and thumbstick
	analog readings. It is usually best to set this to
	a small value, or allow players to set this option
	themselves in an in-game settings menu.

	The `GetThumbstick` and `GetTrigger` methods also allow
	a deadzone value to be passed in, which overrides this
	value.
]=]

--[=[
	@within Gamepad
	@prop SupportsVibration boolean
	@readonly
	Flag to indicate if the currently-active gamepad supports
	haptic motor vibration.

	It is safe to use the motor methods on the gamepad without
	checking this value, but nothing will happen if the motors
	are not supported.
]=]

--[=[
	@within Gamepad
	@prop State GamepadState
	@readonly
	Maps KeyCodes to the matching InputObjects within the gamepad.
	These can be used to directly read the current input state of
	a given part of the gamepad. For most cases, the given methods
	and properties of `Gamepad` should make use of this table quite
	rare, but it is provided for special use-cases that might occur.

	:::note Do Not Cache
	These state objects will change if the active gamepad changes.
	Because a player might switch up gamepads during playtime, it cannot
	be assumed that these state objects will always be the same. Thus
	they should be accessed directly from this `State` table anytime they
	need to be used.
	:::

	```lua
	local leftThumbstick = gamepad.State[Enum.KeyCode.Thumbstick1]
	print(leftThumbstick.Position)
	-- It would be better to use gamepad:GetThumbstick(Enum.KeyCode.Thumbstick1),
	-- but this is just an example of direct state access.
	```
]=]

--[=[
	@within Gamepad
	@type GamepadState {[Enum.KeyCode]: InputObject}
]=]


--[=[
	@param gamepad Enum.UserInputType?
	@return Gamepad
	Constructs a gamepad object.

	If no gamepad UserInputType is provided, this object will always wrap
	around the currently-active gamepad, even if it changes. In most cases
	where input is needed from just the primary gamepad used by the player,
	leaving the `gamepad` argument blank is preferred.

	Only include the `gamepad` argument when it is necessary to hard-lock
	the object to a specific gamepad input type.

	```lua
	-- In most cases, construct the gamepad as such:
	local gamepad = Gamepad.new()

	-- If the exact UserInputType gamepad is needed, pass it as such:
	local gamepad = Gamepad.new(Enum.UserInputType.Gamepad1)
	```
]=]
function Gamepad.new(gamepad: Enum.UserInputType?)
	local self = setmetatable({}, Gamepad)
	self._trove = Trove.new()
	self._gamepadTrove = self._trove:Construct(Trove)
	self.ButtonDown = self._trove:Construct(Signal)
	self.ButtonUp = self._trove:Construct(Signal)
	self.Connected = self._trove:Construct(Signal)
	self.Disconnected = self._trove:Construct(Signal)
	self.GamepadChanged = self._trove:Construct(Signal)
	self.DefaultDeadzone = 0.05
	self.SupportsVibration = false
	self.State = {}
	self:_setupGamepad(gamepad)
	self:_setupMotors()
	return self
end


function Gamepad:_setupActiveGamepad(gamepad: Enum.UserInputType?)

	local lastGamepad = self._gamepad
	if gamepad == lastGamepad then return end

	self._gamepadTrove:Clean()
	table.clear(self.State)
	self.SupportsVibration = if gamepad then HapticService:IsVibrationSupported(gamepad) else false

	self._gamepad = gamepad

	-- Stop if disconnected:
	if not gamepad then
		self.Disconnected:Fire()
		self.GamepadChanged:Fire(nil)
		return
	end

	for _,inputObject in ipairs(UserInputService:GetGamepadState(gamepad)) do
		self.State[inputObject.KeyCode] = inputObject
	end

	self._gamepadTrove:Add(self, "StopMotors")

	self._gamepadTrove:Connect(UserInputService.InputBegan, function(input, processed)
		if input.UserInputType == gamepad then
			self.ButtonDown:Fire(input.KeyCode, processed)
		end
	end)

	self._gamepadTrove:Connect(UserInputService.InputEnded, function(input, processed)
		if input.UserInputType == gamepad then
			self.ButtonUp:Fire(input.KeyCode, processed)
		end
	end)

	if lastGamepad == nil then
		self.Connected:Fire()
	end
	self.GamepadChanged:Fire(gamepad)

end


function Gamepad:_setupGamepad(forcedGamepad: Enum.UserInputType?)

	if forcedGamepad then

		-- Forced gamepad:

		self._trove:Connect(UserInputService.GamepadConnected, function(gp)
			if gp == forcedGamepad then
				self:_setupActiveGamepad(forcedGamepad)
			end
		end)

		self._trove:Connect(UserInputService.GamepadDisconnected, function(gp)
			if gp == forcedGamepad then
				self:_setupActiveGamepad(nil)
			end
		end)

		if UserInputService:GetGamepadConnected(forcedGamepad) then
			self:_setupActiveGamepad(forcedGamepad)
		end

	else

		-- Dynamic gamepad:

		local function CheckToSetupActive()
			local active = GetActiveGamepad()
			if active ~= self._gamepad then
				self:_setupActiveGamepad(active)
			end
		end

		self._trove:Connect(UserInputService.GamepadConnected, CheckToSetupActive)
		self._trove:Connect(UserInputService.GamepadDisconnected, CheckToSetupActive)
		self:_setupActiveGamepad(GetActiveGamepad())

	end

end


function Gamepad:_setupMotors()
	self._setMotorIds = {}
	for _,motor in ipairs(Enum.VibrationMotor:GetEnumItems()) do
		self._setMotorIds[motor] = 0
	end
end


--[=[
	@param thumbstick Enum.KeyCode
	@param deadzoneThreshold number?
	@return Vector2
	Gets the position of the given thumbstick. The two thumbstick
	KeyCodes are `Enum.KeyCode.Thumbstick1` and `Enum.KeyCode.Thumbstick2`.

	If `deadzoneThreshold` is not included, the `DefaultDeadzone` value is
	used instead.

	```lua
	local leftThumbstick = gamepad:GetThumbstick(Enum.KeyCode.Thumbstick1)
	print("Left thumbstick position", leftThumbstick)
	```
]=]
function Gamepad:GetThumbstick(thumbstick: Enum.KeyCode, deadzoneThreshold: number?): Vector2
	local pos = self.State[thumbstick].Position
	local deadzone = deadzoneThreshold or self.DefaultDeadzone
	return Vector2.new(
		ApplyDeadzone(pos.X, deadzone),
		ApplyDeadzone(pos.Y, deadzone)
	)
end


--[=[
	@param trigger KeyCode
	@param deadzoneThreshold number?
	@return number
	Gets the position of the given trigger. The triggers are usually going
	to be `Enum.KeyCode.ButtonL2` and `Enum.KeyCode.ButtonR2`. These trigger
	buttons are analog, and will output a value between the range of [0, 1].

	If `deadzoneThreshold` is not included, the `DefaultDeadzone` value is
	used instead.

	```lua
	local triggerAmount = gamepad:GetTrigger(Enum.KeyCode.ButtonR2)
	print(triggerAmount)
	```
]=]
function Gamepad:GetTrigger(trigger: Enum.KeyCode, deadzoneThreshold: number?): number
	return ApplyDeadzone(self.State[trigger].Position.Z, deadzoneThreshold or self.DefaultDeadzone)
end	


--[=[
	@param gamepadButton KeyCode
	@return boolean
	Returns `true` if the given button is down. This includes
	any button on the gamepad, such as `Enum.KeyCode.ButtonA`,
	`Enum.KeyCode.ButtonL3`, `Enum.KeyCode.DPadUp`, etc.

	```lua
	-- Check if the 'A' button is down:
	if gamepad:IsButtonDown(Enum.KeyCode.ButtonA) then
		print("ButtonA is down")
	end
	```
]=]
function Gamepad:IsButtonDown(gamepadButton: Enum.KeyCode): boolean
	return UserInputService:IsGamepadButtonDown(self._gamepad, gamepadButton)
end


--[=[
	@param motor Enum.VibrationMotor
	@return boolean
	Returns `true` if the given motor is supported.

	```lua
	-- Pulse the trigger (e.g. shooting a weapon), but fall back to
	-- the large motor if not supported:
	local motor = Enum.VibrationMotor.Large
	if gamepad:IsMotorSupported(Enum.VibrationMotor.RightTrigger) then
		motor = Enum.VibrationMotor.RightTrigger
	end
	gamepad:PulseMotor(motor, 1, 0.1)
	```
]=]
function Gamepad:IsMotorSupported(motor: Enum.VibrationMotor): boolean
	return HapticService:IsMotorSupported(self._gamepad, motor)
end


--[=[
	@param motor Enum.VibrationMotor
	@param intensity number
	Sets the gamepad's haptic motor to a certain intensity. The
	intensity value is a number in the range of [0, 1].

	```lua
	gamepad:SetMotor(Enum.VibrationMotor.Large, 0.5)
	```
]=]
function Gamepad:SetMotor(motor: Enum.VibrationMotor, intensity: number): number
	self._setMotorIds[motor] += 1
	local id = self._setMotorIds[motor]
	HapticService:SetMotor(self._gamepad, motor, intensity)
	return id
end


--[=[
	@param motor Enum.VibrationMotor
	@param intensity number
	@param duration number
	Sets the gamepad's haptic motor to a certain intensity for a given
	period of time. The motor will stop vibrating after the given
	`duration` has elapsed.

	Calling any motor setter methods (e.g. `SetMotor`, `PulseMotor`,
	`StopMotor`) _after_ calling this method will override the pulse.
	For instance, if `PulseMotor` is called, and then `SetMotor` is
	called right afterwards, `SetMotor` will take precedent.

	```lua
	-- Pulse the large motor for 0.2 seconds with an intensity of 90%:
	gamepad:PulseMotor(Enum.VibrationMotor.Large, 0.9, 0.2)

	-- Example of PulseMotor being overridden:
	gamepad:PulseMotor(Enum.VibrationMotor.Large, 1, 3)
	task.wait(0.1)
	gamepad:SetMotor(Enum.VibrationMotor.Large, 0.5)
	-- Now the pulse won't shut off the motor after 3 seconds,
	-- because SetMotor was called, which cancels the pulse.
	```
]=]
function Gamepad:PulseMotor(motor: Enum.VibrationMotor, intensity: number, duration: number)
	local id = self:SetMotor(motor, intensity)
	local heartbeat = HeartbeatDelay(duration, function()
		if self._setMotorIds[motor] ~= id then return end
		self:StopMotor(motor)
	end)
	self._gamepadTrove:Add(heartbeat)
end


--[=[
	@param motor Enum.VibrationMotor
	Stops the given motor. This is equivalent to calling
	`gamepad:SetMotor(motor, 0)`.

	```lua
	gamepad:SetMotor(Enum.VibrationMotor.Large, 1)
	task.wait(0.1)
	gamepad:StopMotor(Enum.VibrationMotor.Large)
	```
]=]
function Gamepad:StopMotor(motor: Enum.VibrationMotor)
	self:SetMotor(motor, 0)
end


--[=[
	Stops all motors on the gamepad.

	```lua
	gamepad:SetMotor(Enum.VibrationMotor.Large, 1)
	gamepad:SetMotor(Enum.VibrationMotor.Small, 1)
	task.wait(0.1)
	gamepad:StopMotors()
	```
]=]
function Gamepad:StopMotors()
	for _,motor in ipairs(Enum.VibrationMotor:GetEnumItems()) do
		if self:IsMotorSupported(motor) then
			self:StopMotor(motor)
		end
	end
end


--[=[
	@return boolean
	Returns `true` if the gamepad is currently connected.
]=]
function Gamepad:IsConnected(): boolean
	return if self._gamepad then UserInputService:GetGamepadConnected(self._gamepad) else false
end


--[=[
	@return Enum.UserInputType?
	Gets the current gamepad UserInputType that the gamepad object
	is using. This will be `nil` if there is no connected gamepad.
]=]
function Gamepad:GetUserInputType(): Enum.UserInputType?
	return self._gamepad
end


--[=[
	@param enabled boolean
	Sets the [`GuiService.AutoSelectGuiEnabled`](https://developer.roblox.com/en-us/api-reference/property/GuiService/AutoSelectGuiEnabled)
	property.

	This sets whether or not the Select button on a gamepad will try to auto-select
	a GUI object on screen. This does _not_ turn on/off GUI gamepad navigation,
	but just the initial selection using the Select button.

	For UX purposes, it usually is preferred to set this to `false` and then
	manually set the [`GuiService.SelectedObject`](https://developer.roblox.com/en-us/api-reference/property/GuiService/SelectedObject)
	property within code to set the selected object for gamepads.

	```lua
	gamepad:SetAutoSelectGui(false)
	game:GetService("GuiService").SelectedObject = someGuiObject
	```
]=]
function Gamepad:SetAutoSelectGui(enabled: boolean)
	GuiService.AutoSelectGuiEnabled = enabled
end

--[=[
	@return boolean
	Returns the [`GuiService.AutoSelectGuiEnabled`](https://developer.roblox.com/en-us/api-reference/property/GuiService/AutoSelectGuiEnabled)
	property.
]=]
function Gamepad:IsAutoSelectGuiEnabled(): boolean
	return GuiService.AutoSelectGuiEnabled
end


--[=[
	Destroys the gamepad object.
]=]
function Gamepad:Destroy()
	self._trove:Destroy()
end


return Gamepad
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="337">
              <Properties>
                <string name="Name">Keyboard</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezNGOEZBQzEwLTlCRDQtNEE5RS05QUUyLUZCQjU0NUU5M0I1NX0=]]></BinaryString>
                <string name="Source"><![CDATA[-- Keyboard
-- Stephen Leitnick
-- October 10, 2021


local Trove = require(script.Parent.Parent.Trove)
local Signal = require(script.Parent.Parent.Signal)

local UserInputService = game:GetService("UserInputService")


--[=[
	@class Keyboard
	@client

	The Keyboard class is part of the Input package.

	```lua
	local Keyboard = require(packages.Input).Keyboard
	```
]=]
local Keyboard = {}
Keyboard.__index = Keyboard

--[=[
	@within Keyboard
	@prop KeyDown Signal<Enum.KeyCode>
	@tag Event
	Fired when a key is pressed.
	```lua
	keyboard.KeyDown:Connect(function(key: KeyCode)
		print("Key pressed", key)
	end)
	```
]=]
--[=[
	@within Keyboard
	@prop KeyUp Signal<Enum.KeyCode>
	@tag Event
	Fired when a key is released.
	```lua
	keyboard.KeyUp:Connect(function(key: KeyCode)
		print("Key released", key)
	end)
	```
]=]


--[=[
	@return Keyboard

	Constructs a new keyboard input capturer.

	```lua
	local keyboard = Keyboard.new()
	```
]=]
function Keyboard.new()
	local self = setmetatable({}, Keyboard)
	self._trove = Trove.new()
	self.KeyDown = self._trove:Construct(Signal)
	self.KeyUp = self._trove:Construct(Signal)
	self:_setup()
	return self
end


--[=[
	Check if the given key is down.

	```lua
	local w = keyboard:IsKeyDown(Enum.KeyCode.W)
	if w then ... end
	```
]=]
function Keyboard:IsKeyDown(keyCode: Enum.KeyCode): boolean
	return UserInputService:IsKeyDown(keyCode)
end


--[=[
	Check if _both_ keys are down. Useful for key combinations.

	```lua
	local shiftA = keyboard:AreKeysDown(Enum.KeyCode.LeftShift, Enum.KeyCode.A)
	if shiftA then ... end
	```
]=]
function Keyboard:AreKeysDown(keyCodeOne: Enum.KeyCode, keyCodeTwo: Enum.KeyCode): boolean
	return self:IsKeyDown(keyCodeOne) and self:IsKeyDown(keyCodeTwo)
end


--[=[
	Check if _either_ of the keys are down. Useful when two keys might perform
	the same operation.

	```lua
	local wOrUp = keyboard:AreEitherKeysDown(Enum.KeyCode.W, Enum.KeyCode.Up)
	if wOrUp then
		-- Go forward
	end
	```
]=]
function Keyboard:AreEitherKeysDown(keyCodeOne: Enum.KeyCode, keyCodeTwo: Enum.KeyCode): boolean
	return self:IsKeyDown(keyCodeOne) or self:IsKeyDown(keyCodeTwo)
end


function Keyboard:_setup()

	self._trove:Connect(UserInputService.InputBegan, function(input, processed)
		if processed then return end
		if input.UserInputType == Enum.UserInputType.Keyboard then
			self.KeyDown:Fire(input.KeyCode)
		end
	end)

	self._trove:Connect(UserInputService.InputEnded, function(input, processed)
		if processed then return end
		if input.UserInputType == Enum.UserInputType.Keyboard then
			self.KeyUp:Fire(input.KeyCode)
		end
	end)

end


--[=[
	Destroy the keyboard input capturer.
]=]
function Keyboard:Destroy()
	self._trove:Destroy()
end


return Keyboard
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="338">
              <Properties>
                <string name="Name">Mouse</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0Y0NTlBMzRGLUFENTYtNDMzOC1CM0UxLTVCNTBCNzg5RjQzNH0=]]></BinaryString>
                <string name="Source"><![CDATA[-- Mouse
-- Stephen Leitnick
-- November 07, 2020


local Trove = require(script.Parent.Parent.Trove)
local Signal = require(script.Parent.Parent.Signal)

local UserInputService = game:GetService("UserInputService")

local RAY_DISTANCE = 1000

--[=[
	@class Mouse
	@client

	The Mouse class is part of the Input package.

	```lua
	local Mouse = require(packages.Input).Mouse
	```
]=]
local Mouse = {}
Mouse.__index = Mouse

--[=[
	@within Mouse
	@prop LeftDown Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop LeftUp Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop RightDown Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop RightUp Signal
	@tag Event
]=]
--[=[
	@within Mouse
	@prop Scrolled Signal<number>
	@tag Event
	```lua
	mouse.Scrolled:Connect(function(scrollAmount) ... end)
	```
]=]


--[=[
	@return Mouse

	Constructs a new mouse input capturer.

	```lua
	local mouse = Mouse.new()
	```
]=]
function Mouse.new()

	local self = setmetatable({}, Mouse)

	self._trove = Trove.new()

	self.LeftDown = self._trove:Construct(Signal)
	self.LeftUp = self._trove:Construct(Signal)
	self.RightDown = self._trove:Construct(Signal)
	self.RightUp = self._trove:Construct(Signal)
	self.Scrolled = self._trove:Construct(Signal)

	self._trove:Connect(UserInputService.InputBegan, function(input, processed)
		if processed then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.LeftDown:Fire()
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.RightDown:Fire()
		end
	end)

	self._trove:Connect(UserInputService.InputEnded, function(input, processed)
		if processed then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.LeftUp:Fire()
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.RightUp:Fire()
		end
	end)

	self._trove:Connect(UserInputService.InputChanged, function(input, processed)
		if processed then return end
		if input.UserInputType == Enum.UserInputType.MouseWheel then
			self.Scrolled:Fire(input.Position.Z)
		end
	end)

	return self

end


--[=[
	Checks if the left mouse button is down.
]=]
function Mouse:IsLeftDown(): boolean
	return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
end


--[=[
	Checks if the right mouse button is down.
]=]
function Mouse:IsRightDown(): boolean
	return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
end


--[=[
	Gets the screen position of the mouse.
]=]
function Mouse:GetPosition(): Vector2
	return UserInputService:GetMouseLocation()
end


--[=[
	Gets the delta screen position of the mouse. In other words, the
	distance the mouse has traveled away from its locked position in
	a given frame (see note about mouse locking below).

	:::info Only When Mouse Locked
	Getting the mouse delta is only intended for when the mouse is locked. If the
	mouse is _not_ locked, this will return a zero Vector2. The mouse can be locked
	using the `mouse:Lock()` and `mouse:LockCenter()` method.
]=]
function Mouse:GetDelta(): Vector2
	return UserInputService:GetMouseDelta()
end


--[=[
	Returns the viewport point ray for the mouse at the current mouse
	position (or the override position if provided).
]=]
function Mouse:GetRay(overridePos: Vector2?): Ray
	local mousePos = overridePos or UserInputService:GetMouseLocation()
	local viewportMouseRay = workspace.CurrentCamera:ViewportPointToRay(mousePos.X, mousePos.Y)
	return viewportMouseRay
end


--[=[
	Performs a raycast operation out from the mouse position (or the
	`overridePos` if provided) into world space. The ray will go
	`distance` studs forward (or 1000 studs if not provided).

	Returns the `RaycastResult` if something was hit, else returns `nil`.

	Use `Raycast` if it is important to capture any objects that could be
	hit along the projected ray. If objects can be ignored and only the
	final position of the ray is needed, use `Project` instead.

	```lua
	local params = RaycastParams.new()
	local result = mouse:Raycast(params)
	if result then
		print(result.Instance)
	else
		print("Mouse raycast did not hit anything")
	end
	```
]=]
function Mouse:Raycast(raycastParams: RaycastParams, distance: number?, overridePos: Vector2?): RaycastResult?
	local viewportMouseRay = self:GetRay(overridePos)
	local result = workspace:Raycast(viewportMouseRay.Origin, viewportMouseRay.Direction * (distance or RAY_DISTANCE), raycastParams)
	return result
end


--[=[
	Gets the 3D world position of the mouse when projected forward. This would be the
	end-position of a raycast if nothing was hit. Similar to `Raycast`, optional
	`distance` and `overridePos` arguments are allowed.
	
	Use `Project` if you want to get the 3D world position of the mouse at a given
	distance but don't care about any objects that could be in the way. It is much
	faster to project a position into 3D space than to do a full raycast operation.

	```lua
	local params = RaycastParams.new()
	local distance = 200

	local result = mouse:Raycast(params, distance)
	if result then
		-- Do something with result
	else
		-- Raycast failed, but still get the world position of the mouse:
		local worldPosition = mouse:Project(distance)
	end
	```
]=]
function Mouse:Project(distance: number?, overridePos: Vector2?): Vector3
	local viewportMouseRay = self:GetRay(overridePos)
	return viewportMouseRay.Origin + (viewportMouseRay.Direction.Unit * (distance or RAY_DISTANCE))
end


--[=[
	Locks the mouse in its current position on screen. Call `mouse:Unlock()`
	to unlock the mouse.

	:::caution Must explicitly unlock
	Be sure to explicitly call `mouse:Unlock()` before cleaning up the mouse.
	The `Destroy` method does _not_ unlock the mouse since there is no way
	to guarantee who "owns" the mouse lock.
]=]
function Mouse:Lock()
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
end


--[=[
	Locks the mouse in the center of the screen. Call `mouse:Unlock()`
	to unlock the mouse.

	:::caution Must explicitly unlock
	See cautionary in `Lock` method above.
]=]
function Mouse:LockCenter()
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
end


--[=[
	Unlocks the mouse.
]=]
function Mouse:Unlock()
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
end


--[=[
	Destroys the mouse.
]=]
function Mouse:Destroy()
	self._trove:Destroy()
end


return Mouse
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="339">
              <Properties>
                <string name="Name">PreferredInput</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0JCNzlGMzFCLTVFODgtNEE0OC1CNkZDLTRDNzBBOUEzNjQxN30=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict

-- PreferredInput
-- Stephen Leitnick
-- April 05, 2021


local Signal = require(script.Parent.Parent.Signal)
local EnumList = require(script.Parent.Parent.EnumList)

local UserInputService = game:GetService("UserInputService")

local touchUserInputType = Enum.UserInputType.Touch
local keyboardUserInputType = Enum.UserInputType.Keyboard


--[=[
	@class PreferredInput
	@client

	A helper library for observing the preferred user input of the
	player. This is useful for determining what input schemes
	to use during gameplay. A player might switch from using
	a mouse to a gamepad mid-game, and it is important for the
	game to respond to this change.

	The Preferred class is part of the Input package.

	```lua
	local PreferredInput = require(packages.Input).PreferredInput
	```
]=]
local PreferredInput = {}

--[=[
	@within PreferredInput
	@interface InputType
	@tag Enum
	.MouseKeyboard "MouseKeyboard" -- Prefer mouse and keyboard input
	.Touch "Touch" -- Prefer touch input
	.Gamepad "Gamepad" -- Prefer gamepad input

	Indicates an input schema that the user currently prefers.
]=]

--[=[
	@within PreferredInput
	@prop Changed Signal<InputType>
	@tag Event

	Fired when the preferred InputType changes.

	```lua
	PreferredInput.Changed:Connect(function(preferred)
		if preferred == PreferredInput.InputType.Gamepad then
			-- Prefer gamepad input
		end
	end)
	```
]=]

--[=[
	@within PreferredInput
	@prop InputType InputType
	@readonly
	@tag Enums

	A table containing the InputType enum, e.g. `PreferredInput.InputType.Gamepad`.

	```lua
	if PreferredInput.Current == PreferredInput.InputType.Gamepad then
		-- User prefers gamepad input
	end
	```
]=]

--[=[
	@within PreferredInput
	@prop Current InputType
	@readonly

	The current preferred InputType.

	```lua
	print(PreferredInput.Current)
	```
]=]

PreferredInput.Changed = Signal.new()
PreferredInput.InputType = EnumList.new("InputType", {"MouseKeyboard", "Touch", "Gamepad"})
PreferredInput.Current = PreferredInput.InputType.MouseKeyboard


--[=[
	@param handler (preferred: InputType) -> ()
	@return Connection

	Observes the preferred input. In other words, the handler function will
	be fired immediately, as well as any time the preferred input changes.

	```lua
	local connection = PreferredInput.Observe(function(preferred)
		-- Fires immediately & any time the preferred input changes
		print(preferred)
	end)

	-- If/when desired, the connection to Observe can be cleaned up:
	connection:Disconnect()
	```
]=]
function PreferredInput.Observe(handler)
	task.spawn(handler, PreferredInput.Current)
	return PreferredInput.Changed:Connect(handler)
end


local function SetPreferred(preferred)
	if preferred ~= PreferredInput.Current then
		PreferredInput.Current = preferred
		PreferredInput.Changed:Fire(preferred)
	end
end


local function DeterminePreferred(inputType: Enum.UserInputType)
	if inputType == touchUserInputType then
		SetPreferred(PreferredInput.InputType.Touch)
	elseif inputType == keyboardUserInputType or inputType.Name:sub(1, 5) == "Mouse" then
		SetPreferred(PreferredInput.InputType.MouseKeyboard)
	elseif inputType.Name:sub(1, 7) == "Gamepad" then
		SetPreferred(PreferredInput.InputType.Gamepad)
	end
end


DeterminePreferred(UserInputService:GetLastInputType())
UserInputService.LastInputTypeChanged:Connect(DeterminePreferred)


return PreferredInput
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="340">
              <Properties>
                <string name="Name">Touch</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0JDMkQ2NUUyLUQzODgtNDhERi05MERFLUE0MkZBODBBNUZFQn0=]]></BinaryString>
                <string name="Source"><![CDATA[-- Touch
-- Stephen Leitnick
-- March 14, 2021


local Trove = require(script.Parent.Parent.Trove)
local Signal = require(script.Parent.Parent.Signal)

local UserInputService = game:GetService("UserInputService")


--[=[
	@class Touch
	@client

	The Touch class is part of the Input package.

	```lua
	local Touch = require(packages.Input).Touch
	```
]=]
local Touch = {}
Touch.__index = Touch

--[=[
	@within Touch
	@prop TouchTap Signal<(touchPositions: {Vector2}, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchTap](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchTap).
]=]
--[=[
	@within Touch
	@prop TouchTapInWorld Signal<(position: Vector2, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchTapInWorld](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchTapInWorld).
]=]
--[=[
	@within Touch
	@prop TouchMoved Signal<(touch: InputObject, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchMoved](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchMoved).
]=]
--[=[
	@within Touch
	@prop TouchLongPress Signal<(touchPositions: {Vector2}, state: Enum.UserInputState, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchLongPress](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchLongPress).
]=]
--[=[
	@within Touch
	@prop TouchPan Signal<(touchPositions: {Vector2}, totalTranslation: Vector2, velocity: Vector2, state: Enum.UserInputState, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchPan](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchPan).
]=]
--[=[
	@within Touch
	@prop TouchPinch Signal<(touchPositions: {Vector2}, scale: number, velocity: Vector2, state: Enum.UserInputState, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchPinch](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchPinch).
]=]
--[=[
	@within Touch
	@prop TouchRotate Signal<(touchPositions: {Vector2}, rotation: number, velocity: number, state: Enum.UserInputState, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchRotate](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchRotate).
]=]
--[=[
	@within Touch
	@prop TouchSwipe Signal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchSwipe](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchSwipe).
]=]
--[=[
	@within Touch
	@prop TouchStarted Signal<(touch: InputObject, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchStarted](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchStarted).
]=]
--[=[
	@within Touch
	@prop TouchEnded Signal<(touch: InputObject, processed: boolean)>
	@tag Event
	Proxy for [UserInputService.TouchEnded](https://developer.roblox.com/en-us/api-reference/event/UserInputService/TouchEnded).
]=]


--[=[
	Constructs a new Touch input capturer.
]=]
function Touch.new()

	local self = setmetatable({}, Touch)

	self._trove = Trove.new()

	self.TouchTap = self._trove:Construct(Signal.Wrap, UserInputService.TouchTap)
	self.TouchTapInWorld = self._trove:Construct(Signal.Wrap, UserInputService.TouchTapInWorld)
	self.TouchMoved = self._trove:Construct(Signal.Wrap, UserInputService.TouchMoved)
	self.TouchLongPress = self._trove:Construct(Signal.Wrap, UserInputService.TouchLongPress)
	self.TouchPan = self._trove:Construct(Signal.Wrap, UserInputService.TouchPan)
	self.TouchPinch = self._trove:Construct(Signal.Wrap, UserInputService.TouchPinch)
	self.TouchRotate = self._trove:Construct(Signal.Wrap, UserInputService.TouchRotate)
	self.TouchSwipe = self._trove:Construct(Signal.Wrap, UserInputService.TouchSwipe)
	self.TouchStarted = self._trove:Construct(Signal.Wrap, UserInputService.TouchStarted)
	self.TouchEnded = self._trove:Construct(Signal.Wrap, UserInputService.TouchEnded)

	return self

end


--[=[
	Returns the value of [`UserInputService.TouchEnabled`](https://developer.roblox.com/en-us/api-reference/property/UserInputService/TouchEnabled).
]=]
function Touch:IsTouchEnabled(): boolean
	return UserInputService.TouchEnabled
end


--[=[
	Destroys the Touch input capturer.
]=]
function Touch:Destroy()
	self._trove:Destroy()
end


return Touch
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="341">
          <Properties>
            <string name="Name">sleitnick_knit@1.4.7</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="342">
            <Properties>
              <string name="Name">Comm</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezA1QjgwNzlCLTAxQjUtNDE2MS04Njc2LTM2ODQyMjM3Mjg0N30=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_comm@0.3.0"]["comm"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="343">
            <Properties>
              <string name="Name">Promise</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0UzRTk2QzY2LTMwNTUtNDdGNC1BRDcxLTg0OUMyOUQ1QjcwM30=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["evaera_promise@4.0.0"]["promise"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="344">
            <Properties>
              <string name="Name">knit</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezMyMkUxNEU2LTdCQTktNEZCMS04ODc4LTU2RjgyQzIxMTc2Mn0=]]></BinaryString>
              <string name="Source"><![CDATA[if game:GetService("RunService"):IsServer() then
	return require(script.KnitServer)
else
	local KnitServer = script:FindFirstChild("KnitServer")
	if KnitServer then
		KnitServer:Destroy()
	end
	return require(script.KnitClient)
end
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="345">
              <Properties>
                <string name="Name">KnitClient</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0I5MkYzQzAyLUM1NjktNDREOS1CMzkzLUUwQUU2QUIzODE4Qn0=]]></BinaryString>
                <string name="Source"><![CDATA[--[=[
	@interface Middleware
	.Inbound ClientMiddleware?
	.Outbound ClientMiddleware?
	@within KnitClient
]=]
type Middleware = {
	Inbound: ClientMiddleware?,
	Outbound: ClientMiddleware?,
}

--[=[
	@type ClientMiddlewareFn (args: {any}) -> (shouldContinue: boolean, ...: any)
	@within KnitClient

	For more info, see [ClientComm](https://sleitnick.github.io/RbxUtil/api/ClientComm/) documentation.
]=]
type ClientMiddlewareFn = (args: {any}) -> (boolean, ...any)

--[=[
	@type ClientMiddleware {ClientMiddlewareFn}
	@within KnitClient
	An array of client middleware functions.
]=]
type ClientMiddleware = {ClientMiddlewareFn}

--[=[
	@type PerServiceMiddleware {[string]: Middleware}
	@within KnitClient
]=]
type PerServiceMiddleware = {[string]: Middleware}

--[=[
	@interface ControllerDef
	.Name string
	.[any] any
	@within KnitClient
	Used to define a controller when creating it in `CreateController`.
]=]
type ControllerDef = {
	Name: string,
	[any]: any,
}

--[=[
	@interface Controller
	.Name string
	.[any] any
	@within KnitClient
]=]
type Controller = {
	Name: string,
	[any]: any,
}

--[=[
	@interface Service
	.[any] any
	@within KnitClient
]=]
type Service = {
	[any]: any,
}

--[=[
	@interface KnitOptions
	.ServicePromises boolean?
	.Middleware Middleware?
	.PerServiceMiddleware PerServiceMiddleware?
	@within KnitClient

	- `ServicePromises` defaults to `true` and indicates if service methods use promises.
	- Each service will go through the defined middleware, unless the service
	has middleware defined in `PerServiceMiddleware`.
]=]
type KnitOptions = {
	ServicePromises: boolean,
	Middleware: Middleware?,
	PerServiceMiddleware: PerServiceMiddleware?,
}

local defaultOptions: KnitOptions = {
	ServicePromises = true,
	Middleware = nil,
	PerServiceMiddleware = {},
}

local selectedOptions = nil


--[=[
	@class KnitClient
	@client
]=]
local KnitClient = {}

--[=[
	@prop Player Player
	@within KnitClient
	@readonly
	Reference to the LocalPlayer.
]=]
KnitClient.Player = game:GetService("Players").LocalPlayer

--[=[
	@prop Util Folder
	@within KnitClient
	@readonly
	References the Util folder. Should only be accessed when using Knit as
	a standalone module. If using Knit from Wally, modules should just be
	pulled in via Wally instead of relying on Knit's Util folder, as this
	folder only contains what is necessary for Knit to run in Wally mode.
]=]
KnitClient.Util = script.Parent.Parent

local Promise = require(KnitClient.Util.Promise)
local Comm = require(KnitClient.Util.Comm)
local ClientComm = Comm.ClientComm

local controllers: {[string]: Controller} = {}
local services: {[string]: Service} = {}
local servicesFolder = nil

local started = false
local startedComplete = false
local onStartedComplete = Instance.new("BindableEvent")


local function DoesControllerExist(controllerName: string): boolean
	local controller: Controller? = controllers[controllerName]
	return controller ~= nil
end


local function GetServicesFolder()
	if not servicesFolder then
		servicesFolder = script.Parent:WaitForChild("Services")
	end
	return servicesFolder
end


local function GetMiddlewareForService(serviceName: string)
	local knitMiddleware = selectedOptions.Middleware or {}
	local serviceMiddleware = selectedOptions.PerServiceMiddleware[serviceName]
	return serviceMiddleware or knitMiddleware
end


local function BuildService(serviceName: string)
	local folder = GetServicesFolder()
	local middleware = GetMiddlewareForService(serviceName)
	local clientComm = ClientComm.new(folder, selectedOptions.ServicePromises, serviceName)
	local service = clientComm:BuildObject(middleware.Inbound, middleware.Outbound)
	services[serviceName] = service
	return service
end


--[=[
	Creates a new controller.

	:::caution
	Controllers must be created _before_ calling `Knit.Start()`.
	:::
	```lua
	-- Create a controller
	local MyController = Knit.CreateController {
		Name = "MyController",
	}

	function MyController:KnitStart()
		print("MyController started")
	end

	function MyController:KnitInit()
		print("MyController initialized")
	end
	```
]=]
function KnitClient.CreateController(controllerDef: ControllerDef): Controller
	assert(type(controllerDef) == "table", "Controller must be a table; got " .. type(controllerDef))
	assert(type(controllerDef.Name) == "string", "Controller.Name must be a string; got " .. type(controllerDef.Name))
	assert(#controllerDef.Name > 0, "Controller.Name must be a non-empty string")
	assert(not DoesControllerExist(controllerDef.Name), "Controller \"" .. controllerDef.Name .. "\" already exists")
	local controller = controllerDef :: Controller
	controllers[controller.Name] = controller
	return controller
end


--[=[
	Requires all the modules that are children of the given parent. This is an easy
	way to quickly load all controllers that might be in a folder.
	```lua
	Knit.AddControllers(somewhere.Controllers)
	```
]=]
function KnitClient.AddControllers(parent: Instance): {Controller}
	local addedControllers = {}
	for _,v in ipairs(parent:GetChildren()) do
		if not v:IsA("ModuleScript") then continue end
		table.insert(addedControllers, require(v))
	end
	return addedControllers
end


--[=[
	Requires all the modules that are descendants of the given parent.
]=]
function KnitClient.AddControllersDeep(parent: Instance): {Controller}
	local addedControllers = {}
	for _,v in ipairs(parent:GetDescendants()) do
		if not v:IsA("ModuleScript") then continue end
		table.insert(addedControllers, require(v))
	end
	return addedControllers
end


--[=[
	Returns a Service object which is a reflection of the remote objects
	within the Client table of the given service. Throws an error if the
	service is not found.

	If a service's Client table contains RemoteSignals and/or RemoteProperties,
	these values are reflected as
	[ClientRemoteSignals](https://sleitnick.github.io/RbxUtil/api/ClientRemoteSignal) and
	[ClientRemoteProperties](https://sleitnick.github.io/RbxUtil/api/ClientRemoteProperty).

	```lua
	-- Server-side service creation:
	local MyService = Knit.CreateService {
		Name = "MyService",
		Client = {
			MySignal = Knit.CreateSignal(),
			MyProperty = Knit.CreateProperty("Hello"),
		},
	}
	function MyService:AddOne(player, number)
		return number + 1
	end

	-------------------------------------------------

	-- Client-side service reflection:
	local MyService = Knit.GetService("MyService")

	-- Call a method:
	local num = MyService:AddOne(5) --> 6

	-- Fire a signal to the server:
	MyService.MySignal:Fire("Hello")

	-- Listen for signals from the server:
	MyService.MySignal:Connect(function(message)
		print(message)
	end)

	-- Observe the initial value and changes to properties:
	MyService.MyProperty:Observe(function(value)
		print(value)
	end)
	```

	:::caution
	Services are only exposed to the client if the service has remote-based
	content in the Client table. If not, the service will not be visible
	to the client. `KnitClient.GetService` will only work on services that
	expose remote-based content on their Client tables.
	:::
]=]
function KnitClient.GetService(serviceName: string): Service
	local service = services[serviceName]
	if service then
		return service
	end
	assert(started, "Cannot call GetService until Knit has been started")
	assert(type(serviceName) == "string", "ServiceName must be a string; got " .. type(serviceName))
	return BuildService(serviceName)
end


--[=[
	Gets the controller by name. Throws an error if the controller
	is not found.
]=]
function KnitClient.GetController(controllerName: string): Controller
	local controller = controllers[controllerName]
	if controller then
		return controller
	end
	assert(started, "Cannot call GetController until Knit has been started")
	assert(type(controllerName) == "string", "ControllerName must be a string; got " .. type(controllerName))
	error("Could not find controller \"" .. controllerName .. "\". Check to verify a controller with this name exists.", 2)
end


--[=[
	@return Promise
	Starts Knit. Should only be called once per client.
	```lua
	Knit.Start():andThen(function()
		print("Knit started!")
	end):catch(warn)
	```

	By default, service methods exposed to the client will return promises.
	To change this behavior, set the `ServicePromises` option to `false`:
	```lua
	Knit.Start({ServicePromises = false}):andThen(function()
		print("Knit started!")
	end):catch(warn)
	```
]=]
function KnitClient.Start(options: KnitOptions?)

	if started then
		return Promise.reject("Knit already started")
	end

	started = true

	if options == nil then
		selectedOptions = defaultOptions
	else
		assert(typeof(options) == "table", "KnitOptions should be a table or nil; got " .. typeof(options))
		selectedOptions = options
		for k,v in pairs(defaultOptions) do
			if selectedOptions[k] == nil then
				selectedOptions[k] = v
			end
		end
	end
	if type(selectedOptions.PerServiceMiddleware) ~= "table" then
		selectedOptions.PerServiceMiddleware = {}
	end

	return Promise.new(function(resolve)

		-- Init:
		local promisesStartControllers = {}

		for _,controller in pairs(controllers) do
			if type(controller.KnitInit) == "function" then
				table.insert(promisesStartControllers, Promise.new(function(r)
					debug.setmemorycategory(controller.Name)
					controller:KnitInit()
					r()
				end))
			end
		end

		resolve(Promise.all(promisesStartControllers))

	end):andThen(function()

		-- Start:
		for _,controller in pairs(controllers) do
			if type(controller.KnitStart) == "function" then
				task.spawn(function()
					debug.setmemorycategory(controller.Name)
					controller:KnitStart()
				end)
			end
		end

		startedComplete = true
		onStartedComplete:Fire()

		task.defer(function()
			onStartedComplete:Destroy()
		end)

	end)

end


--[=[
	@return Promise
	Returns a promise that is resolved once Knit has started. This is useful
	for any code that needs to tie into Knit controllers but is not the script
	that called `Start`.
	```lua
	Knit.OnStart():andThen(function()
		local MyController = Knit.GetController("MyController")
		MyController:DoSomething()
	end):catch(warn)
	```
]=]
function KnitClient.OnStart()
	if startedComplete then
		return Promise.resolve()
	else
		return Promise.fromEvent(onStartedComplete.Event)
	end
end


return KnitClient
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="346">
              <Properties>
                <string name="Name">KnitServer</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezA4NUU5RDlDLUQ4MzMtNEMyNy05RDNFLTE0M0RFOTE3ODE5MX0=]]></BinaryString>
                <string name="Source"><![CDATA[--[=[
	@interface Middleware
	.Inbound ServerMiddleware?
	.Outbound ServerMiddleware?
	@within KnitServer
]=]
type Middleware = {
	Inbound: ServerMiddleware?,
	Outbound: ServerMiddleware?,
}

--[=[
	@type ServerMiddlewareFn (player: Player, args: {any}) -> (shouldContinue: boolean, ...: any)
	@within KnitServer

	For more info, see [ServerComm](https://sleitnick.github.io/RbxUtil/api/ServerComm/) documentation.
]=]
type ServerMiddlewareFn = (player: Player, args: {any}) -> (boolean, ...any)

--[=[
	@type ServerMiddleware {ServerMiddlewareFn}
	@within KnitServer
	An array of server middleware functions.
]=]
type ServerMiddleware = {ServerMiddlewareFn}

--[=[
	@interface ServiceDef
	.Name string
	.Client table?
	.Middleware Middleware?
	.[any] any
	@within KnitServer
	Used to define a service when creating it in `CreateService`.

	The middleware tables provided will be used instead of the Knit-level
	middleware (if any). This allows fine-tuning each service's middleware.
	These can also be left out or `nil` to not include middleware.
]=]
type ServiceDef = {
	Name: string,
	Client: {[any]: any}?,
	Middleware: Middleware?,
	[any]: any,
}

--[=[
	@interface Service
	.Name string
	.Client ServiceClient
	.KnitComm Comm
	.[any] any
	@within KnitServer
]=]
type Service = {
	Name: string,
	Client: ServiceClient,
	KnitComm: any,
	[any]: any,
}

--[=[
	@interface ServiceClient
	.Server Service
	.[any] any
	@within KnitServer
]=]
type ServiceClient = {
	Server: Service,
	[any]: any,
}

--[=[
	@interface KnitOptions
	.Middleware Middleware?
	@within KnitServer

	- Middleware will apply to all services _except_ ones that define
	their own middleware.
]=]
type KnitOptions = {
	Middleware: Middleware?,
}

local defaultOptions: KnitOptions = {
	Middleware = nil,
}

local selectedOptions = nil

--[=[
	@class KnitServer
	@server
	Knit server-side lets developers create services and expose methods and signals
	to the clients.

	```lua
	local Knit = require(somewhere.Knit)

	-- Load service modules within some folder:
	Knit.AddServices(somewhere.Services)

	-- Start Knit:
	Knit.Start():andThen(function()
		print("Knit started")
	end):catch(warn)
	```
]=]
local KnitServer = {}

--[=[
	@prop Util Folder
	@within KnitServer
	@readonly
	References the Util folder. Should only be accessed when using Knit as
	a standalone module. If using Knit from Wally, modules should just be
	pulled in via Wally instead of relying on Knit's Util folder, as this
	folder only contains what is necessary for Knit to run in Wally mode.
]=]
KnitServer.Util = script.Parent.Parent

local SIGNAL_MARKER = newproxy(true)
getmetatable(SIGNAL_MARKER).__tostring = function()
	return "SIGNAL_MARKER"
end

local PROPERTY_MARKER = newproxy(true)
getmetatable(PROPERTY_MARKER).__tostring = function()
	return "PROPERTY_MARKER"
end

local knitRepServiceFolder = Instance.new("Folder")
knitRepServiceFolder.Name = "Services"

local Promise = require(KnitServer.Util.Promise)
local Comm = require(KnitServer.Util.Comm)
local ServerComm = Comm.ServerComm

local services: {[string]: Service} = {}
local started = false
local startedComplete = false
local onStartedComplete = Instance.new("BindableEvent")


local function DoesServiceExist(serviceName: string): boolean
	local service: Service? = services[serviceName]
	return service ~= nil
end


--[=[
	Constructs a new service.

	:::caution
	Services must be created _before_ calling `Knit.Start()`.
	:::
	```lua
	-- Create a service
	local MyService = Knit.CreateService {
		Name = "MyService",
		Client = {},
	}

	-- Expose a ToAllCaps remote function to the clients
	function MyService.Client:ToAllCaps(player, msg)
		return msg:upper()
	end

	-- Knit will call KnitStart after all services have been initialized
	function MyService:KnitStart()
		print("MyService started")
	end

	-- Knit will call KnitInit when Knit is first started
	function MyService:KnitInit()
		print("MyService initialize")
	end
	```
]=]
function KnitServer.CreateService(serviceDef: ServiceDef): Service
	assert(type(serviceDef) == "table", "Service must be a table; got " .. type(serviceDef))
	assert(type(serviceDef.Name) == "string", "Service.Name must be a string; got " .. type(serviceDef.Name))
	assert(#serviceDef.Name > 0, "Service.Name must be a non-empty string")
	assert(not DoesServiceExist(serviceDef.Name), "Service \"" .. serviceDef.Name .. "\" already exists")
	local service = serviceDef
	service.KnitComm = ServerComm.new(knitRepServiceFolder, serviceDef.Name)
	if type(service.Client) ~= "table" then
		service.Client = {Server = service}
	else
		if service.Client.Server ~= service then
			service.Client.Server = service
		end
	end
	services[service.Name] = service
	return service
end


--[=[
	Requires all the modules that are children of the given parent. This is an easy
	way to quickly load all services that might be in a folder.
	```lua
	Knit.AddServices(somewhere.Services)
	```
]=]
function KnitServer.AddServices(parent: Instance): {Service}
	local addedServices = {}
	for _,v in ipairs(parent:GetChildren()) do
		if not v:IsA("ModuleScript") then continue end
		table.insert(addedServices, require(v))
	end
	return addedServices
end


--[=[
	Requires all the modules that are descendants of the given parent.
]=]
function KnitServer.AddServicesDeep(parent: Instance): {Service}
	local addedServices = {}
	for _,v in ipairs(parent:GetDescendants()) do
		if not v:IsA("ModuleScript") then continue end
		table.insert(addedServices, require(v))
	end
	return addedServices
end


--[=[
	Gets the service by name. Throws an error if the service is not found.
]=]
function KnitServer.GetService(serviceName: string): Service
	assert(started, "Cannot call GetService until Knit has been started")
	assert(type(serviceName) == "string", "ServiceName must be a string; got " .. type(serviceName))
	return assert(services[serviceName], "Could not find service \"" .. serviceName .. "\"") :: Service
end


--[=[
	@return SIGNAL_MARKER
	Returns a marker that will transform the current key into
	a RemoteSignal once the service is created. Should only
	be called within the Client table of a service.

	See [RemoteSignal](https://sleitnick.github.io/RbxUtil/api/RemoteSignal)
	documentation for more info.
	```lua
	local MyService = Knit.CreateService {
		Name = "MyService",
		Client = {
			-- Create the signal marker, which will turn into a
			-- RemoteSignal when Knit.Start() is called:
			MySignal = Knit.CreateSignal(),
		},
	}

	function MyService:KnitInit()
		-- Connect to the signal:
		self.Client.MySignal:Connect(function(player, ...) end)
	end
	```
]=]
function KnitServer.CreateSignal()
	return SIGNAL_MARKER
end


--[=[
	@return PROPERTY_MARKER
	Returns a marker that will transform the current key into
	a RemoteProperty once the service is created. Should only
	be called within the Client table of a service. An initial
	value can be passed along as well.

	RemoteProperties are great for replicating data to all of
	the clients. Different data can also be set per client.

	See [RemoteProperty](https://sleitnick.github.io/RbxUtil/api/RemoteProperty)
	documentation for more info.

	```lua
	local MyService = Knit.CreateService {
		Name = "MyService",
		Client = {
			-- Create the property marker, which will turn into a
			-- RemoteProperty when Knit.Start() is called:
			MyProperty = Knit.CreateProperty("HelloWorld"),
		},
	}

	function MyService:KnitInit()
		-- Change the value of the property:
		self.Client.MyProperty:Set("HelloWorldAgain")
	end
	```
]=]
function KnitServer.CreateProperty(initialValue: any)
	return {PROPERTY_MARKER, initialValue}
end


--[=[
	@return Promise
	Starts Knit. Should only be called once.

	Optionally, `KnitOptions` can be passed in order to set
	Knit's custom configurations.

	:::caution
	Be sure that all services have been created _before_
	calling `Start`. Services cannot be added later.
	:::

	```lua
	Knit.Start():andThen(function()
		print("Knit started!")
	end):catch(warn)
	```
	
	Example of Knit started with options:
	```lua
	Knit.Start({
		Middleware = {
			Inbound = {
				function(player, args)
					print("Player is giving following args to server:", args)
					return true
				end
			},
		},
	}):andThen(function()
		print("Knit started!")
	end):catch(warn)
	```
]=]
function KnitServer.Start(options: KnitOptions?)

	if started then
		return Promise.reject("Knit already started")
	end

	started = true

	if options == nil then
		selectedOptions = defaultOptions
	else
		assert(typeof(options) == "table", "KnitOptions should be a table or nil; got " .. typeof(options))
		selectedOptions = options
		for k,v in pairs(defaultOptions) do
			if selectedOptions[k] == nil then
				selectedOptions[k] = v
			end
		end
	end

	return Promise.new(function(resolve)

		local knitMiddleware = selectedOptions.Middleware or {}

		-- Bind remotes:
		for _,service in pairs(services) do
			local middleware = service.Middleware or {}
			local inbound = middleware.Inbound or knitMiddleware.Inbound
			local outbound = middleware.Outbound or knitMiddleware.Outbound
			service.Middleware = nil
			for k,v in pairs(service.Client) do
				if type(v) == "function" then
					service.KnitComm:WrapMethod(service.Client, k, inbound, outbound)
				elseif v == SIGNAL_MARKER then
					service.Client[k] = service.KnitComm:CreateSignal(k, inbound, outbound)
				elseif type(v) == "table" and v[1] == PROPERTY_MARKER then
					service.Client[k] = service.KnitComm:CreateProperty(k, v[2], inbound, outbound)
				end
			end
		end

		-- Init:
		local promisesInitServices = {}
		for _,service in pairs(services) do
			if type(service.KnitInit) == "function" then
				table.insert(promisesInitServices, Promise.new(function(r)
					debug.setmemorycategory(service.Name)
					service:KnitInit()
					r()
				end))
			end
		end

		resolve(Promise.all(promisesInitServices))

	end):andThen(function()

		-- Start:
		for _,service in pairs(services) do
			if type(service.KnitStart) == "function" then
				task.spawn(function()
					debug.setmemorycategory(service.Name)
					service:KnitStart()
				end)
			end
		end

		startedComplete = true
		onStartedComplete:Fire()

		task.defer(function()
			onStartedComplete:Destroy()
		end)

		-- Expose service remotes to everyone:
		knitRepServiceFolder.Parent = script.Parent

	end)

end


--[=[
	@return Promise
	Returns a promise that is resolved once Knit has started. This is useful
	for any code that needs to tie into Knit services but is not the script
	that called `Start`.
	```lua
	Knit.OnStart():andThen(function()
		local MyService = Knit.Services.MyService
		MyService:DoSomething()
	end):catch(warn)
	```
]=]
function KnitServer.OnStart()
	if startedComplete then
		return Promise.resolve()
	else
		return Promise.fromEvent(onStartedComplete.Event)
	end
end


return KnitServer
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="347">
          <Properties>
            <string name="Name">sleitnick_loader@1.0.2</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="348">
            <Properties>
              <string name="Name">loader</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0Q1QjVCMzQ5LUNGMTEtNEZDMy1BQTM3LTY1NUVDQjVDMzI1Mn0=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict

-- Loader
-- Stephen Leitnick
-- January 10, 2021

--[[

	Loads all ModuleScripts within the given parent.

	Loader.LoadChildren(parent: Instance): module[]
	Loader.LoadDescendants(parent: Instance): module[]

--]]

--[=[
	@class Loader

	The Loader module will require all children or descendant ModuleScripts.
]=]
local Loader = {}

type Module = {}
type Modules = {Module}


--[=[
	Requires all children ModuleScripts

	@param parent Instance -- Parent to scan
	@return {ModuleScript} -- Array of required modules
]=]
function Loader.LoadChildren(parent: Instance): Modules
	local modules: Modules = {}
	for _,child in ipairs(parent:GetChildren()) do
		if child:IsA("ModuleScript") then
			local m = require(child)
			table.insert(modules, m)
		end
	end
	return modules
end


--[=[
	Requires all descendant ModuleScripts

	@param parent Instance -- Parent to scan
	@return {ModuleScript} -- Array of required modules
]=]
function Loader.LoadDescendants(parent: Instance): Modules
	local modules: Modules = {}
	for _,descendant in ipairs(parent:GetDescendants()) do
		if descendant:IsA("ModuleScript") then
			local m = require(descendant)
			table.insert(modules, m)
		end
	end
	return modules
end


return Loader
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="349">
          <Properties>
            <string name="Name">sleitnick_option@1.0.3</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="350">
            <Properties>
              <string name="Name">option</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezg1NTdEOTdELTI0ODItNDVBRC04RDYxLTMzNzM1REJFNzkzRn0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Option
-- Stephen Leitnick
-- August 28, 2020

--[[

	MatchTable {
		Some: (value: any) -> any
		None: () -> any
	}

	CONSTRUCTORS:

		Option.Some(anyNonNilValue): Option<any>
		Option.Wrap(anyValue): Option<any>


	STATIC FIELDS:

		Option.None: Option<None>


	STATIC METHODS:

		Option.Is(obj): boolean


	METHODS:

		opt:Match(): (matches: MatchTable) -> any
		opt:IsSome(): boolean
		opt:IsNone(): boolean
		opt:Unwrap(): any
		opt:Expect(errMsg: string): any
		opt:ExpectNone(errMsg: string): void
		opt:UnwrapOr(default: any): any
		opt:UnwrapOrElse(default: () -> any): any
		opt:And(opt2: Option<any>): Option<any>
		opt:AndThen(predicate: (unwrapped: any) -> Option<any>): Option<any>
		opt:Or(opt2: Option<any>): Option<any>
		opt:OrElse(orElseFunc: () -> Option<any>): Option<any>
		opt:XOr(opt2: Option<any>): Option<any>
		opt:Contains(value: any): boolean

	--------------------------------------------------------------------

	Options are useful for handling nil-value cases. Any time that an
	operation might return nil, it is useful to instead return an
	Option, which will indicate that the value might be nil, and should
	be explicitly checked before using the value. This will help
	prevent common bugs caused by nil values that can fail silently.


	Example:

	local result1 = Option.Some(32)
	local result2 = Option.Some(nil)
	local result3 = Option.Some("Hi")
	local result4 = Option.Some(nil)
	local result5 = Option.None

	-- Use 'Match' to match if the value is Some or None:
	result1:Match {
		Some = function(value) print(value) end;
		None = function() print("No value") end;
	}

	-- Raw check:
	if result2:IsSome() then
		local value = result2:Unwrap() -- Explicitly call Unwrap
		print("Value of result2:", value)
	end

	if result3:IsNone() then
		print("No result for result3")
	end

	-- Bad, will throw error bc result4 is none:
	local value = result4:Unwrap()

--]]


local CLASSNAME = "Option"

--[=[
	@class Option

	Represents an optional value in Lua. This is useful to avoid `nil` bugs, which can
	go silently undetected within code and cause hidden or hard-to-find bugs.
]=]
local Option = {}
Option.__index = Option


function Option._new(value)
	local self = setmetatable({
		ClassName = CLASSNAME;
		_v = value;
		_s = (value ~= nil);
	}, Option)
	return self
end


--[=[
	@param value T
	@return Option<T>

	Creates an Option instance with the given value. Throws an error
	if the given value is `nil`.
]=]
function Option.Some(value)
	assert(value ~= nil, "Option.Some() value cannot be nil")
	return Option._new(value)
end


--[=[
	@param value T
	@return Option<T> | Option<None>

	Safely wraps the given value as an option. If the
	value is `nil`, returns `Option.None`, otherwise
	returns `Option.Some(value)`.
]=]
function Option.Wrap(value)
	if value == nil then
		return Option.None
	else
		return Option.Some(value)
	end
end


--[=[
	@param obj any
	@return boolean
	Returns `true` if `obj` is an Option.
]=]
function Option.Is(obj)
	return type(obj) == "table" and getmetatable(obj) == Option
end


--[=[
	@param obj any
	Throws an error if `obj` is not an Option.
]=]
function Option.Assert(obj)
	assert(Option.Is(obj), "Result was not of type Option")
end


--[=[
	@param data table
	@return Option
	Deserializes the data into an Option. This data should have come from
	the `option:Serialize()` method.
]=]
function Option.Deserialize(data) -- type data = {ClassName: string, Value: any}
	assert(type(data) == "table" and data.ClassName == CLASSNAME, "Invalid data for deserializing Option")
	return data.Value == nil and Option.None or Option.Some(data.Value)
end


--[=[
	@return table
	Returns a serialized version of the option.
]=]
function Option:Serialize()
	return {
		ClassName = self.ClassName;
		Value = self._v;
	}
end


--[=[
	@param matches {Some: (value: any) -> any, None: () -> any}
	@return any

	Matches against the option.

	```lua
	local opt = Option.Some(32)
	opt:Match {
		Some = function(num) print("Number", num) end,
		None = function() print("No value") end,
	}
	```
]=]
function Option:Match(matches)
	local onSome = matches.Some
	local onNone = matches.None
	assert(type(onSome) == "function", "Missing 'Some' match")
	assert(type(onNone) == "function", "Missing 'None' match")
	if self:IsSome() then
		return onSome(self:Unwrap())
	else
		return onNone()
	end
end


--[=[
	@return boolean
	Returns `true` if the option has a value.
]=]
function Option:IsSome()
	return self._s
end


--[=[
	@return boolean
	Returns `true` if the option is None.
]=]
function Option:IsNone()
	return not self._s
end


--[=[
	@param msg string
	@return value: any
	Unwraps the value in the option, otherwise throws an error with `msg` as the error message.
	```lua
	local opt = Option.Some(10)
	print(opt:Expect("No number")) -> 10
	print(Option.None:Expect("No number")) -- Throws an error "No number"
	```
]=]
function Option:Expect(msg)
	assert(self:IsSome(), msg)
	return self._v
end


--[=[
	@param msg string
	Throws an error with `msg` as the error message if the value is _not_ None.
]=]
function Option:ExpectNone(msg)
	assert(self:IsNone(), msg)
end


--[=[
	@return value: any
	Returns the value in the option, or throws an error if the option is None.
]=]
function Option:Unwrap()
	return self:Expect("Cannot unwrap option of None type")
end


--[=[
	@param default any
	@return value: any
	If the option holds a value, returns the value. Otherwise, returns `default`.
]=]
function Option:UnwrapOr(default)
	if self:IsSome() then
		return self:Unwrap()
	else
		return default
	end
end


--[=[
	@param defaultFn () -> any
	@return value: any
	If the option holds a value, returns the value. Otherwise, returns the
	result of the `defaultFn` function.
]=]
function Option:UnwrapOrElse(defaultFn)
	if self:IsSome() then
		return self:Unwrap()
	else
		return defaultFn()
	end
end


--[=[
	@param optionB Option
	@return Option
	Returns `optionB` if the calling option has a value,
	otherwise returns None.

	```lua
	local optionA = Option.Some(32)
	local optionB = Option.Some(64)
	local opt = optionA:And(optionB)
	-- opt == optionB

	local optionA = Option.None
	local optionB = Option.Some(64)
	local opt = optionA:And(optionB)
	-- opt == Option.None
	```
]=]
function Option:And(optionB)
	if self:IsSome() then
		return optionB
	else
		return Option.None
	end
end


--[=[
	@param andThenFn (value: any) -> Option
	@return value: Option
	If the option holds a value, then the `andThenFn`
	function is called with the held value of the option,
	and then the resultant Option returned by the `andThenFn`
	is returned. Otherwise, None is returned.

	```lua
	local optA = Option.Some(32)
	local optB = optA:AndThen(function(num)
		return Option.Some(num * 2)
	end)
	print(optB:Expect("Expected number")) --> 64
	```
]=]
function Option:AndThen(andThenFn)
	if self:IsSome() then
		local result = andThenFn(self:Unwrap())
		Option.Assert(result)
		return result
	else
		return Option.None
	end
end


--[=[
	@param optionB Option
	@return Option
	If caller has a value, returns itself. Otherwise, returns `optionB`.
]=]
function Option:Or(optionB)
	if self:IsSome() then
		return self
	else
		return optionB
	end
end


--[=[
	@param orElseFn () -> Option
	@return Option
	If caller has a value, returns itself. Otherwise, returns the
	option generated by the `orElseFn` function.
]=]
function Option:OrElse(orElseFn)
	if self:IsSome() then
		return self
	else
		local result = orElseFn()
		Option.Assert(result)
		return result
	end
end


--[=[
	@param optionB Option
	@return Option
	If both `self` and `optionB` have values _or_ both don't have a value,
	then this returns None. Otherwise, it returns the option that does have
	a value.
]=]
function Option:XOr(optionB)
	local someOptA = self:IsSome()
	local someOptB = optionB:IsSome()
	if someOptA == someOptB then
		return Option.None
	elseif someOptA then
		return self
	else
		return optionB
	end
end


--[=[
	@param predicate (value: any) -> boolean
	@return Option
	Returns `self` if this option has a value and the predicate returns `true.
	Otherwise, returns None.
]=]
function Option:Filter(predicate)
	if self:IsNone() or not predicate(self._v) then
		return Option.None
	else
		return self
	end
end


--[=[
	@param value any
	@return boolean
	Returns `true` if this option contains `value`.
]=]
function Option:Contains(value)
	return self:IsSome() and self._v == value
end


--[=[
	@return string
	Metamethod to transform the option into a string.
	```lua
	local optA = Option.Some(64)
	local optB = Option.None
	print(optA) --> Option<number>
	print(optB) --> Option<None>
	```
]=]
function Option:__tostring()
	if self:IsSome() then
		return ("Option<" .. typeof(self._v) .. ">")
	else
		return "Option<None>"
	end
end


--[=[
	@return boolean
	@param opt Option
	Metamethod to check equality between two options. Returns `true` if both
	options hold the same value _or_ both options are None.
	```lua
	local o1 = Option.Some(32)
	local o2 = Option.Some(32)
	local o3 = Option.Some(64)
	local o4 = Option.None
	local o5 = Option.None

	print(o1 == o2) --> true
	print(o1 == o3) --> false
	print(o1 == o4) --> false
	print(o4 == o5) --> true
	```
]=]
function Option:__eq(opt)
	if Option.Is(opt) then
		if self:IsSome() and opt:IsSome() then
			return (self:Unwrap() == opt:Unwrap())
		elseif self:IsNone() and opt:IsNone() then
			return true
		end
	end
	return false
end


--[=[
	@prop None Option<None>
	@within Option
	Represents no value.
]=]
Option.None = Option._new()


return Option
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="351">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezg2RTE2QkM0LTc0QkYtNDU1RS04OTM2LUY2MjBGODMzMjU5NX0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local Option = require(script.Parent)

	describe("Some", function()

		it("should create some option", function()
			local opt = Option.Some(true)
			expect(opt:IsSome()).to.equal(true)
		end)

		it("should fail to create some option with nil", function()
			expect(function()
				Option.Some(nil)
			end).to.throw()
		end)

		it("should not be none", function()
			local opt = Option.Some(10)
			expect(opt:IsNone()).to.equal(false)
		end)

	end)

	describe("None", function()

		it("should be able to reference none", function()
			expect(function()
				local _none = Option.None
			end).never.to.throw()
		end)

		it("should be able to check if none", function()
			local none = Option.None
			expect(none:IsNone()).to.equal(true)
		end)

		it("should be able to check if not some", function()
			local none = Option.None
			expect(none:IsSome()).to.equal(false)
		end)

	end)

	describe("Equality", function()

		it("should equal the same some from same options", function()
			local opt = Option.Some(32)
			expect(opt).to.equal(opt)
		end)

		it("should equal the same some from different options", function()
			local opt1 = Option.Some(32)
			local opt2 = Option.Some(32)
			expect(opt1).to.equal(opt2)
		end)

	end)

	describe("Assert", function()

		it("should assert that a some option is an option", function()
			expect(Option.Is(Option.Some(10))).to.equal(true)
		end)

		it("should assert that a none option is an option", function()
			expect(Option.Is(Option.None)).to.equal(true)
		end)

		it("should assert that a non-option is not an option", function()
			expect(Option.Is(10)).to.equal(false)
			expect(Option.Is(true)).to.equal(false)
			expect(Option.Is(false)).to.equal(false)
			expect(Option.Is("Test")).to.equal(false)
			expect(Option.Is({})).to.equal(false)
			expect(Option.Is(function() end)).to.equal(false)
			expect(Option.Is(coroutine.create(function() end))).to.equal(false)
			expect(Option.Is(Option)).to.equal(false)
		end)

	end)

	describe("Unwrap", function()

		it("should unwrap a some option", function()
			local opt = Option.Some(10)
			expect(function()
				opt:Unwrap()
			end).never.to.throw()
			expect(opt:Unwrap()).to.equal(10)
		end)

		it("should fail to unwrap a none option", function()
			local opt = Option.None
			expect(function()
				opt:Unwrap()
			end).to.throw()
		end)

	end)

	describe("Expect", function()

		it("should expect a some option", function()
			local opt = Option.Some(10)
			expect(function()
				opt:Expect("Expecting some value")
			end).never.to.throw()
			expect(opt:Unwrap()).to.equal(10)
		end)

		it("should fail when expecting on a none option", function()
			local opt = Option.None
			expect(function()
				opt:Expect("Expecting some value")
			end).to.throw()
		end)

	end)

	describe("ExpectNone", function()

		it("should fail to expect a none option", function()
			local opt = Option.Some(10)
			expect(function()
				opt:ExpectNone("Expecting some value")
			end).to.throw()
		end)

		it("should expect a none option", function()
			local opt = Option.None
			expect(function()
				opt:ExpectNone("Expecting some value")
			end).never.to.throw()
		end)

	end)

	describe("UnwrapOr", function()

		it("should unwrap a some option", function()
			local opt = Option.Some(10)
			expect(opt:UnwrapOr(20)).to.equal(10)
		end)

		it("should unwrap a none option", function()
			local opt = Option.None
			expect(opt:UnwrapOr(20)).to.equal(20)
		end)

	end)

	describe("UnwrapOrElse", function()

		it("should unwrap a some option", function()
			local opt = Option.Some(10)
			local result = opt:UnwrapOrElse(function() return 30 end)
			expect(result).to.equal(10)
		end)

		it("should unwrap a none option", function()
			local opt = Option.None
			local result = opt:UnwrapOrElse(function() return 30 end)
			expect(result).to.equal(30)
		end)

	end)

	describe("And", function()

		it("should return the second option with and when both are some", function()
			local opt1 = Option.Some(1)
			local opt2 = Option.Some(2)
			expect(opt1:And(opt2)).to.equal(opt2)
		end)

		it("should return none when first option is some and second option is none", function()
			local opt1 = Option.Some(1)
			local opt2 = Option.None
			expect(opt1:And(opt2):IsNone()).to.equal(true)
		end)

		it("should return none when first option is none and second option is some", function()
			local opt1 = Option.None
			local opt2 = Option.Some(2)
			expect(opt1:And(opt2):IsNone()).to.equal(true)
		end)

		it("should return none when both options are none", function()
			local opt1 = Option.None
			local opt2 = Option.None
			expect(opt1:And(opt2):IsNone()).to.equal(true)
		end)

	end)

	describe("AndThen", function()

		it("should pass the some value to the predicate", function()
			local opt = Option.Some(32)
			opt:AndThen(function(value)
				expect(value).to.equal(32)
				return Option.None
			end)
		end)

		it("should throw if an option is not returned from predicate", function()
			local opt = Option.Some(32)
			expect(function()
				opt:AndThen(function()
				end)
			end).to.throw()
		end)

		it("should return none if the option is none", function()
			local opt = Option.None
			expect(opt:AndThen(function()
				return Option.Some(10)
			end):IsNone()).to.equal(true)
		end)

		it("should return option of predicate if option is some", function()
			local opt = Option.Some(32)
			local result = opt:AndThen(function()
				return Option.Some(10)
			end)
			expect(result:IsSome()).to.equal(true)
			expect(result:Unwrap()).to.equal(10)
		end)

	end)

	describe("Or", function()

		it("should return the first option if it is some", function()
			local opt1 = Option.Some(10)
			local opt2 = Option.Some(20)
			expect(opt1:Or(opt2)).to.equal(opt1)
		end)

		it("should return the second option if the first one is none", function()
			local opt1 = Option.None
			local opt2 = Option.Some(20)
			expect(opt1:Or(opt2)).to.equal(opt2)
		end)

	end)

	describe("OrElse", function()

		it("should return the first option if it is some", function()
			local opt1 = Option.Some(10)
			local opt2 = Option.Some(20)
			expect(opt1:OrElse(function() return opt2 end)).to.equal(opt1)
		end)

		it("should return the second option if the first one is none", function()
			local opt1 = Option.None
			local opt2 = Option.Some(20)
			expect(opt1:OrElse(function() return opt2 end)).to.equal(opt2)
		end)

		it("should throw if the predicate does not return an option", function()
			local opt1 = Option.None
			expect(function() opt1:OrElse(function() end) end).to.throw()
		end)

	end)

	describe("XOr", function()

		it("should return first option if first option is some and second option is none", function()
			local opt1 = Option.Some(1)
			local opt2 = Option.None
			expect(opt1:XOr(opt2)).to.equal(opt1)
		end)

		it("should return second option if first option is none and second option is some", function()
			local opt1 = Option.None
			local opt2 = Option.Some(2)
			expect(opt1:XOr(opt2)).to.equal(opt2)
		end)

		it("should return none if first and second option are some", function()
			local opt1 = Option.Some(1)
			local opt2 = Option.Some(2)
			expect(opt1:XOr(opt2)).to.equal(Option.None)
		end)

		it("should return none if first and second option are none", function()
			local opt1 = Option.None
			local opt2 = Option.None
			expect(opt1:XOr(opt2)).to.equal(Option.None)
		end)

	end)

	describe("Filter", function()

		it("should return none if option is none", function()
			local opt = Option.None
			expect(opt:Filter(function() end)).to.equal(Option.None)
		end)

		it("should return none if option is some but fails predicate", function()
			local opt = Option.Some(10)
			expect(opt:Filter(function(_v) return false end)).to.equal(Option.None)
		end)

		it("should return self if option is some and passes predicate", function()
			local opt = Option.Some(10)
			expect(opt:Filter(function(_v) return true end)).to.equal(opt)
		end)

	end)

	describe("Contains", function()

		it("should return true if some option contains the given value", function()
			local opt = Option.Some(32)
			expect(opt:Contains(32)).to.equal(true)
		end)

		it("should return false if some option does not contain the given value", function()
			local opt = Option.Some(32)
			expect(opt:Contains(64)).to.equal(false)
		end)

		it("should return false if option is none", function()
			local opt = Option.None
			expect(opt:Contains(64)).to.equal(false)
		end)

	end)

	describe("ToString", function()

		it("should return string of none option", function()
			local opt = Option.None
			expect(tostring(opt)).to.equal("Option<None>")
		end)

		it("should return string of some option with type", function()
			local values = {10, true, false, "test", {}, function() end, coroutine.create(function() end), workspace}
			for _,value in ipairs(values) do
				local expectedString = ("Option<%s>"):format(typeof(value))
				expect(tostring(Option.Some(value))).to.equal(expectedString)
			end
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="352">
          <Properties>
            <string name="Name">sleitnick_signal@1.1.0</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="353">
            <Properties>
              <string name="Name">signal</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0Q3MjMwQTZBLTM0QjAtNDY4QS05RkZFLTQ3NEZDRjk2MDBCNH0=]]></BinaryString>
              <string name="Source"><![CDATA[-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end


--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection


function Connection.new(signal, fn)
	return setmetatable({
		Connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end


function Connection:Disconnect()
	if not self.Connected then return end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})


--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	Signals allow events to be dispatched and handled.

	For example:
	```lua
	local signal = Signal.new()

	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new()
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
	}, Signal)
	return self
end


--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap(rbxScriptSignal)
	assert(typeof(rbxScriptSignal) == "RBXScriptSignal", "Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal))
	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)
	return signal
end


--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj)
	return type(obj) == "table" and getmetatable(obj) == Signal
end


--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end


function Signal:GetConnections()
	local items = {}
	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end
	return items
end


-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false
end


-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end


--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		task.defer(item._fn, ...)
		item = item._next
	end
end


--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end


--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()
	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end


-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="354">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezc4RUM3NEE1LTY1NTYtNEQ3Ri05RkQ5LUI1NDgyQTBBOTk5Qn0=]]></BinaryString>
                <string name="Source"><![CDATA[local function AwaitCondition(predicate, timeout)
	local start = os.clock()
	timeout = (timeout or 10)
	while true do
		if predicate() then return true end
		if (os.clock() - start) > timeout then return false end
		task.wait()
	end
end

return function()

	local Signal = require(script.Parent)

	local signal

	local function NumConns(sig)
		sig = sig or signal
		return #sig:GetConnections()
	end

	beforeEach(function()
		signal = Signal.new()
	end)

	afterEach(function()
		signal:Destroy()
	end)

	describe("Constructor", function()

		it("should create a new signal and fire it", function()
			expect(Signal.Is(signal)).to.equal(true)
			task.defer(function()
				signal:Fire(10, 20)
			end)
			local n1, n2 = signal:Wait()
			expect(n1).to.equal(10)
			expect(n2).to.equal(20)
		end)

		it("should create a proxy signal and connect to it", function()
			local signalWrap = Signal.Wrap(game:GetService("RunService").Heartbeat)
			expect(Signal.Is(signalWrap)).to.equal(true)
			local fired = false
			signalWrap:Connect(function()
				fired = true
			end)
			expect(AwaitCondition(function() return fired end, 2)).to.equal(true)
			signalWrap:Destroy()
		end)

	end)

	describe("FireDeferred", function()

		it("should be able to fire primitive argument", function()
			local send = 10
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:FireDeferred(send)
			expect(AwaitCondition(function() return (send == value) end, 1)).to.equal(true)
		end)

		it("should be able to fire a reference based argument", function()
			local send = {10, 20}
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:FireDeferred(send)
			expect(AwaitCondition(function() return (send == value) end, 1)).to.equal(true)
		end)

	end)

	describe("Fire", function()

		it("should be able to fire primitive argument", function()
			local send = 10
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:Fire(send)
			expect(value).to.equal(send)
		end)

		it("should be able to fire a reference based argument", function()
			local send = {10, 20}
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:Fire(send)
			expect(value).to.equal(send)
		end)

	end)

	describe("Wait", function()

		it("should be able to wait for a signal to fire", function()
			task.defer(function()
				signal:Fire(10, 20, 30)
			end)
			local n1, n2, n3 = signal:Wait()
			expect(n1).to.equal(10)
			expect(n2).to.equal(20)
			expect(n3).to.equal(30)
		end)

	end)

	describe("DisconnectAll", function()

		it("should disconnect all connections", function()
			signal:Connect(function() end)
			signal:Connect(function() end)
			expect(NumConns()).to.equal(2)
			signal:DisconnectAll()
			expect(NumConns()).to.equal(0)
		end)

	end)

	describe("Disconnect", function()

		it("should disconnect connection", function()
			local con = signal:Connect(function() end)
			expect(NumConns()).to.equal(1)
			con:Disconnect()
			expect(NumConns()).to.equal(0)
		end)

		it("should still work if connections disconnected while firing", function()
			local a = 0
			local c
			signal:Connect(function() a += 1 end)
			c = signal:Connect(function() c:Disconnect() a += 1 end)
			signal:Connect(function() a += 1 end)
			signal:Fire()
			expect(a).to.equal(3)
		end)

		it("should still work if connections disconnected while firing deferred", function()
			local a = 0
			local c
			signal:Connect(function() a += 1 end)
			c = signal:Connect(function() c:Disconnect() a += 1 end)
			signal:Connect(function() a += 1 end)
			signal:FireDeferred()
			expect(AwaitCondition(function() return a == 3 end)).to.equal(true)
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="355">
          <Properties>
            <string name="Name">sleitnick_silo@0.1.0</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="356">
            <Properties>
              <string name="Name">silo</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0Y5MzcwODlFLUI5RDQtNEY1Qi1BQjkxLTlDMTYzNzU4OTc0MH0=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict

-- Silo
-- Stephen Leitnick
-- April 29, 2022


--[=[
	@within Silo
	@type State<S> {[string]: any}
	Represents state.
]=]
export type State<S> = S & {[string]: any}

--[=[
	@within Silo
	@type Modifier<S> (State<S>, any) -> ()
	A function that modifies state.
]=]
export type Modifier<S> = (State<S>, any) -> ()

--[=[
	@within Silo
	@interface Action<A>
	.Name string
	.Payload A
	Actions are passed to `Dispatch`. However, typically actions are
	never constructed by hand. Use a silo's Actions table to generate
	these actions.
]=]
type Action<A> = {
	Name: string,
	Payload: A,
}

local Util = require(script.Util)
local TableWatcher = require(script.TableWatcher)

--[=[
	@class Silo
	A Silo is a state container, inspired by Redux slices and
	designed for Roblox developers.
]=]
local Silo = {}
Silo.__index = Silo

--[=[
	@return Silo
	Create a Silo.

	```lua
	local statsSilo = Silo.new({
		-- Initial state:
		Kills = 0,
		Deaths = 0,
		Points = 0,
	}, {
		-- Modifiers are functions that modify the state:
		SetKills = function(state, kills)
			state.Kills = kills
		end,
		AddPoints = function(state, points)
			state.Points += points
		end,
	})

	-- Use Actions to modify the state:
	statsSilo:Dispatch(statsSilo.Actions.SetKills(10))

	-- Use GetState to get the current state:
	print("Kills", statsSilo:GetState().Kills)
	```

	From the above example, note how the modifier functions were transformed
	into functions that can be called from `Actions` with just the single
	payload (no need to pass state). The `SetKills` modifier is then used
	as the `SetKills` action to be dispatched.
]=]
function Silo.new<S>(defaultState: State<S>, modifiers: {Modifier<S>}?)

	local self = setmetatable({}, Silo)

	self._State = Util.DeepFreeze(Util.DeepCopy(defaultState))
	self._Modifiers = {}
	self._Dispatching = false
	self._Parent = self
	self._Subscribers = {}

	self.Actions = {}

	-- Create modifiers and action creators:
	for actionName,modifier in pairs(modifiers or {}) do

		self._Modifiers[actionName] = function(state: State<S>, payload: any)
			-- Create a watcher to virtually watch for state mutations:
			local watcher = TableWatcher(state)
			modifier(watcher, payload)
			-- Apply state mutations into new state table:
			return watcher()
		end

		self.Actions[actionName] = function(payload)
			return {
				Name = actionName,
				Payload = payload,
			}
		end

	end

	return self

end

--[=[
	@param silos {Silo}
	@return Silo
	Constructs a new silo as a combination of other silos.
]=]
function Silo.combine<S>(silos, initialState: State<S>?)

	-- Combine state:
	local state = {}
	for name,silo in pairs(silos) do
		if silo._Dispatching then
			error("cannot combine silos from a modifier", 2)
		end
		state[name] = silo:GetState()
	end

	local combinedSilo = Silo.new(Util.Extend(state, initialState or {}))

	-- Combine modifiers and actions:
	for name,silo in pairs(silos) do
		silo._Parent = combinedSilo
		for actionName,modifier in pairs(silo._Modifiers) do
			-- Prefix action name to keep it unique:
			local fullActionName = name .. "/" .. actionName
			combinedSilo._Modifiers[fullActionName] = function(s, payload)
				-- Extend the top-level state from the sub-silo state modification:
				return Util.Extend(s, {
					[name] = modifier((s :: {[string]: any})[name], payload)
				})
			end
		end
		for actionName in pairs(silo.Actions) do
			-- Update the action creator to include the correct prefixed action name:
			local fullActionName = name .. "/" .. actionName
			silo.Actions[actionName] = function(p)
				return {
					Name = fullActionName,
					Payload = p,
				}
			end
		end
	end

	return combinedSilo

end

--[=[
	Get the current state.

	```lua
	local state = silo:GetState()
	```
]=]
function Silo:GetState<S>(): State<S>
	if self._Parent ~= self then
		error("can only get state from top-level silo", 2)
	end
	return self._State
end

--[=[
	Dispatch an action.

	```lua
	silo:Dispatch(silo.Actions.DoSomething("something"))
	```
]=]
function Silo:Dispatch<A>(action: Action<A>)

	if self._Dispatching then
		error("cannot dispatch from a modifier", 2)
	end
	if self._Parent ~= self then
		error("can only dispatch from top-level silo", 2)
	end

	-- Find and invoke the modifier to modify current state:
	self._Dispatching = true
	local oldState = self._State
	local newState = oldState
	local modifier = self._Modifiers[action.Name]
	if modifier then
		newState = modifier(newState, action.Payload)
	end
	self._Dispatching = false

	-- State changed:
	if newState ~= oldState then

		self._State = Util.DeepFreeze(newState)

		-- Notify subscribers of state change:
		for _,subscriber in ipairs(self._Subscribers) do
			subscriber(newState, oldState)
		end
		
	end

end

--[=[
	Subscribe a function to receive all state updates, including
	initial state (subscriber is called immediately).

	Returns an unsubscribe function. Call the function to unsubscribe.

	```lua
	local unsubscribe = silo:Subscribe(function(newState, oldState)
		-- Do something
	end)

	-- Later on, if desired, disconnect the subscription by calling unsubscribe:
	unsubscribe()
	```
]=]
function Silo:Subscribe<S>(subscriber: (newState: State<S>, oldState: State<S>) -> ()): () -> ()

	if self._Dispatching then
		error("cannot subscribe from within a modifier", 2)
	end
	if self._Parent ~= self then
		error("can only subscribe on top-level silo", 2)
	end
	if table.find(self._Subscribers, subscriber) then
		error("cannot subscribe same function more than once", 2)
	end

	table.insert(self._Subscribers, subscriber)

	-- Unsubscribe:
	return function()
		local index = table.find(self._Subscribers, subscriber)
		if not index then return end
		table.remove(self._Subscribers, index)
	end

end

--[=[
	Watch a specific value within the state, which is selected by the
	`selector` function. The initial value, and any subsequent changes
	grabbed by the selector, will be passed to the `onChange` function.

	Just like `Subscribe`, a function is returned that can be used
	to unsubscribe (i.e. stop watching).

	```lua
	local function SelectPoints(state)
		return state.Statistics.Points
	end

	local unsubscribe = silo:Watch(SelectPoints, function(points)
		print("Points", points)
	end)
	```
]=]
function Silo:Watch<S, T>(selector: (State<S>) -> T, onChange: (T) -> ()): () -> ()

	local value = selector(self:GetState())

	local unsubscribe = self:Subscribe(function(state)
		local newValue = selector(state)
		if newValue == value then return end
		value = newValue
		onChange(value)
	end)

	-- Call initial onChange after subscription to verify subscription didn't fail:
	onChange(value)

	return unsubscribe

end

return Silo
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="357">
              <Properties>
                <string name="Name">TableWatcher</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezhBRjhFNjFDLTNCRDMtNDdGRC1BMTRFLUFFQTY1NUI4NzYwNX0=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict

-- TableWatcher
-- Stephen Leitnick
-- April 29, 2022


type AnyTable = {[any]: any}

type Watcher = {
	Changes: AnyTable,
	Tbl: AnyTable,
}

local Util = require(script.Parent.Util)

local watchers: {[TableWatcher]: Watcher} = {}
setmetatable(watchers, {__mode = "k"})

local WatcherMt = {}

function WatcherMt:__index(index)
	local w = watchers[self]
	local c = w.Changes[index]
	if c ~= nil then
		if c == Util.None then
			return nil
		else
			return c
		end
	end
	return w.Tbl[index]
end

function WatcherMt:__newindex(index, value)
	local w = watchers[self]
	if w.Tbl[index] == value then return end
	if value == nil then
		w.Changes[index] = Util.None
	else
		w.Changes[index] = value
	end
end

function WatcherMt:__call()
	local w = watchers[self]
	if next(w.Changes) == nil then
		return w.Tbl
	end
	return Util.Extend(w.Tbl, w.Changes)
end

local function TableWatcher(t: AnyTable): TableWatcher
	local watcher = setmetatable({}, WatcherMt)
	watchers[watcher] = {
		Changes = {},
		Tbl = t,
	}
	return watcher
end

type TableWatcher = typeof(setmetatable({}, WatcherMt))

return TableWatcher
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="358">
              <Properties>
                <string name="Name">Util</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezQ5NzI1RUQ3LUYyOEQtNDk1My04Q0ZCLUM2NTRCOEJEQjFGRX0=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict

-- Util
-- Stephen Leitnick
-- April 29, 2022


type AnyTable = {[any]: any}

local Util = {}

Util.None = newproxy()

-- Recursive table freeze.
function Util.DeepFreeze(tbl: AnyTable): AnyTable
	table.freeze(tbl)
	for _,v in pairs(tbl) do
		if type(v) == "table" then
			Util.DeepFreeze(v)
		end
	end
	return tbl
end

-- Recursive table copy.
function Util.DeepCopy(tbl: AnyTable): AnyTable
	local newTbl = table.clone(tbl)
	for k,v in pairs(newTbl) do
		if type(v) == "table" then
			newTbl[k] = Util.DeepCopy(v)
		end
	end
	return newTbl
end

-- Extends one table with another.
-- Similar to the spread operator in JavaScript.
function Util.Extend(original: AnyTable, extension: AnyTable): AnyTable
	local t = Util.DeepCopy(original)
	for k,v in pairs(extension) do
		if type(v) == "table" then
			if type(original[k]) == "table" then
				t[k] = Util.Extend(original[k], v)
			else
				t[k] = Util.DeepCopy(v)
			end
		elseif v == Util.None then
			t[k] = nil
		else
			t[k] = v
		end
	end
	return t
end

return Util
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="359">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezA0RDJFMERGLUIyNjgtNEZBOC1CQ0UyLTdDNjA2ODczNTZBNX0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local Silo = require(script.Parent)

	local silo1, silo2, rootSilo

	beforeEach(function()
		silo1 = Silo.new({
			Kills = 0,
			Deaths = 0,
		}, {
			SetKills = function(state, kills)
				state.Kills = kills
			end,
			IncrementDeaths = function(state, deaths)
				state.Deaths += deaths
			end,
		})
		silo2 = Silo.new({
			Money = 0,
		}, {
			AddMoney = function(state, money)
				state.Money += money
			end
		})
		rootSilo = Silo.combine({
			Stats = silo1,
			Econ = silo2,
		})
	end)

	describe("State", function()

		it("should get state properly", function()
			local silo = Silo.new({
				ABC = 10,
			})
			local state = silo:GetState()
			expect(state).to.be.a("table")
			expect(state.ABC).to.equal(10)
		end)

		it("should get state from combined silos", function()
			local state = rootSilo:GetState()
			expect(state).to.be.a("table")
			expect(state.Stats).to.be.a("table")
			expect(state.Econ).to.be.a("table")
			expect(state.Stats.Kills).to.be.a("number")
			expect(state.Stats.Deaths).to.be.a("number")
			expect(state.Econ.Money).to.be.a("number")
		end)

		it("should not allow getting state from sub-silo", function()
			expect(function()
				silo1:GetState()
			end).to.throw()
			expect(function()
				silo2:GetState()
			end).to.throw()
		end)

		it("should throw error if attempting to modify state directly", function()
			expect(function()
				rootSilo:GetState().Stats.Kills = 10
			end).to.throw()
			expect(function()
				rootSilo:GetState().Stats.SomethingNew = 100
			end).to.throw()
			expect(function()
				rootSilo:GetState().Stats = {}
			end).to.throw()
			expect(function()
				rootSilo:GetState().SomethingElse = {}
			end).to.throw()
		end)

	end)

	describe("Dispatch", function()

		it("should dispatch", function()
			expect(rootSilo:GetState().Stats.Kills).to.equal(0)
			rootSilo:Dispatch(silo1.Actions.SetKills(10))
			expect(rootSilo:GetState().Stats.Kills).to.equal(10)
			rootSilo:Dispatch(silo2.Actions.AddMoney(10))
			rootSilo:Dispatch(silo2.Actions.AddMoney(20))
			expect(rootSilo:GetState().Econ.Money).to.equal(30)
		end)

		it("should not allow dispatching from a sub-silo", function()
			expect(function()
				silo1:Dispatch(silo1.Action.SetKills(0))
			end).to.throw()
			expect(function()
				silo2:Dispatch(silo2.Action.AddMoney(0))
			end).to.throw()
		end)

		it("should not allow dispatching from within a modifier", function()
			expect(function()
				local silo
				silo = Silo.new({
					Data = 0,
				}, {
					SetData = function(state, newData)
						state.Data = newData
						silo:Dispatch({Name = "", Payload = 0})
					end,
				})
				silo:Dispatch(silo.Actions.SetData(0))
			end).to.throw()
		end)
		
	end)

	describe("Subscribe", function()

		it("should subscribe to a silo", function()
			local new, old
			local n = 0
			local unsubscribe = rootSilo:Subscribe(function(newState, oldState)
				n += 1
				new, old = newState, oldState
			end)
			expect(n).to.equal(0)
			rootSilo:Dispatch(silo1.Actions.SetKills(10))
			expect(n).to.equal(1)
			expect(new).to.be.a("table")
			expect(old).to.be.a("table")
			expect(new.Stats.Kills).to.equal(10)
			expect(old.Stats.Kills).to.equal(0)
			rootSilo:Dispatch(silo1.Actions.SetKills(20))
			expect(n).to.equal(2)
			expect(new.Stats.Kills).to.equal(20)
			expect(old.Stats.Kills).to.equal(10)
			unsubscribe()
			rootSilo:Dispatch(silo1.Actions.SetKills(30))
			expect(n).to.equal(2)
		end)

		it("should not allow subscribing same function more than once", function()
			local function sub() end
			expect(function()
				rootSilo:Subscribe(sub)
			end).never.to.throw()
			expect(function()
				rootSilo:Subscribe(sub)
			end).to.throw()
		end)

		it("should not allow subscribing to a sub-silo", function()
			expect(function()
				silo1:Subscribe(function() end)
			end).to.throw()
		end)

		it("should not allow subscribing from within a modifier", function()
			expect(function()
				local silo
				silo = Silo.new({
					Data = 0,
				}, {
					SetData = function(state, newData)
						state.Data = newData
						silo:Subscribe(function() end)
					end,
				})
				silo:Dispatch(silo.Actions.SetData(0))
			end).to.throw()
		end)
	
	end)

	describe("Watch", function()

		it("should watch value changes", function()
			local function SelectMoney(state)
				return state.Econ.Money
			end
			local changes = 0
			local currentMoney = 0
			local unsubscribeWatch = rootSilo:Watch(SelectMoney, function(money)
				changes += 1
				currentMoney = money
			end)
			expect(changes).to.equal(1)
			rootSilo:Dispatch(silo2.Actions.AddMoney(10))
			expect(changes).to.equal(2)
			expect(currentMoney).to.equal(10)
			rootSilo:Dispatch(silo2.Actions.AddMoney(20))
			expect(changes).to.equal(3)
			expect(currentMoney).to.equal(30)
			rootSilo:Dispatch(silo2.Actions.AddMoney(0))
			expect(changes).to.equal(3)
			expect(currentMoney).to.equal(30)
			rootSilo:Dispatch(silo1.Actions.SetKills(10))
			expect(changes).to.equal(3)
			expect(currentMoney).to.equal(30)
			unsubscribeWatch()
			rootSilo:Dispatch(silo2.Actions.AddMoney(10))
			expect(changes).to.equal(3)
			expect(currentMoney).to.equal(30)
		end)
		
	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="360">
          <Properties>
            <string name="Name">sleitnick_streamable@1.2.3</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="361">
            <Properties>
              <string name="Name">Signal</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezJEMEFGQjdDLTk4REEtNEM2QS05NkY0LTY4NjI0OTQzODM2MH0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_signal@1.1.0"]["signal"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="362">
            <Properties>
              <string name="Name">Trove</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezVDOUJBMDdDLTJFQjQtNDA2MC05Mzc2LTI2ODEyNEQwNjlDRX0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_trove@0.4.0"]["trove"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="363">
            <Properties>
              <string name="Name">streamable</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezIwRjU2NzQ4LTZCOEEtNDA3RC04Qzc5LUNCOUNCN0Y4NEFERH0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Streamable
-- Stephen Leitnick
-- November 08, 2021


return {
	Streamable = require(script.Streamable);
	StreamableUtil = require(script.StreamableUtil);
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="364">
              <Properties>
                <string name="Name">Streamable</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0JCOEM1NkRGLTY0ODYtNEZCNS04NDE1LTQwQjc2NTQ0RUYwRn0=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict

-- Streamable
-- Stephen Leitnick
-- March 03, 2021

type StreamableWithInstance = {
	Instance: Instance?,
	[any]: any,
}

local Trove = require(script.Parent.Parent.Trove)
local Signal = require(script.Parent.Parent.Signal)


--[=[
	@within Streamable
	@prop Instance Instance
	The current instance represented by the Streamable. If this
	is being observed, it will always exist. If not currently
	being observed, this will be `nil`.
]=]

--[=[
	@class Streamable
	@client
	Because parts in StreamingEnabled games can stream in and out of existence at
	any point in time, it is hard to write code to interact with them. This is
	where Streamables come into play. Streamables will observe the existence of
	a given instance, and will signal when the instance exists and does not
	exist.

	The API is very simple. Create a Streamable that points to a certain parent
	and looks for a specific child instance (typically a BasePart). Then, call
	the `Observe` method to observe when the instance streams in and out.

	```lua
	local Streamable = require(packages.Streamable).Streamable

	-- Models might take a bit to load, but the model instance
	-- is never removed, thus we can use WaitForChild.
	local model = workspace:WaitForChild("MyModel")

	-- Watch for a specific part in the model:
	local partStreamable = Streamable.new(model, "SomePart")

	partStreamable:Observe(function(part, trove)
		print(part:GetFullName() .. " added")
		-- Run code on the part here.
		-- Use the trove to manage cleanup when the part goes away.
		trove:Add(function()
			-- General cleanup stuff
			print(part.Name .. " removed")
		end)
	end)

	-- Watch for the PrimaryPart of a model to exist:
	local primaryStreamable = Streamable.primary(model)
	primaryStreamable:Observe(function(primary, trove)
		print("Model now has a PrimaryPart:", primary.Name)
		trove:Add(function()
			print("Model's PrimaryPart has been removed")
		end)
	end)

	-- At any given point, accessing the Instance field will
	-- reference the observed part, if it exists:
	if partStreamable.Instance then
		print("Streamable has its instance:", partStreamable.Instance)
	end

	-- When/if done, call Destroy on the streamable, which will
	-- also clean up any observers:
	partStreamable:Destroy()
	primaryStreamable:Destroy()
	```

	For more information on the mechanics of how StreamingEnabled works
	and what sort of behavior to expect, see the
	[Content Streaming](https://developer.roblox.com/en-us/articles/content-streaming#technical-behavior)
	page. It is important to understand that only BaseParts and their descendants are streamed in/out,
	whereas other instances are loaded during the initial client load. It is also important to understand
	that streaming only occurs on the client. The server has immediate access to everything right away.
]=]
local Streamable = {}
Streamable.__index = Streamable


--[=[
	@return Streamable
	@param parent Instance
	@param childName string

	Constructs a Streamable that watches for a direct child of name `childName`
	within the `parent` Instance. Call `Observe` to observe the existence of
	the child within the parent.
]=]
function Streamable.new(parent: Instance, childName: string)

	local self: StreamableWithInstance = {}
	setmetatable(self, Streamable)

	self._trove = Trove.new()
	self._shown = self._trove:Construct(Signal)
	self._shownTrove = Trove.new()
	self._trove:Add(self._shownTrove)

	self.Instance = parent:FindFirstChild(childName)

	local function OnInstanceSet()
		local instance = self.Instance
		if typeof(instance) == "Instance" then
			self._shown:Fire(instance, self._shownTrove)
			self._shownTrove:Connect(instance:GetPropertyChangedSignal("Parent"), function()
				if not instance.Parent then
					self._shownTrove:Clean()
				end
			end)
			self._shownTrove:Add(function()
				if self.Instance == instance then
					self.Instance = nil
				end
			end)
		end
	end

	local function OnChildAdded(child: Instance)
		if child.Name == childName and not self.Instance then
			self.Instance = child
			OnInstanceSet()
		end
	end

	self._trove:Connect(parent.ChildAdded, OnChildAdded)
	if self.Instance then
		OnInstanceSet()
	end

	return self

end


--[=[
	@return Streamable
	@param parent Model

	Constructs a streamable that watches for the PrimaryPart of the
	given `parent` Model.
]=]
function Streamable.primary(parent: Model)

	local self: StreamableWithInstance = {}
	setmetatable(self, Streamable)

	self._trove = Trove.new()
	self._shown = self._trove:Construct(Signal)
	self._shownTrove = Trove.new()
	self._trove:Add(self._shownTrove)

	self.Instance = parent.PrimaryPart

	local function OnPrimaryPartChanged()
		local primaryPart = parent.PrimaryPart
		self._shownTrove:Clean()
		self.Instance = primaryPart
		if primaryPart then
			self._shown:Fire(primaryPart, self._shownTrove)
		end
	end

	self._trove:Connect(parent:GetPropertyChangedSignal("PrimaryPart"), OnPrimaryPartChanged)
	if self.Instance then
		OnPrimaryPartChanged()
	end

	return self
	
end


--[=[
	@param handler (instance: Instance, trove: Trove) -> nil
	@return Connection

	Observes the instance. The handler is called anytime the
	instance comes into existence, and the trove given is
	cleaned up when the instance goes away.

	To stop observing, disconnect the returned connection.
]=]
function Streamable:Observe(handler)
	if self.Instance then
		task.spawn(handler, self.Instance, self._shownTrove)
	end
	return self._shown:Connect(handler)
end


--[=[
	Destroys the Streamable. Any observers will be disconnected,
	which also means that troves within observers will be cleaned
	up. This should be called when a streamable is no longer needed.
]=]
function Streamable:Destroy()
	self._trove:Destroy()
end


export type Streamable = typeof(Streamable.new(workspace, "X"))


return Streamable
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="365">
              <Properties>
                <string name="Name">Streamable.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezIwRDc5QzcyLTEyOUQtNERERi05MzY0LTQ0NUIyNkE1NjhEOH0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local Streamable = require(script.Parent.Streamable)

	local instanceFolder
	local instanceModel

	local function CreateInstance(name)
		local folder = Instance.new("Folder")
		folder.Name = name
		folder.Archivable = false
		folder.Parent = instanceFolder
		return folder
	end

	local function CreatePrimary()
		local primary = Instance.new("Part")
		primary.Anchored = true
		primary.Parent = instanceModel
		instanceModel.PrimaryPart = primary
		return primary
	end

	beforeAll(function()
		instanceFolder = Instance.new("Folder")
		instanceFolder.Name = "KnitTestFolder"
		instanceFolder.Archivable = false
		instanceFolder.Parent = workspace
		instanceModel = Instance.new("Model")
		instanceModel.Name = "KnitTestModel"
		instanceModel.Archivable = false
		instanceModel.Parent = workspace
	end)

	afterEach(function()
		instanceFolder:ClearAllChildren()
		instanceModel:ClearAllChildren()
	end)

	afterAll(function()
		instanceFolder:Destroy()
		instanceModel:Destroy()
	end)

	describe("Streamable", function()

		it("should detect instance that is immediately available", function()
			local testInstance = CreateInstance("TestImmediate")
			local streamable = Streamable.new(instanceFolder, "TestImmediate")
			local observed = 0
			local cleaned = 0
			streamable:Observe(function(_instance, trove)
				observed += 1
				trove:Add(function()
					cleaned += 1
				end)
			end)
			task.wait()
			testInstance.Parent = nil
			task.wait()
			testInstance.Parent = instanceFolder
			task.wait()
			streamable:Destroy()
			task.wait()
			expect(observed).to.equal(2)
			expect(cleaned).to.equal(2)
		end)

		it("should detect instance that is not immediately available", function()
			local streamable = Streamable.new(instanceFolder, "TestImmediate")
			local observed = 0
			local cleaned = 0
			streamable:Observe(function(_instance, trove)
				observed += 1
				trove:Add(function()
					cleaned += 1
				end)
			end)
			task.wait(0.1)
			local testInstance = CreateInstance("TestImmediate")
			task.wait()
			testInstance.Parent = nil
			task.wait()
			testInstance.Parent = instanceFolder
			task.wait()
			streamable:Destroy()
			task.wait()
			expect(observed).to.equal(2)
			expect(cleaned).to.equal(2)
		end)
		
		it("should detect primary part that is immediately available", function()
			local testInstance = CreatePrimary()
			local streamable = Streamable.primary(instanceModel)
			local observed = 0
			local cleaned = 0
			streamable:Observe(function(_instance, trove)
				observed += 1
				trove:Add(function()
					cleaned += 1
				end)
			end)
			task.wait()
			testInstance.Parent = nil
			task.wait()
			testInstance.Parent = instanceModel
			instanceModel.PrimaryPart = testInstance
			task.wait()
			streamable:Destroy()
			task.wait()
			expect(observed).to.equal(2)
			expect(cleaned).to.equal(2)
		end)
		
		it("should detect primary part that is not immediately available", function()
			local streamable = Streamable.primary(instanceModel)
			local observed = 0
			local cleaned = 0
			streamable:Observe(function(_instance, trove)
				observed += 1
				trove:Add(function()
					cleaned += 1
				end)
			end)
			task.wait(0.1)
			local testInstance = CreatePrimary()
			task.wait()
			testInstance.Parent = nil
			task.wait()
			testInstance.Parent = instanceModel
			instanceModel.PrimaryPart = testInstance
			task.wait()
			streamable:Destroy()
			task.wait()
			expect(observed).to.equal(2)
			expect(cleaned).to.equal(2)
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="366">
              <Properties>
                <string name="Name">StreamableUtil</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezI5RjA0NENGLUE4QUItNEREMS1BQTQzLTk0QzUzMjkyM0M4NX0=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict

-- StreamableUtil
-- Stephen Leitnick
-- March 03, 2021


local Trove = require(script.Parent.Parent.Trove)
local _Streamable = require(script.Parent.Streamable)


type Streamables = {_Streamable.Streamable}
type CompoundHandler = (Streamables, any) -> nil


--[=[
	@class StreamableUtil
	@client
	A utility library for the Streamable class.

	```lua
	local StreamableUtil = require(packages.Streamable).StreamableUtil
	```
]=]
local StreamableUtil = {}


--[=[
	@param streamables {Streamable}
	@param handler ({[child: string]: Instance}, trove: Trove) -> nil
	@return Trove

	Creates a compound streamable around all the given streamables. The compound
	streamable's observer handler will be fired once _all_ the given streamables
	are in existence, and will be cleaned up when _any_ of the streamables
	disappear.

	```lua
	local s1 = Streamable.new(workspace, "Part1")
	local s2 = Streamable.new(workspace, "Part2")

	local compoundTrove = StreamableUtil.Compound({S1 = s1, S2 = s2}, function(streamables, trove)
		local part1 = streamables.S1.Instance
		local part2 = streamables.S2.Instance
		trove:Add(function()
			print("Cleanup")
		end)
	end)
	```
]=]
function StreamableUtil.Compound(streamables: Streamables, handler: CompoundHandler)
	local compoundTrove = Trove.new()
	local observeAllTrove = Trove.new()
	local allAvailable = false
	local function Check()
		if allAvailable then return end
		for _,streamable in pairs(streamables) do
			if not streamable.Instance then
				return
			end
		end
		allAvailable = true
		handler(streamables, observeAllTrove)
	end
	local function Cleanup()
		if not allAvailable then return end
		allAvailable = false
		observeAllTrove:Clean()
	end
	for _,streamable in pairs(streamables) do
		compoundTrove:Add(streamable:Observe(function(_child, trove)
			Check()
			trove:Add(Cleanup)
		end))
	end
	compoundTrove:Add(Cleanup)
	return compoundTrove
end


return StreamableUtil
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="367">
              <Properties>
                <string name="Name">StreamableUtil.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezI0NjJBMTE4LURDMUMtNENGNS1BNDdCLUNBRTdBNjk2NEE3MX0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local Streamable = require(script.Parent.Streamable)
	local StreamableUtil = require(script.Parent.StreamableUtil)

	local instanceFolder

	local function CreateInstance(name)
		local folder = Instance.new("Folder")
		folder.Name = name
		folder.Archivable = false
		folder.Parent = instanceFolder
		return folder
	end

	beforeAll(function()
		instanceFolder = Instance.new("Folder")
		instanceFolder.Name = "KnitTest"
		instanceFolder.Archivable = false
		instanceFolder.Parent = workspace
	end)

	afterEach(function()
		instanceFolder:ClearAllChildren()
	end)

	afterAll(function()
		instanceFolder:Destroy()
	end)

	describe("Compound", function()

		it("should capture multiple streams", function()
			local s1 = Streamable.new(instanceFolder, "ABC")
			local s2 = Streamable.new(instanceFolder, "XYZ")
			local observe = 0
			local cleaned = 0
			StreamableUtil.Compound({S1 = s1; S2 = s2}, function(_streamables, trove)
				observe += 1
				trove:Add(function()
					cleaned += 1
				end)
			end)
			local i1 = CreateInstance("ABC")
			local i2 = CreateInstance("XYZ")
			task.wait()
			i1.Parent = nil
			task.wait()
			i1.Parent = instanceFolder
			task.wait()
			i1.Parent = nil
			i2.Parent = nil
			task.wait()
			i2.Parent = instanceFolder
			task.wait()
			expect(observe).to.equal(2)
			expect(cleaned).to.equal(2)
			s1:Destroy()
			s2:Destroy()
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="368">
          <Properties>
            <string name="Name">sleitnick_symbol@2.0.0</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="369">
            <Properties>
              <string name="Name">symbol</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezdFQzA4MzY3LTRDRjQtNDlFMi1BQTMyLTRDNzA2QkMyQzE3Nn0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Symbol
-- Stephen Leitnick
-- January 04, 2022


--[=[
	@class Symbol

	Represents a unique object.

	Symbols are often used as unique keys in tables. This is useful to avoid possible collisions
	with a key in a table, since the symbol will always be unique and cannot be reconstructed.

	
	:::note All Unique
	Every creation of a symbol is unique, even if the
	given names are the same.
	:::

	```lua
	local Symbol = require(packages.Symbol)
	
	-- Create a symbol:
	local symbol = Symbol("MySymbol")

	-- The name is optional:
	local anotherSymbol = Symbol()

	-- Comparison:
	print(symbol == symbol) --> true

	-- All symbol constructions are unique, regardless of the name:
	print(Symbol("Hello") == Symbol("Hello")) --> false

	-- Commonly used as unique keys in a table:
	local DATA_KEY = Symbol("Data")
	local t = {
		-- Can only be accessed using the DATA_KEY symbol:
		[DATA_KEY] = {}
	}

	print(t[DATA_KEY]) --> {}
	```
]=]

local function Symbol(name: string?)
	local symbol = newproxy(true)
	if not name then
		name = ""
	end
	getmetatable(symbol).__tostring = function()
		return "Symbol(" .. name .. ")"
	end
	return symbol
end

return Symbol
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="370">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezA5N0JBRTk0LTNERUEtNDE2My1CRkVFLTFBNEI2NUNDMjJBOX0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local Symbol = require(script.Parent)

	describe("Constructor", function()

		it("should create a new symbol", function()
			local symbol = Symbol("Test")
			expect(symbol).to.be.a("userdata")
			expect(symbol == symbol).to.equal(true)
			expect(tostring(symbol)).to.equal("Symbol(Test)")
		end)

		it("should create a new symbol with no name", function()
			local symbol = Symbol()
			expect(symbol).to.be.a("userdata")
			expect(symbol == symbol).to.equal(true)
			expect(tostring(symbol)).to.equal("Symbol()")
		end)

		it("should be unique regardless of the name", function()
			expect(Symbol("Test") == Symbol("Test")).to.equal(false)
			expect(Symbol() == Symbol()).to.equal(false)
			expect(Symbol("Test") == Symbol()).to.equal(false)
			expect(Symbol("Test1") == Symbol("Test2")).to.equal(false)
		end)

		it("should be useable as a table key", function()
			local symbol = Symbol()
			local t = {}
			t[symbol] = 100
			expect(t[symbol]).to.equal(100)
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="371">
          <Properties>
            <string name="Name">sleitnick_table-util@1.1.1</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="372">
            <Properties>
              <string name="Name">table-util</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezYzQjVBNDdDLUE5M0UtNDZGMi1CNTc4LTQ1Rjc2RjAyMERDQX0=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict

-- TableUtil
-- Stephen Leitnick
-- September 13, 2017


type Table = {any}
type MapPredicate = (any, any, Table) -> any
type FilterPredicate = (any, any, Table) -> boolean
type ReducePredicate = (number, any, any, Table) -> any
type FindCallback = (any, any, Table) -> boolean
type IteratorFunc = (t: Table, k: any) -> (any, any)

--[=[
	@class TableUtil

	A collection of helpful table utility functions. Many of these functions are carried over from JavaScript or
	Python that are not present in Lua.

	Tables that only work specifically with arrays or dictionaries are marked as such in the documentation.

	:::info Immutability
	All functions (_except_ `SwapRemove`, `SwapRemoveFirstValue`, and `Lock`) treat tables as immutable and will return
	copies of the given table(s) with the operations performed on the copies.
]=]
local TableUtil = {}

local HttpService = game:GetService("HttpService")
local rng = Random.new()


--[=[
	@within TableUtil
	@function Copy
	@param tbl table -- Table to copy
	@param deep boolean? -- Whether or not to perform a deep copy
	@return table

	Creates a copy of the given table. By default, a shallow copy is
	performed. For deep copies, a second boolean argument must be
	passed to the function.

	:::caution No cyclical references
	Deep copies are _not_ protected against cyclical references. Passing
	a table with cyclical references _and_ the `deep` parameter set to
	`true` will result in a stack-overflow.
]=]
local function Copy(t: Table, deep: boolean?): Table
	if deep then
		local function DeepCopy(tbl)
			local tCopy = table.create(#tbl)
			for k,v in pairs(tbl) do
				if type(v) == "table" then
					tCopy[k] = DeepCopy(v)
				else
					tCopy[k] = v
				end
			end
			return tCopy
		end
		return DeepCopy(t)
	else
		if #t > 0 then
			return table.move(t, 1, #t, 1, table.create(#t))
		else
			local tCopy = {}
			for k,v in pairs(t) do
				tCopy[k] = v
			end
			return tCopy
		end
	end
end


--[=[
	@within TableUtil
	@function Sync
	@param srcTbl table -- Source table
	@param templateTbl table -- Template table
	@return table

	Synchronizes the `srcTbl` based on the `templateTbl`. This will make
	sure that `srcTbl` has all of the same keys as `templateTbl`, including
	removing keys in `srcTbl` that are not present in `templateTbl`. This
	is a _deep_ operation, so any nested tables will be synchronized as
	well.

	```lua
	local template = {kills = 0, deaths = 0, xp = 0}
	local data = {kills = 10, experience = 12}
	data = TableUtil.Sync(data, template)
	print(data) --> {kills = 10, deaths = 0, xp = 0}
	```

	:::caution Data Loss Warning
	This is a two-way sync, so the source table will have data
	_removed_ that isn't found in the template table. This can
	be problematic if used for player data, where there might
	be dynamic data added that isn't in the template.

	For player data, use `TableUtil.Reconcile` instead.
]=]
local function Sync(srcTbl: Table, templateTbl: Table): Table

	assert(type(srcTbl) == "table", "First argument must be a table")
	assert(type(templateTbl) == "table", "Second argument must be a table")

	local tbl = Copy(srcTbl)

	-- If 'tbl' has something 'templateTbl' doesn't, then remove it from 'tbl'
	-- If 'tbl' has something of a different type than 'templateTbl', copy from 'templateTbl'
	-- If 'templateTbl' has something 'tbl' doesn't, then add it to 'tbl'
	for k,v in pairs(tbl) do

		local vTemplate = templateTbl[k]

		-- Remove keys not within template:
		if vTemplate == nil then
			tbl[k] = nil

		-- Synchronize data types:
		elseif type(v) ~= type(vTemplate) then
			if type(vTemplate) == "table" then
				tbl[k] = Copy(vTemplate, true)
			else
				tbl[k] = vTemplate
			end

		-- Synchronize sub-tables:
		elseif type(v) == "table" then
			tbl[k] = Sync(v, vTemplate)
		end

	end

	-- Add any missing keys:
	for k,vTemplate in pairs(templateTbl) do

		local v = tbl[k]

		if v == nil then
			if type(vTemplate) == "table" then
				tbl[k] = Copy(vTemplate, true)
			else
				tbl[k] = vTemplate
			end
		end

	end

	return tbl

end


--[=[
	@within TableUtil
	@function Reconcile
	@param source table
	@param template table
	@return table

	Performs a one-way sync on the `source` table against the
	`template` table. Any keys found in `template` that are
	not found in `source` will be added to `source`. This is
	useful for syncing player data against data template tables
	to ensure players have all the necessary keys, while
	maintaining existing keys that may no longer be in the
	template.

	This is a deep operation, so nested tables will also be
	properly reconciled.

	```lua
	local template = {kills = 0, deaths = 0, xp = 0}
	local data = {kills = 10, abc = 20}
	local correctedData = TableUtil.Reconcile(data, template)
	
	print(correctedData) --> {kills = 10, deaths = 0, xp = 0, abc = 30}
	```
]=]
local function Reconcile(src: Table, template: Table): Table

	assert(type(src) == "table", "First argument must be a table")
	assert(type(template) == "table", "Second argument must be a table")

	local tbl = Copy(src)

	for k,v in pairs(template) do
		local sv = src[k]
		if sv == nil then
			if type(v) == "table" then
				tbl[k] = Copy(v, true)
			else
				tbl[k] = v
			end
		elseif type(sv) == "table" then
			if type(v) == "table" then
				tbl[k] = Reconcile(sv, v)
			else
				tbl[k] = Copy(sv, true)
			end
		end
	end

	return tbl

end


--[=[
	@within TableUtil
	@function SwapRemove
	@param tbl table -- Array
	@param i number -- Index

	Removes index `i` in the table by swapping the value at `i` with
	the last value in the array, and then trimming off the last
	value from the array.

	This allows removal of the value at `i` in `O(1)` time, but does
	not preserve array ordering. If a value needs to be removed from
	an array, but ordering of the array does not matter, using
	`SwapRemove` is always preferred over `table.remove`.

	In the following example, we remove "B" at index 2. SwapRemove does
	this by moving the last value "E" over top of "B", and then trimming
	off "E" at the end of the array:
	```lua
	local t = {"A", "B", "C", "D", "E"}
	TableUtil.SwapRemove(t, 2) -- Remove "B"
	print(t) --> {"A", "E", "C", "D"}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function SwapRemove(t: Table, i: number)
	local n = #t
	t[i] = t[n]
	t[n] = nil
end


--[=[
	@within TableUtil
	@function SwapRemoveFirstValue
	@param tbl table -- Array
	@param v any -- Value to find
	@return number?

	Performs `table.find(tbl, v)` to find the index of the given
	value, and then performs `TableUtil.SwapRemove` on that index.

	```lua
	local t = {"A", "B", "C", "D", "E"}
	TableUtil.SwapRemoveFirstValue(t, "C")
	print(t) --> {"A", "B", "E", "D"}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function SwapRemoveFirstValue(t: Table, v: any): number?
	local index: number? = table.find(t, v)
	if index then
		SwapRemove(t, index)
	end
	return index
end


--[=[
	@within TableUtil
	@function Map
	@param tbl table
	@param predicate (value: any, key: any, tbl: table) -> newValue: any
	@return table

	Performs a map operation against the given table, which can be used to
	map new values based on the old values at given keys/indices.

	For example:

	```lua
	local t = {A = 10, B = 20, C = 30}
	local t2 = TableUtil.Map(t, function(key, value)
		return value * 2
	end)
	print(t2) --> {A = 20, B = 40, C = 60}
	```
]=]
local function Map(t: Table, f: MapPredicate): Table
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be a function")
	local newT = table.create(#t)
	for k,v in pairs(t) do
		newT[k] = f(v, k, t)
	end
	return newT
end


--[=[
	@within TableUtil
	@function Filter
	@param tbl table
	@param predicate (value: any, key: any, tbl: table) -> keep: boolean
	@return table

	Performs a filter operation against the given table, which can be used to
	filter out unwanted values from the table.

	For example:

	```lua
	local t = {A = 10, B = 20, C = 30}
	local t2 = TableUtil.Filter(t, function(key, value)
		return value > 15
	end)
	print(t2) --> {B = 40, C = 60}
	```
]=]
local function Filter(t: Table, f: FilterPredicate): Table
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be a function")
	local newT = table.create(#t)
	if #t > 0 then
		local n = 0
		for i,v in ipairs(t) do
			if f(v, i, t) then
				n += 1
				newT[n] = v
			end
		end
	else
		for k,v in pairs(t) do
			if f(v, k, t) then
				newT[k] = v
			end
		end
	end
	return newT
end


--[=[
	@within TableUtil
	@function Reduce
	@param tbl table
	@param predicate (accumulator: any, value: any, index: any, tbl: table) -> result: any
	@return table

	Performs a reduce operation against the given table, which can be used to
	reduce the table into a single value. This could be used to sum up a table
	or transform all the values into a compound value of any kind.

	For example:

	```lua
	local t = {10, 20, 30, 40}
	local result = TableUtil.Reduce(t, function(accum, value)
		return accum + value
	end)
	print(result) --> 100
	```
]=]
local function Reduce(t: Table, f: ReducePredicate, init: any?): any
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be a function")
	local result = init
	if #t > 0 then
		local start = 1
		if init == nil then
			result = t[1]
			start = 2
		end
		for i = start,#t do
			result = f(result, t[i], i, t)
		end
	else
		local start = nil
		if init == nil then
			result = next(t)
			start = result
		end
		for k,v in next,t,start do
			result = f(result, v, k, t)
		end
	end
	return result
end


--[=[
	@within TableUtil
	@function Assign
	@param target table
	@param ... table
	@return table

	Copies all values of the given tables into the `target` table.

	```lua
	local t = {A = 10}
	local t2 = {B = 20}
	local t3 = {C = 30, D = 40}
	local newT = TableUtil.Assign(t, t2, t3)
	print(newT) --> {A = 10, B = 20, C = 30, D = 40}
	```
]=]
local function Assign(target: Table, ...: Table): Table
	local tbl = Copy(target)
	for _,src in ipairs({...}) do
		for k,v in pairs(src) do
			tbl[k] = v
		end
	end
	return tbl
end


--[=[
	@within TableUtil
	@function Extend
	@param target table
	@param extension table
	@return table

	Extends the target array with the extension array.

	```lua
	local t = {10, 20, 30}
	local t2 = {30, 40, 50}
	local tNew = TableUtil.Extend(t, t2)
	print(tNew) --> {10, 20, 30, 30, 40, 50}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Extend(target: Table, extension: Table): Table
	local tbl = Copy(target)
	for _,v in ipairs(extension) do
		table.insert(tbl, v)
	end
	return tbl
end


--[=[
	@within TableUtil
	@function Reverse
	@param tbl table
	@return table

	Reverses the array.

	```lua
	local t = {1, 5, 10}
	local tReverse = TableUtil.Reverse(t)
	print(tReverse) --> {10, 5, 1}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Reverse(tbl: Table): Table
	local n = #tbl
	local tblRev = table.create(n)
	for i = 1,n do
		tblRev[i] = tbl[n - i + 1]
	end
	return tblRev
end


--[=[
	@within TableUtil
	@function Shuffle
	@param tbl table
	@param rngOverride Random?
	@return table

	Shuffles the table.

	```lua
	local t = {1, 2, 3, 4, 5, 6, 7, 8, 9}
	local shuffled = TableUtil.Shuffle(t)
	print(shuffled) --> e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Shuffle(tbl: Table, rngOverride: Random?): Table
	assert(type(tbl) == "table", "First argument must be a table")
	local shuffled = Copy(tbl)
	local random = if typeof(rngOverride) == "Random" then rngOverride else rng
	for i = #tbl, 2, -1 do
		local j = random:NextInteger(1, i)
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	end
	return shuffled
end


--[=[
	@within TableUtil
	@function Sample
	@param tbl table
	@param sampleSize number
	@param rngOverride Random?
	@return table

	Returns a random sample of the table.

	```lua
	local t = {1, 2, 3, 4, 5, 6, 7, 8, 9}
	local sample = TableUtil.Sample(t, 3)
	print(sample) --> e.g. {6, 2, 5}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Sample(tbl: Table, size: number, rngOverride: Random?): Table
	assert(type(tbl) == "table", "First argument must be a table")
	assert(type(size) == "number", "Second argument must be a number")
	local shuffled = Copy(tbl)
	local sample = table.create(size)
	local random = if typeof(rngOverride) == "Random" then rngOverride else rng
	local len = #tbl
	size = math.clamp(size, 1, len)
	for i = 1,size do
		local j = random:NextInteger(i, len)
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	end
	table.move(shuffled, 1, size, 1, sample)
	return sample
end


--[=[
	@within TableUtil
	@function Flat
	@param tbl table
	@param depth number?
	@return table

	Returns a new table where all sub-arrays have been
	bubbled up to the top. The depth at which the scan
	is performed is dictated by the `depth` parameter,
	which is set to `1` by default.

	```lua
	local t = {{10, 20}, {90, 100}, {30, 15}}
	local flat = TableUtil.Flat(t)
	print(flat) --> {10, 20, 90, 100, 30, 15}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Flat(tbl: Table, depth: number?): Table
	local maxDepth: number = if type(depth) == "number" then depth else 1
	local flatTbl = table.create(#tbl)
	local function Scan(t: Table, d: number)
		for _,v in ipairs(t) do
			if type(v) == "table" and d < maxDepth then
				Scan(v, d + 1)
			else
				table.insert(flatTbl, v)
			end
		end
	end
	Scan(tbl, 0)
	return flatTbl
end


--[=[
	@within TableUtil
	@function FlatMap
	@param tbl table
	@param predicate (key: any, value: any, tbl: table) -> newValue: any
	@return table

	Calls `TableUtil.Map` on the given table and predicate, and then
	calls `TableUtil.Flat` on the result from the map operation.

	```lua
	local t = {10, 20, 30}
	local result = TableUtil.FlatMap(t, function(value)
		return {value, value * 2}
	end)
	print(result) --> {10, 20, 20, 40, 30, 60}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function FlatMap(tbl: Table, callback: MapPredicate): Table
	return Flat(Map(tbl, callback))
end


--[=[
	@within TableUtil
	@function Keys
	@param tbl table
	@return table

	Returns an array with all the keys in the table.

	```lua
	local t = {A = 10, B = 20, C = 30}
	local keys = TableUtil.Keys(t)
	print(keys) --> {"A", "B", "C"}
	```

	:::caution Ordering
	The ordering of the keys is never guaranteed. If order is imperative, call
	`table.sort` on the resulting `keys` array.
	```lua
	local keys = TableUtil.Keys(t)
	table.sort(keys)
	```
]=]
local function Keys(tbl: Table): Table
	local keys = table.create(#tbl)
	for k in pairs(tbl) do
		table.insert(keys, k)
	end
	return keys
end


--[=[
	@within TableUtil
	@function Find
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return (value: any?, key: any?)

	Performs a linear scan across the table and calls `callback` on
	each item in the array. Returns the value and key of the first
	pair in which the callback returns `true`.

	```lua
	local t = {
		{Name = "Bob", Age = 20};
		{Name = "Jill", Age = 30};
		{Name = "Ann", Age = 25};
	}

	-- Find first person who has a name starting with J:
	local firstPersonWithJ = TableUtil.Find(t, function(person)
		return person.Name:sub(1, 1):lower() == "j"
	end)

	print(firstPersonWithJ) --> {Name = "Jill", Age = 30}
	```

	:::caution Dictionary Ordering
	While `Find` can also be used with dictionaries, dictionary ordering is never
	guaranteed, and thus the result could be different if there are more
	than one possible matches given the data and callback function.
]=]
local function Find(tbl: Table, callback: FindCallback): (any?, any?)
	for k,v in pairs(tbl) do
		if callback(v, k, tbl) then
			return v, k
		end
	end
	return nil, nil
end


--[=[
	@within TableUtil
	@function Every
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return boolean

	Returns `true` if the `callback` also returns `true` for _every_
	item in the table.

	```lua
	local t = {10, 20, 40, 50, 60}

	local allAboveZero = TableUtil.Every(t, function(value)
		return value > 0
	end)

	print("All above zero:", allAboveZero) --> All above zero: true
	```
]=]
local function Every(tbl: Table, callback: FindCallback): boolean
	for k,v in pairs(tbl) do
		if not callback(v, k, tbl) then
			return false
		end
	end
	return true
end


--[=[
	@within TableUtil
	@function Some
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return boolean

	Returns `true` if the `callback` also returns `true` for _at least
	one_ of the items in the table.

	```lua
	local t = {10, 20, 40, 50, 60}

	local someBelowTwenty = TableUtil.Some(t, function(value)
		return value < 20
	end)

	print("Some below twenty:", someBelowTwenty) --> Some below twenty: true
	```
]=]
local function Some(tbl: Table, callback: FindCallback): boolean
	for k,v in pairs(tbl) do
		if callback(v, k, tbl) then
			return true
		end
	end
	return false
end


--[=[
	@within TableUtil
	@function Truncate
	@param tbl table
	@param length number
	@return table

	Returns a new table truncated to the length of `length`.

	```lua
	local t = {10, 20, 30, 40, 50, 60, 70, 80}
	local tTruncated = TableUtil.Truncate(t, 3)
	print(tTruncated) --> {10, 20, 30}
	```
]=]
local function Truncate(tbl: Table, len: number): Table
	return table.move(tbl, 1, len, 1, table.create(len))
end


--[=[
	@within TableUtil
	@function Zip
	@param ... table
	@return (iter: (t: table, k: any) -> (key: any?, values: table?), tbl: table, startIndex: any?)

	Returns an iterator that can scan through multiple tables at the same time side-by-side, matching
	against shared keys/indices.

	```lua
	local t1 = {10, 20, 30, 40, 50}
	local t2 = {60, 70, 80, 90, 100}

	for key,values in TableUtil.Zip(t1, t2) do
		print(key, values)
	end

	--[[
		Outputs:
		1 {10, 60}
		2 {20, 70}
		3 {30, 80}
		4 {40, 90}
		5 {50, 100}
	--]]
	```
]=]
local function Zip(...): (IteratorFunc, Table, any)
	assert(select("#", ...) > 0, "Must supply at least 1 table")
	local function ZipIteratorArray(all: Table, k: number)
		k += 1
		local values = {}
		for i,t in ipairs(all) do
			local v = t[k]
			if v ~= nil then
				values[i] = v
			else
				return nil, nil
			end
		end
		return k, values
	end
	local function ZipIteratorMap(all: Table, k: any)
		local values = {}
		for i,t in ipairs(all) do
			local v = next(t, k)
			if v ~= nil then
				values[i] = v
			else
				return nil, nil
			end
		end
		return k, values
	end
	local all = {...}
	if #all[1] > 0 then
		return ZipIteratorArray, all, 0
	else
		return ZipIteratorMap, all, nil
	end
end


--[=[
	@within TableUtil
	@function Lock
	@param tbl table
	@return table

	Locks the table using `table.freeze`, as well as any
	nested tables within the given table. This will lock
	the whole deep structure of the table, disallowing any
	further modifications.

	```lua
	local tbl = {xyz = {abc = 32}}
	tbl.xyz.abc = 28 -- Works fine
	TableUtil.Lock(tbl)
	tbl.xyz.abc = 64 -- Will throw an error (cannot modify readonly table)
	```
]=]
local function Lock(tbl: Table): Table
	local function Freeze(t: Table)
		for k,v in pairs(t) do
			if type(v) == "table" then
				t[k] = Freeze(v)
			end
		end
		return table.freeze(t)
	end
	return Freeze(tbl)
end


--[=[
	@within TableUtil
	@function IsEmpty
	@param tbl table
	@return boolean

	Returns `true` if the given table is empty. This is
	simply performed by checking if `next(tbl)` is `nil`
	and works for both arrays and dictionaries. This is
	useful when needing to check if a table is empty but
	not knowing if it is an array or dictionary.

	```lua
	TableUtil.IsEmpty({}) -- true
	TableUtil.IsEmpty({"abc"}) -- false
	TableUtil.IsEmpty({abc = 32}) -- false
	```
]=]
local function IsEmpty(tbl)
	return next(tbl) == nil
end


--[=[
	@within TableUtil
	@function EncodeJSON
	@param value any
	@return string

	Proxy for [`HttpService:JSONEncode`](https://developer.roblox.com/en-us/api-reference/function/HttpService/JSONEncode).
]=]
local function EncodeJSON(value: any): string
	return HttpService:JSONEncode(value)
end


--[=[
	@within TableUtil
	@function DecodeJSON
	@param value any
	@return string

	Proxy for [`HttpService:JSONDecode`](https://developer.roblox.com/en-us/api-reference/function/HttpService/JSONDecode).
]=]
local function DecodeJSON(str: string): any
	return HttpService:JSONDecode(str)
end


TableUtil.Copy = Copy
TableUtil.Sync = Sync
TableUtil.Reconcile = Reconcile
TableUtil.SwapRemove = SwapRemove
TableUtil.SwapRemoveFirstValue = SwapRemoveFirstValue
TableUtil.Map = Map
TableUtil.Filter = Filter
TableUtil.Reduce = Reduce
TableUtil.Assign = Assign
TableUtil.Extend = Extend
TableUtil.Reverse = Reverse
TableUtil.Shuffle = Shuffle
TableUtil.Sample = Sample
TableUtil.Flat = Flat
TableUtil.FlatMap = FlatMap
TableUtil.Keys = Keys
TableUtil.Find = Find
TableUtil.Every = Every
TableUtil.Some = Some
TableUtil.Truncate = Truncate
TableUtil.Zip = Zip
TableUtil.Lock = Lock
TableUtil.IsEmpty = IsEmpty
TableUtil.EncodeJSON = EncodeJSON
TableUtil.DecodeJSON = DecodeJSON

return TableUtil
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="373">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezUwMjVFNzdFLTA2MkItNEI4OS1BOUJDLTlEM0IzRjE0Njg4Rn0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local TableUtil = require(script.Parent)

	describe("Copy (Deep)", function()

		it("should create a deep table copy", function()
			local tbl = {a = {b = {c = {d = 32}}}}
			local tblCopy = TableUtil.Copy(tbl, true)
			expect(tbl).never.to.equal(tblCopy)
			expect(tbl.a).never.to.equal(tblCopy.a)
			expect(tblCopy.a.b.c.d).to.equal(tbl.a.b.c.d)
		end)

	end)

	describe("Copy (Shallow)", function()

		it("should create a shallow dictionary copy", function()
			local tbl = {a = {b = {c = {d = 32}}}}
			local tblCopy = TableUtil.Copy(tbl)
			expect(tblCopy).never.to.equal(tbl)
			expect(tblCopy.a).to.equal(tbl.a)
			expect(tblCopy.a.b.c.d).to.equal(tbl.a.b.c.d)
		end)

		it("should create a shallow array copy", function()
			local tbl = {10, 20, 30, 40}
			local tblCopy = TableUtil.Copy(tbl)
			expect(tblCopy).never.to.equal(tbl)
			for i,v in ipairs(tbl) do
				expect(tblCopy[i]).to.equal(v)
			end
		end)

	end)

	describe("Sync", function()

		it("should sync tables", function()
			local template = {a = 32; b = 64; c = 128; e = {h = 1}}
			local tblSrc = {a = 32; b = 10; d = 1; e = {h = 2; n = 2}; f = {x = 10}}
			local tbl = TableUtil.Sync(tblSrc, template)
			expect(tbl.a).to.equal(template.a)
			expect(tbl.b).to.equal(10)
			expect(tbl.c).to.equal(template.c)
			expect(tbl.d).never.to.be.ok()
			expect(tbl.e.h).to.equal(2)
			expect(tbl.e.n).never.to.be.ok()
			expect(tbl.f).never.to.be.ok()
		end)

	end)

	describe("Reconcile", function()
		
		it("should reconcile table", function()
			local template = {kills = 0, deaths = 0, xp = 10, stuff = {}, stuff2 = "abc", stuff3 = {"data"}}
			local data = {kills = 10, deaths = 4, stuff = {"abc", "xyz"}, extra = 5, stuff2 = {abc = 10}, stuff3 = true}
			local reconciled = TableUtil.Reconcile(data, template)
			expect(reconciled).never.to.equal(data)
			expect(reconciled).never.to.equal(template)
			expect(reconciled.kills).to.equal(10)
			expect(reconciled.deaths).to.equal(4)
			expect(reconciled.xp).to.equal(10)
			expect(reconciled.stuff[1]).to.equal("abc")
			expect(reconciled.stuff[2]).to.equal("xyz")
			expect(reconciled.extra).to.equal(5)
			expect(type(reconciled.stuff2)).to.equal("table")
			expect(reconciled.stuff2).never.to.equal(data.stuff2)
			expect(reconciled.stuff2.abc).to.equal(10)
			expect(type(reconciled.stuff3)).to.equal("boolean")
			expect(reconciled.stuff3).to.equal(true)
		end)

	end)

	describe("SwapRemove", function()

		it("should swap remove index", function()
			local tbl = {1, 2, 3, 4, 5}
			TableUtil.SwapRemove(tbl, 3)
			expect(#tbl).to.equal(4)
			expect(tbl[3]).to.equal(5)
		end)

	end)

	describe("SwapRemoveFirstValue", function()

		it("should swap remove first value given", function()
			local tbl = {"hello", "world", "goodbye", "planet"}
			TableUtil.SwapRemoveFirstValue(tbl, "world")
			expect(#tbl).to.equal(3)
			expect(tbl[2]).to.equal("planet")
		end)

	end)

	describe("Map", function()

		it("should map table", function()
			local tbl = {
				{FirstName = "John", LastName = "Doe"};
				{FirstName = "Jane", LastName = "Smith"};
			}
			local tblMapped = TableUtil.Map(tbl, function(person)
				return person.FirstName .. " " .. person.LastName
			end)
			expect(tblMapped[1]).to.equal("John Doe")
			expect(tblMapped[2]).to.equal("Jane Smith")
		end)

	end)

	describe("Filter", function()

		it("should filter table", function()
			local tbl = {10, 20, 30, 40, 50, 60, 70, 80, 90}
			local tblFiltered = TableUtil.Filter(tbl, function(n)
				return (n >= 30 and n <= 60)
			end)
			expect(#tblFiltered).to.equal(4)
			expect(tblFiltered[1]).to.equal(30)
			expect(tblFiltered[#tblFiltered]).to.equal(60)
		end)

	end)

	describe("Reduce", function()

		it("should reduce table with numbers", function()
			local tbl = {1, 2, 3, 4, 5}
			local reduced = TableUtil.Reduce(tbl, function(accum, value)
				return accum + value
			end)
			expect(reduced).to.equal(15)
		end)

		it("should reduce table", function()
			local tbl = {{Score = 10}, {Score = 20}, {Score = 30}}
			local reduced = TableUtil.Reduce(tbl, function(accum, value)
				return accum + value.Score
			end, 0)
			expect(reduced).to.equal(60)
		end)

		it("should reduce table with initial value", function()
			local tbl = {{Score = 10}, {Score = 20}, {Score = 30}}
			local reduced = TableUtil.Reduce(tbl, function(accum, value)
				return accum + (value.Score)
			end, 40)
			expect(reduced).to.equal(100)
		end)

		it("should reduce functions", function()
			local function Square(x) return x * x end
			local function Double(x) return x * 2 end
			local Func = TableUtil.Reduce({Square, Double}, function(a, b)
				return function(x)
					return a(b(x))
				end
			end)
			local result = Func(10)
			expect(result).to.equal(400)
		end)

	end)

	describe("Assign", function()

		it("should assign tables", function()
			local target = {a = 32; x = 100}
			local t1 = {b = 64; c = 128}
			local t2 = {a = 10; c = 100; d = 200}
			local tbl = TableUtil.Assign(target, t1, t2)
			expect(tbl.a).to.equal(10)
			expect(tbl.b).to.equal(64)
			expect(tbl.c).to.equal(100)
			expect(tbl.d).to.equal(200)
			expect(tbl.x).to.equal(100)
		end)

	end)

	describe("Extend", function()

		it("should extend tables", function()
			local tbl = {"a", "b", "c"}
			local extension = {"d", "e", "f"}
			local extended = TableUtil.Extend(tbl, extension)
			expect(table.concat(extended)).to.equal("abcdef")
		end)

	end)

	describe("Reverse", function()

		it("should create a table in reverse", function()
			local tbl = {1, 2, 3}
			local tblRev = TableUtil.Reverse(tbl)
			expect(table.concat(tblRev)).to.equal("321")
		end)

	end)

	describe("Shuffle", function()

		it("should shuffle a table", function()
			local tbl = {1, 2, 3, 4, 5}
			expect(function() TableUtil.Shuffle(tbl) end).never.to.throw()
		end)

	end)

	describe("Sample", function()

		it("should sample a table", function()
			local tbl = {1, 2, 3, 4, 5}
			local sample = TableUtil.Sample(tbl, 3)
			expect(#sample).to.equal(3)
		end)

	end)

	describe("Flat", function()

		it("should flatten table", function()
			local tbl = {1, 2, 3, {4, 5, {6, 7}}}
			local tblFlat = TableUtil.Flat(tbl, 3)
			expect(table.concat(tblFlat)).to.equal("1234567")
		end)

	end)

	describe("FlatMap", function()

		it("should map and flatten table", function()
			local tbl = {1, 2, 3, 4, 5, 6, 7}
			local tblFlat = TableUtil.FlatMap(tbl, function(n) return {n, n * 2} end)
			expect(table.concat(tblFlat)).to.equal("12243648510612714")
		end)

	end)

	describe("Keys", function()

		it("should give all keys of table", function()
			local tbl = {a = 1, b = 2, c = 3}
			local keys = TableUtil.Keys(tbl)
			expect(#keys).to.equal(3)
			expect(table.find(keys, "a")).to.be.ok()
			expect(table.find(keys, "b")).to.be.ok()
			expect(table.find(keys, "c")).to.be.ok()
		end)

	end)

	describe("Find", function()

		it("should find item in array", function()
			local tbl = {10, 20, 30}
			local item, index = TableUtil.Find(tbl, function(value)
				return (value == 20)
			end)
			expect(item).to.be.ok()
			expect(index).to.equal(2)
			expect(item).to.equal(20)
		end)

		it("should find item in dictionary", function()
			local tbl = {{Score = 10}, {Score = 20}, {Score = 30}}
			local item, index = TableUtil.Find(tbl, function(value)
				return (value.Score == 20)
			end)
			expect(item).to.be.ok()
			expect(index).to.equal(2)
			expect(item.Score).to.equal(20)
		end)

	end)

	describe("Every", function()

		it("should see every value is above 20", function()
			local tbl = {21, 40, 200}
			local every = TableUtil.Every(tbl, function(n)
				return (n > 20)
			end)
			expect(every).to.equal(true)
		end)

		it("should see every value is not above 20", function()
			local tbl = {20, 40, 200}
			local every = TableUtil.Every(tbl, function(n)
				return (n > 20)
			end)
			expect(every).never.to.equal(true)
		end)

	end)

	describe("Some", function()

		it("should see some value is above 20", function()
			local tbl = {5, 40, 1}
			local every = TableUtil.Some(tbl, function(n)
				return (n > 20)
			end)
			expect(every).to.equal(true)
		end)

		it("should see some value is not above 20", function()
			local tbl = {5, 15, 1}
			local every = TableUtil.Some(tbl, function(n)
				return (n > 20)
			end)
			expect(every).never.to.equal(true)
		end)

	end)

	describe("Truncate", function()

		it("should truncate an array", function()
			local t1 = {1, 2, 3, 4, 5}
			local t2 = TableUtil.Truncate(t1, 3)
			expect(#t2).to.equal(3)
			expect(t2[1]).to.equal(t1[1])
			expect(t2[2]).to.equal(t1[2])
			expect(t2[3]).to.equal(t1[3])
		end)
		
	end)

	describe("Lock", function()
		
		it("should lock a table", function()
			local t = {abc = {xyz = {num = 32}}}
			expect(function()
				t.abc.xyz.num = 64
			end).never.to.throw()
			local t2 = TableUtil.Lock(t)
			expect(t.abc.xyz.num).to.equal(64)
			expect(t).to.equal(t2)
			expect(function()
				t.abc.xyz.num = 10
			end).to.throw()
		end)

	end)

	describe("Zip", function()

		it("should zip arrays together", function()
			local t1 = {1, 2, 3, 4, 5}
			local t2 = {9, 8, 7, 6, 5}
			local t3 = {1, 1, 1, 1, 1}
			local lastIndex = 0
			for i,v in TableUtil.Zip(t1, t2, t3) do
				lastIndex = i
				expect(v[1]).to.equal(t1[i])
				expect(v[2]).to.equal(t2[i])
				expect(v[3]).to.equal(t3[i])
			end
			expect(lastIndex).to.equal(math.min(#t1, #t2, #t3))
		end)

		it("should zip arrays of different lengths together", function()
			local t1 = {1, 2, 3, 4, 5}
			local t2 = {9, 8, 7, 6}
			local t3 = {1, 1, 1}
			local lastIndex = 0
			for i,v in TableUtil.Zip(t1, t2, t3) do
				lastIndex = i
				expect(v[1]).to.equal(t1[i])
				expect(v[2]).to.equal(t2[i])
				expect(v[3]).to.equal(t3[i])
			end
			expect(lastIndex).to.equal(math.min(#t1, #t2, #t3))
		end)

		it("should zip maps together", function()
			local t1 = {a = 10, b = 20, c = 30}
			local t2 = {a = 100, b = 200, c = 300}
			local t3 = {a = 3000, b = 2000, c = 3000}
			for k,v in TableUtil.Zip(t1, t2, t3) do
				expect(v[1]).to.equal(t1[k])
				expect(v[2]).to.equal(t2[k])
				expect(v[3]).to.equal(t3[k])
			end
		end)

		it("should zip maps of different keys together", function()
			local t1 = {a = 10, b = 20, c = 30, d = 40}
			local t2 = {a = 100, b = 200, c = 300, z = 10}
			local t3 = {a = 3000, b = 2000, c = 3000, x = 0}
			for k,v in TableUtil.Zip(t1, t2, t3) do
				expect(v[1]).to.equal(t1[k])
				expect(v[2]).to.equal(t2[k])
				expect(v[3]).to.equal(t3[k])
			end
		end)

	end)

	describe("IsEmpty", function()

		it("should detect that table is empty", function()
			local tbl = {}
			local isEmpty = TableUtil.IsEmpty(tbl)
			expect(isEmpty).to.equal(true)
		end)

		it("should detect that array is not empty", function()
			local tbl = {10, 20, 30}
			local isEmpty = TableUtil.IsEmpty(tbl)
			expect(isEmpty).to.equal(false)
		end)

		it("should detect that dictionary is not empty", function()
			local tbl = {a = 10, b = 20, c = 30}
			local isEmpty = TableUtil.IsEmpty(tbl)
			expect(isEmpty).to.equal(false)
		end)

	end)

	describe("JSON", function()

		it("should encode json", function()
			local tbl = {hello = "world"}
			local json = TableUtil.EncodeJSON(tbl)
			expect(json).to.equal("{\"hello\":\"world\"}")
		end)

		it("should decode json", function()
			local json = "{\"hello\":\"world\"}"
			local tbl = TableUtil.DecodeJSON(json)
			expect(tbl).to.be.a("table")
			expect(tbl.hello).to.equal("world")
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="374">
          <Properties>
            <string name="Name">sleitnick_timer@1.1.1</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="375">
            <Properties>
              <string name="Name">Signal</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezE2QkI4NzBCLUVCQzEtNDZBQi1CNUU0LTUyMDI5NDYwMEFFNn0=]]></BinaryString>
              <string name="Source"><![CDATA[return require(script.Parent.Parent["sleitnick_signal@1.1.0"]["signal"])
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="376">
            <Properties>
              <string name="Name">timer</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezIzQjFFQTc0LTBGOTItNDEwQy05NEU4LUUwMUExRUMyRENCNX0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Timer
-- Stephen Leitnick
-- July 28, 2021


--[=[
	@within Timer
	@type CallbackFn () -> ()
	Callback function.
]=]
type CallbackFn = () -> nil

--[=[
	@within Timer
	@type TimeFn () -> number
	Time function.
]=]
type TimeFn = () -> number

local Signal = require(script.Parent.Signal)

local RunService = game:GetService("RunService")


--[=[
	@class Timer

	The Timer class allows for code to run periodically at specified intervals.

	```lua
	local timer = Timer.new(2)
	timer.Tick:Connect(function()
		print("Tock")
	end)
	timer:Start()
	```
]=]
local Timer = {}
Timer.__index = Timer


--[=[
	@within Timer
	@prop Interval number
	Interval at which the `Tick` event fires.
]=]
--[=[
	@within Timer
	@prop UpdateSignal RBXScriptSignal | Signal
	The signal which updates the timer internally.
]=]
--[=[
	@within Timer
	@prop TimeFunction TimeFn
	The function which gets the current time.
]=]
--[=[
	@within Timer
	@prop AllowDrift boolean
	Flag which indicates if the timer is allowed to drift. This
	is set to `true` by default. This flag must be set before
	calling `Start` or `StartNow`. This flag should only be set
	to `false` if it is necessary for drift to be eliminated.
]=]
--[=[
	@within Timer
	@prop Tick RBXScriptSignal | Signal
	The event which is fired every time the timer hits its interval.
]=]


--[=[
	@return Timer
	
	Creates a new timer.
]=]
function Timer.new(interval: number)
	assert(type(interval) == "number", "Argument #1 to Timer.new must be a number; got " .. type(interval))
	assert(interval >= 0, "Argument #1 to Timer.new must be greater or equal to 0; got " .. tostring(interval))
	local self = setmetatable({}, Timer)
	self._runHandle = nil
	self.Interval = interval
	self.UpdateSignal = RunService.Heartbeat
	self.TimeFunction = time
	self.AllowDrift = true
	self.Tick = Signal.new()
	return self
end


--[=[
	@return RBXScriptConnection

	Creates a simplified timer which just fires off a callback function at the given interval.

	```lua
	-- Basic:
	Timer.Simple(1, function()
		print("Tick")
	end)

	-- Using other arguments:
	Timer.Simple(1, function()
		print("Tick")
	end, true, RunService.Heartbeat, os.clock)
	```
]=]
function Timer.Simple(interval: number, callback: CallbackFn, startNow: boolean?, updateSignal: RBXScriptSignal?, timeFn: TimeFn?)
	local update = updateSignal or RunService.Heartbeat
	local t = timeFn or time
	local nextTick = t() + interval
	if startNow then
		task.defer(callback)
	end
	return update:Connect(function()
		local now = t()
		if now >= nextTick then
			nextTick = now + interval
			task.defer(callback)
		end
	end)
end


--[=[
	Returns `true` if the given object is a Timer.
]=]
function Timer.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Timer
end


function Timer:_startTimer()
	local t = self.TimeFunction
	local nextTick = t() + self.Interval
	self._runHandle = self.UpdateSignal:Connect(function()
		local now = t()
		if now >= nextTick then
			nextTick = now + self.Interval
			self.Tick:Fire()
		end
	end)
end


function Timer:_startTimerNoDrift()
	assert(self.Interval > 0, "Interval must be greater than 0 when AllowDrift is set to false")
	local t = self.TimeFunction
	local n = 1
	local start = t()
	local nextTick = start + self.Interval
	self._runHandle = self.UpdateSignal:Connect(function()
		local now = t()
		while now >= nextTick do
			n += 1
			nextTick = start + (self.Interval * n)
			self.Tick:Fire()
		end
	end)
end


--[=[
	Starts the timer. Will do nothing if the timer is already running.

	```lua
	timer:Start()
	```
]=]
function Timer:Start()
	if self._runHandle then return end
	if self.AllowDrift then
		self:_startTimer()
	else
		self:_startTimerNoDrift()
	end
end


--[=[
	Starts the timer and fires off the Tick event immediately. Will do
	nothing if the timer is already running.

	```lua
	timer:StartNow()
	```
]=]
function Timer:StartNow()
	if self._runHandle then return end
	self.Tick:Fire()
	self:Start()
end


--[=[
	Stops the timer. Will do nothing if the timer is already stopped.

	```lua
	timer:Stop()
	```
]=]
function Timer:Stop()
	if not self._runHandle then return end
	self._runHandle:Disconnect()
	self._runHandle = nil
end


--[=[
	Returns `true` if the timer is currently running.

	```lua
	if timer:IsRunning() then
		-- Do something
	end
	```
]=]
function Timer:IsRunning(): boolean
	return self._runHandle ~= nil
end


--[=[
	Destroys the timer. This will also stop the timer.
]=]
function Timer:Destroy()
	self.Tick:Destroy()
	self:Stop()
end


return Timer
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="377">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezY1RkYzREJBLTBBQjUtNDU1Ri1BM0JGLUY5MEIxQjExQTBBOX0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local Timer = require(script.Parent)

	describe("Timer", function()

		local timer

		beforeEach(function()
			timer = Timer.new(0.1)
			timer.TimeFunction = os.clock
		end)

		afterEach(function()
			if timer then
				timer:Destroy()
				timer = nil
			end
		end)

		it("should create a new timer", function()
			expect(Timer.Is(timer)).to.equal(true)
		end)

		it("should tick appropriately", function()
			local start = os.clock()
			timer:Start()
			timer.Tick:Wait()
			local duration = (os.clock() - start)
			expect(duration).to.be.near(duration, 0.02)
		end)

		it("should start immediately", function()
			local start = os.clock()
			local stop = nil
			timer.Tick:Connect(function()
				if not stop then
					stop = os.clock()
				end
			end)
			timer:StartNow()
			timer.Tick:Wait()
			expect(stop).to.be.a("number")
			local duration = (stop - start)
			expect(duration).to.be.near(0, 0.02)
		end)

		it("should stop", function()
			local ticks = 0
			timer.Tick:Connect(function()
				ticks += 1
			end)
			timer:StartNow()
			timer:Stop()
			task.wait(1)
			expect(ticks).to.equal(1)
		end)

		it("should detect if running", function()
			expect(timer:IsRunning()).to.equal(false)
			timer:Start()
			expect(timer:IsRunning()).to.equal(true)
			timer:Stop()
			expect(timer:IsRunning()).to.equal(false)
			timer:StartNow()
			expect(timer:IsRunning()).to.equal(true)
			timer:Stop()
			expect(timer:IsRunning()).to.equal(false)
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="378">
          <Properties>
            <string name="Name">sleitnick_trove@0.4.0</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="379">
            <Properties>
              <string name="Name">trove</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezM3MUJFNEFDLTdCOEYtNDcwOS04MjcwLTM3MkZDNUFEMDZENX0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Trove
-- Stephen Leitnick
-- October 16, 2021


local FN_MARKER = newproxy()
local THREAD_MARKER = newproxy()

local RunService = game:GetService("RunService")


local function GetObjectCleanupFunction(object, cleanupMethod)
	local t = typeof(object)
	if t == "function" then
		return FN_MARKER
	elseif t == "thread" then
		return THREAD_MARKER
	end
	if cleanupMethod then
		return cleanupMethod
	end
	if t == "Instance" then
		return "Destroy"
	elseif t == "RBXScriptConnection" then
		return "Disconnect"
	elseif t == "table" then
		if typeof(object.Destroy) == "function" then
			return "Destroy"
		elseif typeof(object.Disconnect) == "function" then
			return "Disconnect"
		end
	end
	error("Failed to get cleanup function for object " .. t .. ": " .. tostring(object), 3)
end


local function AssertPromiseLike(object)
	if type(object) ~= "table" or type(object.getStatus) ~= "function" or type(object.finally) ~= "function" or type(object.cancel) ~= "function" then
		error("Did not receive a Promise as an argument", 3)
	end
end


--[=[
	@class Trove
	A Trove is helpful for tracking any sort of object during
	runtime that needs to get cleaned up at some point.
]=]
local Trove = {}
Trove.__index = Trove


--[=[
	@return Trove
	Constructs a Trove object.
]=]
function Trove.new()
	local self = setmetatable({}, Trove)
	self._objects = {}
	return self
end


--[=[
	@return Trove
	Creates and adds another trove to itself. This is just shorthand
	for `trove:Construct(Trove)`. This is useful for contexts where
	the trove object is present, but the class itself isn't.

	:::note
	This does _not_ clone the trove. In other words, the objects in the
	trove are not given to the new constructed trove. This is simply to
	construct a new Trove and add it as an object to track.
	:::

	```lua
	local trove = Trove.new()
	local subTrove = trove:Extend()

	trove:Clean() -- Cleans up the subTrove too
	```
]=]
function Trove:Extend()
	return self:Construct(Trove)
end


--[=[
	Clones the given instance and adds it to the trove. Shorthand for
	`trove:Add(instance:Clone())`.
]=]
function Trove:Clone(instance: Instance): Instance
	return self:Add(instance:Clone())
end


--[=[
	@param class table | (...any) -> any
	@param ... any
	@return any
	Constructs a new object from either the
	table or function given.

	If a table is given, the table's `new`
	function will be called with the given
	arguments.

	If a function is given, the function will
	be called with the given arguments.
	
	The result from either of the two options
	will be added to the trove.

	This is shorthand for `trove:Add(SomeClass.new(...))`
	and `trove:Add(SomeFunction(...))`.

	```lua
	local Signal = require(somewhere.Signal)

	-- All of these are identical:
	local s = trove:Construct(Signal)
	local s = trove:Construct(Signal.new)
	local s = trove:Construct(function() return Signal.new() end)
	local s = trove:Add(Signal.new())

	-- Even Roblox instances can be created:
	local part = trove:Construct(Instance, "Part")
	```
]=]
function Trove:Construct(class, ...)
	local object = nil
	local t = type(class)
	if t == "table" then
		object = class.new(...)
	elseif t == "function" then
		object = class(...)
	end
	return self:Add(object)
end


--[=[
	@param signal RBXScriptSignal
	@param fn (...: any) -> ()
	@return RBXScriptConnection
	Connects the function to the signal, adds the connection
	to the trove, and then returns the connection.

	This is shorthand for `trove:Add(signal:Connect(fn))`.

	```lua
	trove:Connect(workspace.ChildAdded, function(instance)
		print(instance.Name .. " added to workspace")
	end)
	```
]=]
function Trove:Connect(signal, fn)
	return self:Add(signal:Connect(fn))
end


--[=[
	@param name string
	@param priority number
	@param fn (dt: number) -> ()
	Calls `RunService:BindToRenderStep` and registers a function in the
	trove that will call `RunService:UnbindFromRenderStep` on cleanup.

	```lua
	trove:BindToRenderStep("Test", Enum.RenderPriority.Last.Value, function(dt)
		-- Do something
	end)
	```
]=]
function Trove:BindToRenderStep(name: string, priority: number, fn: (dt: number) -> ())
	RunService:BindToRenderStep(name, priority, fn)
	self:Add(function()
		RunService:UnbindFromRenderStep(name)
	end)
end


--[=[
	@param promise Promise
	@return Promise
	Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise
	is removed. The exact promise is returned, thus allowing chaining.

	```lua
	trove:AddPromise(doSomethingThatReturnsAPromise())
		:andThen(function()
			print("Done")
		end)
	-- Will cancel the above promise (assuming it didn't resolve immediately)
	trove:Clean()

	local p = trove:AddPromise(doSomethingThatReturnsAPromise())
	-- Will also cancel the promise
	trove:Remove(p)
	```

	:::caution Promise v4 Only
	This is only compatible with the [roblox-lua-promise](https://eryn.io/roblox-lua-promise/) library, version 4.
	:::
]=]
function Trove:AddPromise(promise)
	AssertPromiseLike(promise)
	if promise:getStatus() == "Started" then
		promise:finally(function()
			return self:_findAndRemoveFromObjects(promise, false)
		end)
		self:Add(promise, "cancel")
	end
	return promise
end


--[=[
	@param object any -- Object to track
	@param cleanupMethod string? -- Optional cleanup name override
	@return object: any
	Adds an object to the trove. Once the trove is cleaned or
	destroyed, the object will also be cleaned up.

	The following types are accepted (e.g. `typeof(object)`):

	| Type | Cleanup |
	| ---- | ------- |
	| `Instance` | `object:Destroy()` |
	| `RBXScriptConnection` | `object:Disconnect()` |
	| `function` | `object()` |
	| `thread` | `coroutine.close(object)` |
	| `table` | `object:Destroy()` _or_ `object:Disconnect()` |
	| `table` with `cleanupMethod` | `object:<cleanupMethod>()` |

	Returns the object added.

	```lua
	-- Add a part to the trove, then destroy the trove,
	-- which will also destroy the part:
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Destroy()

	-- Add a function to the trove:
	trove:Add(function()
		print("Cleanup!")
	end)
	trove:Destroy()

	-- Standard cleanup from table:
	local tbl = {}
	function tbl:Destroy()
		print("Cleanup")
	end
	trove:Add(tbl)

	-- Custom cleanup from table:
	local tbl = {}
	function tbl:DoSomething()
		print("Do something on cleanup")
	end
	trove:Add(tbl, "DoSomething")
	```
]=]
function Trove:Add(object: any, cleanupMethod: string?): any
	local cleanup = GetObjectCleanupFunction(object, cleanupMethod)
	table.insert(self._objects, {object, cleanup})
	return object
end


--[=[
	@param object any -- Object to remove
	Removes the object from the Trove and cleans it up.

	```lua
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Remove(part)
	```
]=]
function Trove:Remove(object: any): boolean
	return self:_findAndRemoveFromObjects(object, true)
end


--[=[
	Cleans up all objects in the trove. This is
	similar to calling `Remove` on each object
	within the trove.
]=]
function Trove:Clean()
	for _,obj in ipairs(self._objects) do
		self:_cleanupObject(obj[1], obj[2])
	end
	table.clear(self._objects)
end


function Trove:_findAndRemoveFromObjects(object: any, cleanup: boolean): boolean
	local objects = self._objects
	for i,obj in ipairs(objects) do
		if obj[1] == object then
			local n = #objects
			objects[i] = objects[n]
			objects[n] = nil
			if cleanup then
				self:_cleanupObject(obj[1], obj[2])
			end
			return true
		end
	end
	return true
end


function Trove:_cleanupObject(object, cleanupMethod)
	if cleanupMethod == FN_MARKER then
		object()
	elseif cleanupMethod == THREAD_MARKER then
		coroutine.close(object)
	else
		object[cleanupMethod](object)
	end
end


--[=[
	@param instance Instance
	@return RBXScriptConnection
	Attaches the trove to a Roblox instance. Once this
	instance is removed from the game (parent or ancestor's
	parent set to `nil`), the trove will automatically
	clean up.

	:::caution
	Will throw an error if `instance` is not a descendant
	of the game hierarchy.
	:::
]=]
function Trove:AttachToInstance(instance: Instance)
	assert(instance:IsDescendantOf(game), "Instance is not a descendant of the game hierarchy")
	return self:Connect(instance.Destroying, function()
		self:Destroy()
	end)
end


--[=[
	Destroys the Trove object. Forces `Clean` to run.
]=]
function Trove:Destroy()
	self:Clean()
end


return Trove
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="380">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezhFRTQ1OTIyLUUxNDUtNDAyOC1CQUQ0LTBBRTBFMzkwNDY4MX0=]]></BinaryString>
                <string name="Source"><![CDATA[return function()

	local Trove = require(script.Parent)

	describe("Trove", function()

		local trove

		beforeEach(function()
			trove = Trove.new()
		end)

		afterEach(function()
			if trove then
				trove:Destroy()
				trove = nil
			end
		end)

		it("should add and clean up roblox instance", function()
			local part = Instance.new("Part")
			part.Parent = workspace
			trove:Add(part)
			trove:Destroy()
			expect(part.Parent).to.equal(nil)
		end)

		it("should add and clean up roblox connection", function()
			local connection = workspace.Changed:Connect(function() end)
			trove:Add(connection)
			trove:Destroy()
			expect(connection.Connected).to.equal(false)
		end)

		it("should add and clean up a table with a destroy method", function()
			local tbl = {Destroyed = false}
			function tbl:Destroy()
				self.Destroyed = true
			end
			trove:Add(tbl)
			trove:Destroy()
			expect(tbl.Destroyed).to.equal(true)
		end)

		it("should add and clean up a table with a disconnect method", function()
			local tbl = {Connected = true}
			function tbl:Disconnect()
				self.Connected = false
			end
			trove:Add(tbl)
			trove:Destroy()
			expect(tbl.Connected).to.equal(false)
		end)

		it("should add and clean up a function", function()
			local fired = false
			trove:Add(function()
				fired = true
			end)
			trove:Destroy()
			expect(fired).to.equal(true)
		end)

		it("should allow a custom cleanup method", function()
			local tbl = {Cleaned = false}
			function tbl:Cleanup()
				self.Cleaned = true
			end
			trove:Add(tbl, "Cleanup")
			trove:Destroy()
			expect(tbl.Cleaned).to.equal(true)
		end)

		it("should return the object passed to add", function()
			local part = Instance.new("Part")
			local part2 = trove:Add(part)
			expect(part).to.equal(part2)
			trove:Destroy()
		end)

		it("should fail to add object without proper cleanup method", function()
			local tbl = {}
			expect(function() trove:Add(tbl) end).to.throw()
		end)

		it("should construct an object and add it", function()
			local class = {}
			class.__index = class
			function class.new(msg)
				local self = setmetatable({}, class)
				self._msg = msg
				self._destroyed = false
				return self
			end
			function class:Destroy()
				self._destroyed = true
			end
			local msg = "abc"
			local obj = trove:Construct(class, msg)
			expect(typeof(obj)).to.equal("table")
			expect(getmetatable(obj)).to.equal(class)
			expect(obj._msg).to.equal(msg)
			expect(obj._destroyed).to.equal(false)
			trove:Destroy()
			expect(obj._destroyed).to.equal(true)
		end)

		it("should connect to a signal", function()
			local connection = trove:Connect(workspace.Changed, function() end)
			expect(typeof(connection)).to.equal("RBXScriptConnection")
			expect(connection.Connected).to.equal(true)
			trove:Destroy()
			expect(connection.Connected).to.equal(false)
		end)

		it("should remove an object", function()
			local connection = trove:Connect(workspace.Changed, function() end)
			expect(trove:Remove(connection)).to.equal(true)
			expect(connection.Connected).to.equal(false)
		end)

		it("should attach to instance", function()
			local part = Instance.new("Part")
			part.Parent = workspace
			local connection = trove:AttachToInstance(part)
			expect(connection.Connected).to.equal(true)
			part:Destroy()
			expect(connection.Connected).to.equal(false)
		end)

		it("should fail to attach to instance not in hierarchy", function()
			local part = Instance.new("Part")
			expect(function() trove:AttachToInstance(part) end).to.throw()
		end)

		it("should extend itself", function()
			local subTrove = trove:Extend()
			local called = false
			subTrove:Add(function()
				called = true
			end)
			expect(subTrove).to.be.a("table")
			expect(getmetatable(subTrove)).to.equal(Trove)
			trove:Clean()
			expect(called).to.equal(true)
		end)

		it("should clone an instance", function()
			local name = "TroveCloneTest"
			local p1 = trove:Construct(Instance.new, "Part")
			p1.Name = name
			local p2 = trove:Clone(p1)
			expect(typeof(p2)).to.equal("Instance")
			expect(p2).to.never.equal(p1)
			expect(p2.Name).to.equal(name)
			expect(p1.Name).to.equal(p2.Name)
		end)

		it("should clean up a thread", function()
			local co = coroutine.create(function() end)
			trove:Add(co)
			expect(coroutine.status(co)).to.equal("suspended")
			trove:Clean()
			expect(coroutine.status(co)).to.equal("dead")
		end)

	end)

end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="381">
          <Properties>
            <string name="Name">elttob_fusion@0.1.1-beta</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="382">
            <Properties>
              <string name="Name">fusion</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0VEQTdFRDcwLTIwRDgtNERGMS1CRUQ1LTcwODUxQ0U5QzRGN30=]]></BinaryString>
              <string name="Source">--[[
	The entry point for the Fusion library.
]]

local Types = require(script.Types)
local restrictRead = require(script.Utility.restrictRead)

export type State = Types.State
export type StateOrValue = Types.StateOrValue
export type Symbol = Types.Symbol

return restrictRead("Fusion", {
	New = require(script.Instances.New),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	State = require(script.State.State),
	Computed = require(script.State.Computed),
	ComputedPairs = require(script.State.ComputedPairs),
	Compat = require(script.State.Compat),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring)
})</string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="Folder" referent="383">
              <Properties>
                <string name="Name">Animation</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="384">
                <Properties>
                  <string name="Name">Spring</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0ZDNTVFRjM1LUM3QzYtNEQyNi1BNDZCLUZGMkNFM0ZDQTE3Rn0=]]></BinaryString>
                  <string name="Source">--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_PARAM_SETTERS = false

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value.

	If the new goal can be animated to, the equilibrium point of the internal
	springs will be moved, but the springs themselves stay in place.
	Returns false, as this has no immediate impact on the current value of the
	Spring object.

	If the new goal can't be animated to (different types/non-animatable type),
	then the springs will be instantly moved to the goal value. Returns true, as
	the current value of the Spring object will jump directly to the goal.
]]
function class:update()
	local goalValue = self._goalState:get(false)

	local oldType = self._currentType
	local newType = typeof(goalValue)

	self._goalValue = goalValue
	self._currentType = newType

	local springGoals = unpackType(goalValue, newType)
	local numSprings = #springGoals

	self._springGoals = springGoals

	if newType ~= oldType then
		-- if the type changed, we need to set the position and velocity
		local springPositions = table.create(numSprings, 0)
		local springVelocities = table.create(numSprings, 0)

		for index, springGoal in ipairs(springGoals) do
			springPositions[index] = springGoal
		end

		self._springPositions = springPositions
		self._springVelocities = springVelocities
		self._currentValue = self._goalValue

		SpringScheduler.remove(self)
		return true

	elseif numSprings == 0 then
		-- if the type hasn't changed, but isn't animatable, just change the
		-- current value
		self._currentValue = self._goalValue

		SpringScheduler.remove(self)
		return true
	end

	SpringScheduler.add(self)
	return false
end

if ENABLE_PARAM_SETTERS then

	--[[
		Changes the damping ratio of this Spring.
	]]
	function class:setDamping(damping: number)
		if damping &lt; 0 then
			logError("invalidSpringDamping", nil, damping)
		end

		SpringScheduler.remove(self)
		self._damping = damping
		SpringScheduler.add(self)
	end

	--[[
		Changes the angular frequency of this Spring.
	]]
	function class:setSpeed(speed: number)
		if speed &lt; 0 then
			logError("invalidSpringSpeed", nil, speed)
		end

		SpringScheduler.remove(self)
		self._speed = speed
		SpringScheduler.add(self)
	end

	--[[
		Sets the position of the internal springs, meaning the value of this
		Spring will jump to the given value. This doesn't affect velocity.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:setPosition(newValue: Types.Animatable)
		local newType = typeof(newValue)
		if newType ~= self._currentType then
			logError("springTypeMismatch", nil, newType, self._currentType)
		end

		self._springPositions = unpackType(newValue, newType)
		self._currentValue = newValue

		updateAll(self)

		SpringScheduler.add(self)
	end

	--[[
		Sets the velocity of the internal springs, overwriting the existing velocity
		of this Spring. This doesn't affect position.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:setVelocity(newValue: Types.Animatable)
		local newType = typeof(newValue)
		if newType ~= self._currentType then
			logError("springTypeMismatch", nil, newType, self._currentType)
		end

		self._springVelocities = unpackType(newValue, newType)
		SpringScheduler.add(self)
	end

	--[[
		Adds to the velocity of the internal springs, on top of the existing
		velocity of this Spring. This doesn't affect position.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:addVelocity(deltaValue: Types.Animatable)
		local deltaType = typeof(deltaValue)
		if deltaType ~= self._currentType then
			logError("springTypeMismatch", nil, deltaType, self._currentType)
		end

		local springDeltas = unpackType(deltaValue, deltaType)
		for index, delta in ipairs(springDeltas) do
			self._springVelocities[index] += delta
		end

		SpringScheduler.add(self)
	end

end

local function Spring(goalState: Types.State&lt;Types.Animatable>, speed: number?, damping: number?)
	-- check and apply defaults for speed and damping
	if speed == nil then
		speed = 10
	elseif speed &lt; 0 then
		logError("invalidSpringSpeed", nil, speed)
	end

	if damping == nil then
		damping = 1
	elseif damping &lt; 0 then
		logError("invalidSpringDamping", nil, damping)
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = {[goalState] = true},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="385">
                <Properties>
                  <string name="Name">SpringScheduler</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezZENkVDQjBGLTQyNkMtNEI4My1CNDNFLTA4RURFRkQ4RTBDQX0=]]></BinaryString>
                  <string name="Source">--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

local SpringScheduler = {}

type Spring = {
	_speed: number,
	_damping: number,

	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- when a spring has displacement and velocity below +/- epsilon, the spring
-- won't send updates
local MOVEMENT_EPSILON = 0.0001

-- organises springs by speed and damping, for batch processing
local springBuckets: {[number]: {[number]: Types.Set&lt;Spring>}} = {}

--[[
	Adds a Spring to be updated every render step.
]]
function SpringScheduler.add(spring: Spring)
	local damping = spring._damping
	local speed = spring._speed

	local dampingBucket = springBuckets[damping]

	if dampingBucket == nil then
		springBuckets[damping] = {
			[speed] = setmetatable({[spring] = true}, WEAK_KEYS_METATABLE)
		}
		return
	end

	local speedBucket = dampingBucket[speed]

	if speedBucket == nil then
		dampingBucket[speed] = setmetatable({[spring] = true}, WEAK_KEYS_METATABLE)
		return
	end

	speedBucket[spring] = true
end

--[[
	Removes a Spring from the scheduler.
]]
function SpringScheduler.remove(spring: Spring)
	local damping = spring._damping
	local speed = spring._speed

	local dampingBucket = springBuckets[damping]

	if dampingBucket == nil then
		return
	end

	local speedBucket = dampingBucket[speed]

	if speedBucket == nil then
		return
	end

	speedBucket[spring] = nil
end

--[[
	Updates all Spring objects.
]]
local function updateAllSprings(timeStep: number)
	for damping, dampingBucket in pairs(springBuckets) do
		for speed, speedBucket in pairs(dampingBucket) do
			local posPosCoef, posVelCoef, velPosCoef, velVelCoef = springCoefficients(timeStep, damping, speed)

			for spring in pairs(speedBucket) do
				local goals = spring._springGoals
				local positions = spring._springPositions
				local velocities = spring._springVelocities

				local isMoving = false

				for index, goal in ipairs(goals) do
					local oldPosition = positions[index]
					local oldVelocity = velocities[index]

					local oldDisplacement = oldPosition - goal

					local newDisplacement = oldDisplacement * posPosCoef + oldVelocity * posVelCoef
					local newVelocity = oldDisplacement * velPosCoef + oldVelocity * velVelCoef

					if
						math.abs(newDisplacement) > MOVEMENT_EPSILON or
						math.abs(newVelocity) > MOVEMENT_EPSILON
					then
						isMoving = true
					end

					positions[index] = newDisplacement + goal
					velocities[index] = newVelocity
				end

				-- if the spring moved a significant distance, update its
				-- current value, otherwise stop animating
				if isMoving then
					spring._currentValue = packType(positions, spring._currentType)
					updateAll(spring)
				else
					SpringScheduler.remove(spring)
				end
			end
		end
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="386">
                <Properties>
                  <string name="Name">Tween</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezI2Q0FDNjA5LUNENTQtNDBCQi1BODE3LTQwRjU3NDIwNEI4NX0=]]></BinaryString>
                  <string name="Source">--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_PARAM_SETTERS = false

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update()
	self._prevValue = self._currentValue
	self._nextValue = self._goalState:get(false)

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = self._tweenInfo

	local tweenDuration = self._tweenInfo.DelayTime + self._tweenInfo.Time
	if self._tweenInfo.Reverses then
		tweenDuration += self._tweenInfo.Time
	end
	tweenDuration *= self._tweenInfo.RepeatCount
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)
	return false
end

if ENABLE_PARAM_SETTERS then

	--[[
		Specifies a new TweenInfo to use when the goal state changes in the future.
	]]
	function class:setTweenInfo(newTweenInfo: TweenInfo)
		self._tweenInfo = newTweenInfo
	end

end

local function Tween(goalState: Types.State&lt;Types.Animatable>, tweenInfo: TweenInfo?)
	local currentValue = goalState:get(false)

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = {[goalState] = true},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo or TweenInfo.new(),

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="387">
                <Properties>
                  <string name="Name">TweenScheduler</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezNEMzNENjgzLURGNkUtNDdGNC1CRkIwLTFDQUJCRUVFMkYyRX0=]]></BinaryString>
                  <string name="Source">--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Tween = {
	_prevValue: Types.Animatable,
	_nextValue: Types.Animatable,
	_currentValue: Types.Animatable,

	_tweenStartTime: number,
	_tweenDuration: number,
	_tweenInfo: TweenInfo
}

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Types.Set&lt;Tween> = setmetatable({}, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	for tween in pairs(allTweens) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="388">
                <Properties>
                  <string name="Name">getTweenRatio</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezFCOURFMUFGLTYxOUEtNDA4NC1BMjRGLTREMTI5RkMxRkI5OH0=]]></BinaryString>
                  <string name="Source">--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numRepeats = tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numRepeats then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime &lt;= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="389">
                <Properties>
                  <string name="Name">lerpType</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezEyOTg0NDZFLUM3NTMtNDQ2Qi05NzU2LTk3QzFCMEE0QzM3Qn0=]]></BinaryString>
                  <string name="Source">--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: Types.Animatable | any, to: Types.Animatable | any, ratio: number): Types.Animatable | any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio).Unit *
				(to.Direction.Magnitude - from.Direction.Magnitude) * ratio + from.Direction.Magnitude
			)

		elseif typeString == "Rect" then
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio &lt; 0.5 then
		return from
	else
		return to
	end
end

return lerpType</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="390">
                <Properties>
                  <string name="Name">packType</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0VGMTU3RTM3LUY3QTMtNDMwNC1BNzUxLUQ3QUZGNUI2MjA5Qn0=]]></BinaryString>
                  <string name="Source">--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): Types.Animatable
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	end
end

return packType</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="391">
                <Properties>
                  <string name="Name">springCoefficients</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezI0OUUzNTU2LTEyOTYtNDhCMy05NDc5LTM3NTdDQkI0QTMyN30=]]></BinaryString>
                  <string name="Source">--[[
	Returns a 2x2 matrix of coefficients for a given damping ratio, speed and
	time step. These coefficients can then be multiplied with the position and
	velocity of an existing spring to find the new position and velocity values.

	Specifically, this function returns four numbers -  posPos, posVel, velPos,
	and velVel, in that order - which can be applied to position and velocity
	like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	If a large number of springs with identical damping ratios and speeds are
	being updated with the same time step, then these coefficients can be used
	to update all of them at once.

	This function assumes the damping ratio, speed and time step are all >= 0,
	with the expectation that these values have been verified beforehand.
]]

local function springCoefficients(timeStep: number, damping: number, speed: number): (number, number, number, number)
	-- if time step or speed is 0, then the spring won't move, so an identity
	-- matrix can be returned early
	if timeStep == 0 or speed == 0 then
		return
			1, 0,
			0, 1
	end

	if damping > 1 then
		-- overdamped spring

		-- solutions to the characteristic equation
		-- z = -ζω ± Sqrt[ζ^2 - 1] ω

		local zRoot = math.sqrt(damping^2 - 1)

		local z1 = (-zRoot - damping)*speed
		local z2 = (zRoot - damping)*speed

		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)

		local zDivide = 1/(z1 - z2)

		local z1Exp = math.exp(timeStep * z1)
		local z2Exp = math.exp(timeStep * z2)

		local posPosCoef = (z2Exp * z1 - z1Exp * z2) * zDivide
		local posVelCoef = (z1Exp - z2Exp) * zDivide

		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local velPosCoef = z1*z2 * (-z1Exp + z2Exp) * zDivide
		local velVelCoef = (z1*z1Exp - z2*z2Exp) * zDivide

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef

	elseif damping == 1 then
		-- critically damped spring

		-- x[t] -> x0(e^-tω)(1+tω) + v0(e^-tω)t

		local timeStepSpeed = timeStep * speed
		local negSpeedExp = math.exp(-timeStepSpeed)

		local posPosCoef = negSpeedExp * (1 + timeStepSpeed)
		local posVelCoef = negSpeedExp * timeStep

		-- v[t] -> x0(t ω^2)(-e^-tω) + v0(1 - tω)(e^-tω)

		local velPosCoef = -negSpeedExp * (timeStep * speed*speed)
		local velVelCoef = negSpeedExp * (1 - timeStepSpeed)

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef

	else
		-- underdamped spring

		-- factored out of the solutions to the characteristic equation, to make
		-- the math cleaner

		local alpha = math.sqrt(1 - damping^2) * speed

		-- x[t] -> x0(e^-tζω)(α Cos[tα] + ζω Sin[tα])/α
		--       + v0(e^-tζω)(Sin[tα])/α

		local negDampSpeedExp = math.exp(-timeStep * damping * speed)

		local sinAlpha = math.sin(timeStep*alpha)
		local alphaCosAlpha = alpha * math.cos(timeStep*alpha)
		local dampSpeedSinAlpha = damping*speed*sinAlpha

		local invAlpha = 1 / alpha

		local posPosCoef = negDampSpeedExp * (alphaCosAlpha + dampSpeedSinAlpha) * invAlpha
		local posVelCoef = negDampSpeedExp * sinAlpha * invAlpha

		-- v[t] -> x0(-e^-tζω)(α^2 + ζ^2 ω^2)(Sin[tα])/α
		--       + v0(e^-tζω)(α Cos[tα] - ζω Sin[tα])/α

		local velPosCoef = -negDampSpeedExp * (alpha*alpha + damping*damping * speed*speed) * sinAlpha * invAlpha
		local velVelCoef = negDampSpeedExp * (alphaCosAlpha - dampSpeedSinAlpha) * invAlpha

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef
	end
end

return springCoefficients</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="392">
                <Properties>
                  <string name="Name">unpackType</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0I0OUYyRjZCLUI2NDAtNEI4Ny1CQTBCLTIzRTMxQkJDNzc2OX0=]]></BinaryString>
                  <string name="Source">--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: Types.Animatable, typeString: string): {number}
	if typeString == "number" then
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="393">
              <Properties>
                <string name="Name">Colour</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="394">
                <Properties>
                  <string name="Name">Oklab</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezRDRjVDQjQxLTkwNjgtNEE0OC1CNUM1LUJGQzdBQTNFNDhEM30=]]></BinaryString>
                  <string name="Source">--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

    local lRoot = l ^ (1/3)
    local mRoot = m ^ (1/3)
    local sRoot = s ^ (1/3)

    return Vector3.new(
        lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
        lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
        lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
    local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
    local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

    local l = lRoot ^ 3
    local m = mRoot ^ 3
    local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="395">
              <Properties>
                <string name="Name">Dependencies</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="396">
                <Properties>
                  <string name="Name">captureDependencies</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezYwOEU2REM3LTBDMEYtNDU0My1BRTdELTk0QzNFODlCNzYwM30=]]></BinaryString>
                  <string name="Source">--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack
-- counts how many sets are currently stored in `initialisedStack`, whether
-- they're currently in use or not
local initialisedStackCapacity = 0

local function captureDependencies(saveToSet: Types.Set&lt;Types.Dependency&lt;any>>, callback: (any) -> any, ...): (boolean, any)
	-- store whichever set was being saved to previously, and replace it with
	-- the new set which was passed in
	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	-- Add a new 'initialised' set to the stack of initialised sets.
	-- If a dependency is created inside the callback (even if indirectly inside
	-- a different `captureDependencies` call), it'll be added to this set.
	-- This can be used to ignore dependencies that were created inside of the
	-- callback.
	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet

	-- instead of constructing new sets all of the time, we can simply leave old
	-- sets in the stack and keep track of the 'real' number of sets ourselves.
	-- this means we don't have to keep creating and throwing away tables, which
	-- is great for performance at the expense of slightly more memory usage.
	if initialisedStackSize > initialisedStackCapacity then
		-- the stack has grown beyond any previous size, so we need to create
		-- a new table
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		-- the stack is smaller or equal to some previous size, so we just need
		-- to clear whatever set was here before
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	-- now that the shared state has been set up, call the callback in a pcall.
	-- using a pcall means the shared state can be reset afterwards, even if an
	-- error occurs.
	local ok, value = xpcall(callback, parseError, ...)

	-- restore the previous set being saved to
	sharedState.dependencySet = prevDependencySet
	-- shrink the stack of initialised sets (essentially removing this set)
	sharedState.initialisedStackSize -= 1

	return ok, value
end

return captureDependencies</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="397">
                <Properties>
                  <string name="Name">initDependency</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezQ2REZGMzIzLUY2QzctNDlEMi1BOEExLThGRjlCMjA4MjYxNn0=]]></BinaryString>
                  <string name="Source">--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: Types.Dependency&lt;any>)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="398">
                <Properties>
                  <string name="Name">sharedState</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezRENThBQzUwLUREMTAtNDc5Qy04REU2LTJFQkU1RDI3OUUzRn0=]]></BinaryString>
                  <string name="Source">--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

type SharedState = {
	dependencySet: Types.Set&lt;Types.Dependency&lt;any>>?,

	initialisedStack: {Types.Set&lt;Types.Dependency&lt;any>>},
	initialisedStackSize: number
}

local sharedState: SharedState = {
	-- The set where used dependencies should be saved to.
	dependencySet = nil,

	-- A stack of sets where newly created dependencies should be stored.
	initialisedStack = {},
	initialisedStackSize = 0
}

return sharedState</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="399">
                <Properties>
                  <string name="Name">updateAll</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezg5NzdCM0MxLUE3NTEtNDE3Qy1COUU1LTJBRjY2RjY2NDlDQX0=]]></BinaryString>
                  <string name="Source">--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function updateAll(ancestor: Types.Dependency&lt;any>)
	--[[
		First things first, we need to mark all indirect dependents as needing
		an update. This means we can ignore any dependencies that aren't related
		to the current update operation.
	]]

	-- set of all dependents that still need to be updated
	local needsUpdateSet: Types.Set&lt;Types.Dependent&lt;any>> = {}
	-- the dependents to be processed now
	local processNow: {Types.Dependent&lt;any>} = {}
	local processNowSize = 0
	-- the dependents of the open set to be processed next
	local processNext: {Types.Dependent&lt;any>} = {}
	local processNextSize = 0

	-- initialise `processNow` with dependents of ancestor
	for dependent in pairs(ancestor.dependentSet) do
		processNowSize += 1
		processNow[processNowSize] = dependent
	end

	repeat
		-- if we add to `processNext` this will be false, indicating we need to
		-- process more dependents
		local processingDone = true

		for _, member in ipairs(processNow) do
			-- mark this member as needing an update
			needsUpdateSet[member] = true

			-- add the dependents of the member for processing
			if member.dependentSet ~= nil then
				for dependent in pairs(member.dependentSet) do
					processNextSize += 1
					processNext[processNextSize] = dependent
					processingDone = false
				end
			end
		end

		-- swap in the next dependents to be processed
		processNow, processNext = processNext, processNow
		processNowSize, processNextSize = processNextSize, 0
		table.clear(processNext)
	until processingDone

	--[[
		`needsUpdateSet` is now set up. Now that we have this information, we
		can iterate over the dependents once more and update them only when the
		relevant dependencies have been updated.
	]]

	-- re-initialise `processNow` similar to before
	processNowSize = 0
	table.clear(processNow)
	for dependent in pairs(ancestor.dependentSet) do
		processNowSize += 1
		processNow[processNowSize] = dependent
	end

	repeat
		-- if we add to `processNext` this will be false, indicating we need to
		-- process more dependents
		local processingDone = true

		for _, member in ipairs(processNow) do
			-- mark this member as no longer needing an update
			needsUpdateSet[member] = nil

			--FUTURE: should this guard against errors?
			local didChange = member:update()

			-- add the dependents of the member for processing
			-- optimisation: if nothing changed, then we don't need to add these
			-- dependents, because they don't need processing.
			if didChange and member.dependentSet ~= nil then
				for dependent in pairs(member.dependentSet) do
					-- don't add dependents that have un-updated dependencies
					local allDependenciesUpdated = true
					for dependentDependency in pairs(dependent.dependencySet) do
						if needsUpdateSet[dependentDependency] then
							allDependenciesUpdated = false
							break
						end
					end

					if allDependenciesUpdated then
						processNextSize += 1
						processNext[processNextSize] = dependent
						processingDone = false
					end
				end
			end
		end

		if not processingDone then
			-- swap in the next dependents to be processed
			processNow, processNext = processNext, processNow
			processNowSize, processNextSize = processNextSize, 0
			table.clear(processNext)
		end
	until processingDone

	--[[
		The update is now complete!
	]]
end

return updateAll</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="400">
                <Properties>
                  <string name="Name">useDependency</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezJCRUM3RjlBLURGOUUtNEEzQS1BNThELUYxMjE1ODU4MzE1NH0=]]></BinaryString>
                  <string name="Source">--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: Types.Dependency&lt;any>)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="401">
              <Properties>
                <string name="Name">Instances</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="402">
                <Properties>
                  <string name="Name">Children</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezhCMTQ1M0QzLTAzREQtNEIyQS1COUNCLTMwMjAyNjBENkM0Qn0=]]></BinaryString>
                  <string name="Source">--[[
	The symbol used to denote the children of an instance when working with the
	`New` function.
]]

return {
	type = "Symbol",
	name = "Children"
}</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="403">
                <Properties>
                  <string name="Name">New</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezgxNjE5RDUyLTBBMDgtNEU3Ri1CRDAzLTVGMjBCMzM4OUM3Q30=]]></BinaryString>
                  <string name="Source">--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local cleanupOnDestroy = require(Package.Utility.cleanupOnDestroy)
local Children = require(Package.Instances.Children)
local Scheduler = require(Package.Instances.Scheduler)
local defaultProps = require(Package.Instances.defaultProps)
local Compat = require(Package.State.Compat)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)

local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_EXPERIMENTAL_GC_MODE = false

-- NOTE: this needs to be weakly held so gc isn't inhibited
local overrideParents: {[Instance]: Types.StateOrValue&lt;Instance>} = setmetatable({}, WEAK_KEYS_METATABLE)

local function New(className: string)
	return function(propertyTable: {[string | Types.Symbol]: any})
		-- things to clean up when the instance is destroyed or gc'd
		local cleanupTasks = {}
		-- event handlers to connect
		local toConnect: {[RBXScriptSignal]: () -> ()} = {}

		--[[
			STEP 1: Create a reference to a new instance
		]]
		local refMetatable = {__mode = ""}
		local ref = setmetatable({}, refMetatable)
		local conn

		do
			local createOK, instance = pcall(Instance.new, className)
			if not createOK then
				logError("cannotCreateClass", nil, className)
			end

			local defaultClassProps = defaultProps[className]
			if defaultClassProps ~= nil then
				for property, value in pairs(defaultClassProps) do
					instance[property] = value
				end
			end

			ref.instance = instance

			conn = instance.Changed:Connect(function() end)
			instance = nil
		end

		--[[
			STEP 2: Apply properties and event handlers
		]]
		for key, value in pairs(propertyTable) do
			-- ignore some keys which will be processed later
			if key == Children or key == "Parent" then
				continue

			--[[
				STEP 2.1: Property (string) keys
			]]
			elseif typeof(key) == "string" then

				-- Properties bound to state
				if typeof(value) == "table" and value.type == "State" then
					local assignOK = pcall(function()
						ref.instance[key] = value:get(false)
					end)

					if not assignOK then
						logError("cannotAssignProperty", nil, className, key)
					end

					table.insert(cleanupTasks,
						Compat(value):onChange(function()
							if ref.instance == nil then
								if ENABLE_EXPERIMENTAL_GC_MODE then
									if conn.Connected then
										warn("ref is nil and instance is around!!!")
									else
										print("ref is nil, but instance was destroyed")
									end
								end
								return
							end
							Scheduler.enqueueProperty(ref.instance, key, value:get(false))
						end)
					)

				-- Properties with constant values
				else
					local assignOK = pcall(function()
						ref.instance[key] = value
					end)

					if not assignOK then
						logError("cannotAssignProperty", nil, className, key)
					end
				end

			--[[
				STEP 2.2: Symbol keys
			]]
			elseif typeof(key) == "table" and key.type == "Symbol" then

				-- Event handler
				if key.name == "OnEvent" then
					local event

					if
						not pcall(function()
							event = ref.instance[key.key]
						end) or
						typeof(event) ~= "RBXScriptSignal"
					then
						logError("cannotConnectChange", nil, className, key.key)
					end

					toConnect[event] = value

				-- Property change handler
				elseif key.name == "OnChange" then
					local event

					if
						not pcall(function()
							event = ref.instance:GetPropertyChangedSignal(key.key)
						end)
					then
						logError("cannotConnectChange", nil, className, key.key)
					end

					toConnect[event] = function()
						if ref.instance == nil then
							if ENABLE_EXPERIMENTAL_GC_MODE then
								if conn.Connected then
									warn("ref is nil and instance is around!!!")
								else
									print("ref is nil, but instance was destroyed")
								end
							end
							return
						end
						value(ref.instance[key.key])
					end

				-- Unknown symbol key
				else
					logError("unrecognisedPropertyKey", nil, key.name)
				end

			-- Unknown key of arbitrary type
			else
				logError("unrecognisedPropertyKey", nil, typeof(key))
			end
		end

		--[[
			STEP 3: If provided, parent [Children] to instance
		]]
		local children = propertyTable[Children]
		if children ~= nil then
			local currentChildren = {}
			local prevChildren = {}

			local currentConnections = {}
			local prevConnections = {}

			local function updateCurrentlyParented()
				if ref.instance == nil then
					if ENABLE_EXPERIMENTAL_GC_MODE then
						if conn.Connected then
							warn("ref is nil and instance is around!!!")
						else
							print("ref is nil, but instance was destroyed")
						end
					end
					return
				end

				prevChildren, currentChildren = currentChildren, prevChildren
				prevConnections, currentConnections = currentConnections, prevConnections

				local function recursiveAddChild(child)
					local childType = typeof(child)

					if childType == "Instance" then
						-- single instance child

						currentChildren[child] = true

						-- reused or newly parented logic
						if prevChildren[child] == nil then
							if overrideParents[child] == nil then
								child.Parent = ref.instance
							end
						else
							prevChildren[child] = nil
						end

					elseif childType == "table" then
						-- could either be an array or state object

						if child.type == "State" then
							-- state object

							recursiveAddChild(child:get(false))

							-- reuse old connection change handler if possible
							local prevDisconnect = prevConnections[child]
							if prevDisconnect ~= nil then
								currentConnections[child] = prevDisconnect
								prevConnections[child] = nil
							else
								-- FUTURE: does this need to be cleaned up when
								-- the instance is destroyed at any point?
								-- If so, how?
								currentConnections[child] = Compat(child):onChange(function()
									Scheduler.enqueueCallback(updateCurrentlyParented)
								end)
							end
						else
							-- array of children
							for _, subChild in pairs(child) do
								recursiveAddChild(subChild)
							end
						end

					-- explicitly allow nils (probably inside a state object)
					elseif childType ~= "nil" then
						logWarn("unrecognisedChildType", childType)
					end
				end

				recursiveAddChild(children)

				-- clean up previous children which weren't reused
				for prevChild in pairs(prevChildren) do
					if overrideParents[prevChild] == nil then
						prevChild.Parent = nil
					end
				end

				-- clean up previous connection handlers which weren't reused
				for prevState, disconnect in pairs(prevConnections) do
					disconnect()
				end

				table.clear(prevChildren)
				table.clear(prevConnections)
			end

			updateCurrentlyParented()
		end

		--[[
			STEP 4: If provided, override the Parent of this instance
		]]
		local parent = propertyTable.Parent
		if parent ~= nil then
			overrideParents[ref.instance] = parent

			if typeof(parent) == "table" and parent.type == "State" then
				-- bind parent to state object
				local assignOK = pcall(function()
					ref.instance.Parent = parent:get(false)
				end)

				if not assignOK then
					logError("cannotAssignProperty", nil, className, "Parent")
				end

				table.insert(cleanupTasks,
					Compat(parent):onChange(function()
						if ref.instance == nil then
							if ENABLE_EXPERIMENTAL_GC_MODE then
								if conn.Connected then
									warn("ref is nil and instance is around!!!")
								else
									print("ref is nil, but instance was destroyed")
								end
							end
							return
						end
						Scheduler.enqueueProperty(ref.instance, "Parent", parent:get(false))
					end)
				)

			else
				-- constant parent assignment
				local assignOK = pcall(function()
					ref.instance.Parent = parent
				end)

				if not assignOK then
					logError("cannotAssignProperty", nil, className, "Parent")
				end
			end
		end

		--[[
			STEP 5: Connect event handlers
		]]
		for event, callback in pairs(toConnect) do
			table.insert(cleanupTasks, event:Connect(callback))
		end

		--[[
			STEP 6: Register cleanup tasks if needed
		]]
		if cleanupTasks[1] ~= nil then
			if ENABLE_EXPERIMENTAL_GC_MODE then
				-- TODO: enabling this code sometimes leads to unexpected nil references appearing
				-- it remains to be determined whether this is a bug with the instance being gc'd
				-- too early, or whether this is a by-product of cleanupOnDestroy() taking some time
				-- before detecting gc'd instances.

				-- when the instance changes ancestor, check if it's still in the
				-- data model - if not, we switch to a weak reference to allow for
				-- gc to occur, otherwise hold the reference strongly
				local function updateRefStrength()
					if game:IsAncestorOf(ref.instance) then
						setmetatable(ref, {})
					else
						setmetatable(ref, {__mode = "v"})
					end
				end

				task.defer(updateRefStrength)
				table.insert(cleanupTasks, ref.instance.AncestryChanged:Connect(updateRefStrength))
			end

			cleanupOnDestroy(ref.instance, cleanupTasks)
		end

		return ref.instance
	end
end

return New</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="404">
                <Properties>
                  <string name="Name">OnChange</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0Y2RTI5N0FELTIzNDItNDk1QS1BOTU1LTg1MzVCOTQ1QzdBMX0=]]></BinaryString>
                  <string name="Source">--[[
	Generates symbols used to denote property change handlers when working with
	the `New` function.
]]

local function OnChange(propertyName: string)
	return {
		type = "Symbol",
		name = "OnChange",
		key = propertyName
	}
end

return OnChange</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="405">
                <Properties>
                  <string name="Name">OnEvent</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezJGMENDQzU1LTdCMDAtNEI3OS05MUE5LUQ5MUE4NERDNkM2Qn0=]]></BinaryString>
                  <string name="Source">--[[
	Generates symbols used to denote event handlers when working with the `New`
	function.
]]

local function OnEvent(eventName: string)
	return {
		type = "Symbol",
		name = "OnEvent",
		key = eventName
	}
end

return OnEvent</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="406">
                <Properties>
                  <string name="Name">Scheduler</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezNEMjQ0RkE4LTdCN0YtNDY4Ny1BRjU5LTc2NzkzOTJFMUI3RH0=]]></BinaryString>
                  <string name="Source">--[[
	Defers and orders UI data binding updates.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local None = require(Package.Utility.None)

local Scheduler = {}

local willUpdate = false
local propertyChanges: {[Instance]: {[string]: any}} = {}
local callbacks: Types.Set&lt;() -> ()> = {}

--[[
	Enqueues an instance property to be updated next render step.
]]
function Scheduler.enqueueProperty(instance: Instance, propertyName: string, newValue: any)
	willUpdate = true

	-- we can't iterate over nil values of tables, so use a symbol instead
	if newValue == nil then
		newValue = None
	end

	local propertyTable = propertyChanges[instance]
	if propertyTable == nil then
		propertyChanges[instance] = {
			[propertyName] = newValue
		}
	else
		propertyTable[propertyName] = newValue
	end
end

--[[
	Enqueues a callback to be run next render step.
]]
function Scheduler.enqueueCallback(callback: TaskCallback)
	willUpdate = true
	callbacks[callback] = true
end

--[[
	Executes all enqueued tasks, and clears out the task lists ready for new
	tasks.
]]
function Scheduler.runTasks()
	-- if no tasks were enqueued, exit early
	if not willUpdate then
		return
	end

	-- execute property changes
	for instance, propertyTable in pairs(propertyChanges) do
		for property, value in pairs(propertyTable) do
			if value == None then
				value = nil
			end
			instance[property] = value
		end
	end

	-- run deferred callbacks
	for callback in pairs(callbacks) do
		callback()
	end

	willUpdate = false
	table.clear(propertyChanges)
	table.clear(callbacks)
end

RunService.Heartbeat:Connect(Scheduler.runTasks)

-- RunService:BindToRenderStep(
-- 	"__FusionUIScheduler",
-- 	Enum.RenderPriority.Last.Value,
-- 	Scheduler.runTasks
-- )

return Scheduler</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="407">
                <Properties>
                  <string name="Name">defaultProps</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezdEQ0YzMkU2LTNCODQtNDNBMC04MzA3LTNFQkQ2RjNGRTYxMn0=]]></BinaryString>
                  <string name="Source">--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

local ENABLE_SENSIBLE_DEFAULTS = true

if ENABLE_SENSIBLE_DEFAULTS then
	return {
		ScreenGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling"
		},

		BillboardGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling"
		},

		SurfaceGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling",

			SizingMode = "PixelsPerStud",
			PixelsPerStud = 50
		},

		Frame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		ScrollingFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			ScrollBarImageColor3 = Color3.new(0, 0, 0)
		},

		TextLabel = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		TextButton = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			AutoButtonColor = false,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		TextBox = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			ClearTextOnFocus = false,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		ImageLabel = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		ImageButton = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			AutoButtonColor = false
		},

		ViewportFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		VideoFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		}
	}
else
	return {}
end</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="408">
              <Properties>
                <string name="Name">Logging</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="409">
                <Properties>
                  <string name="Name">logError</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezZGMzQzQ0YxLTEyNDAtNDMyMi05REQ2LTU3RkMxRUQwOUJGM30=]]></BinaryString>
                  <string name="Source">--[[
	Utility function to log a Fusion-specific error.
]]
local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString = messages[messageID]

	if formatString == nil then
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="410">
                <Properties>
                  <string name="Name">logErrorNonFatal</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezEwOUY2MzRCLUJCNjQtNDJDRC1BMjc5LUMxMTE3NEZDOTA3MH0=]]></BinaryString>
                  <string name="Source">--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]
local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString = messages[messageID]

	if formatString == nil then
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="411">
                <Properties>
                  <string name="Name">logWarn</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezNDNjBGRkM5LTMwN0MtNEM1RS04RTJELTAzMjEwNTcxNTRBMX0=]]></BinaryString>
                  <string name="Source">--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(template, ...)
	local formatString = messages[template]

	if formatString == nil then
		template = "unknownMessage"
		formatString = messages[template]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. template .. ")", ...))
end

return logWarn</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="412">
                <Properties>
                  <string name="Name">messages</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezRDMzlGMkYyLUJCMjUtNDNEMi05RTZFLTBDQUY4MTlFMEVDMH0=]]></BinaryString>
                  <string name="Source">--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	pairsDestructorError = "ComputedPairs destructor error: ERROR_MESSAGE",
	pairsProcessorError = "ComputedPairs callback error: ERROR_MESSAGE",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted as children in `New`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in the property table of `New`"
}</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="413">
                <Properties>
                  <string name="Name">parseError</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezhFMzQ2NDQ4LTcwQUMtNDEwMS04MTY3LTA1MDBGMkU1NTU0Rn0=]]></BinaryString>
                  <string name="Source">--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="414">
              <Properties>
                <string name="Name">State</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="415">
                <Properties>
                  <string name="Name">Compat</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezZBMjZGNTZBLTIxRDctNEY5NC04NEFDLTc1NUU2QjEzQ0NGOX0=]]></BinaryString>
                  <string name="Source">--[[
	Constructs a new state object, which exposes compatibility APIs for
	integrating with non-reactive code.
]]

local Package = script.Parent.Parent
local initDependency = require(Package.Dependencies.initDependency)

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Compat objects in memory.
local strongRefs = {}

--[[
	Called when the watched state changes value.
]]
function class:update()
	for callback in pairs(self._changeListeners) do
		coroutine.wrap(callback)()
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Compat object
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ())
	self._numChangeListeners += 1
	self._changeListeners[callback] = true

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[callback] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Compat(watchedState: Types.State&lt;any>)
	local self = setmetatable({
		type = "State",
		kind = "Compat",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Compat</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="416">
                <Properties>
                  <string name="Name">Computed</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezc2MUUyNjZGLTQ0MkUtNDExMS05NUJFLUVGQTk2NTNFNjUzQX0=]]></BinaryString>
                  <string name="Source">--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update()
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue = captureDependencies(self.dependencySet, self._callback)

	if ok then
		local oldValue = self._value
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return oldValue ~= newValue
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed(callback: () -> any)
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_callback = callback,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="417">
                <Properties>
                  <string name="Name">ComputedPairs</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezBENTRBM0JBLTUzQ0QtNDI1NS04QUNBLTg2RjU2RjY3NzBBMn0=]]></BinaryString>
                  <string name="Source">--[[
	Constructs a new computed state object which maps pairs of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local cleanup = require(Package.Utility.cleanup)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this ComputedPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new value to the output array. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their values from the output table and pass them to the destructor.

]]
function class:update()
	local inputIsState = self._inputIsState
	local oldInput = self._oldInputTable
	local newInput = self._inputTable
	local oldOutput = self._oldOutputTable
	local newOutput = self._outputTable

	if inputIsState then
		newInput = newInput:get(false)
	end

	local didChange = false

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add as dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- STEP 1: find keys that changed value or were not previously present

	for key, newInValue in pairs(newInput) do
		-- get or create key data
		local keyData = self._keyData[key]
		if keyData == nil then
			keyData = {
				-- we don't need strong references here - the main set does that
				-- for us, so let's not introduce unnecessary leak opportunities
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE)
			}
			self._keyData[key] = keyData
		end

		-- if this value is either new or different, we should recalculate it
		local shouldRecalculate = oldInput[key] ~= newInValue

		if not shouldRecalculate then
			-- check if dependencies have changed
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				-- if the dependency changed value, then this needs recalculating
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- if we should recalculate the value by this point, do that
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local oldOutValue = oldOutput[key]
			local processOK, newOutValue = captureDependencies(keyData.dependencySet, self._processor, key, newInValue)

			if processOK then
				-- if the calculated value has changed
				if oldOutValue ~= newOutValue then
					didChange = true

					-- clean up the old calculated value
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor, parseError, oldOutValue)
						if not destructOK then
							logErrorNonFatal("pairsDestructorError", err)
						end
					end
				end

				-- make the old input match the new input
				oldInput[key] = newInValue
				-- store the new output value for next time we run the output comparison
				oldOutput[key] = newOutValue
				-- store the new output value in the table we give to the user
				newOutput[key] = newOutValue
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("pairsProcessorError", newOutValue)
			end
		end

		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed

	for key in pairs(oldInput) do
		-- if this key doesn't have an equivalent in the new input table
		if newInput[key] == nil then
			-- clean up the old calculated value
			local oldOutValue = oldOutput[key]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor, parseError, oldOutValue)
				if not destructOK then
					logErrorNonFatal("pairsDestructorError", err)
				end
			end

			-- make the old input match the new input
			oldInput[key] = nil
			-- remove the reference to the old output value
			oldOutput[key] = nil
			-- remove the value from the table we give to the user
			newOutput[key] = nil
			-- remove key data
			self._keyData[key] = nil
		end
	end

	return didChange
end

local function ComputedPairs(
	inputTable: Types.StateOrValue&lt;{[any]: any}>,
	processor: (any) -> any,
	destructor: (any) -> ()?
)
	-- if destructor function is not defined, use the default cleanup function
	if destructor == nil then
		destructor = cleanup
	end

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ComputedPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyData = {}
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ComputedPairs</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="418">
                <Properties>
                  <string name="Name">State</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezhFMEM2RkI4LTlENjktNDc5NC1CNzUzLUZCM0U5RTk3Q0M4N30=]]></BinaryString>
                  <string name="Source">--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	-- if the value hasn't changed, no need to perform extra work here
	if self._value == newValue and not force then
		return
	end

	self._value = newValue

	-- update any derived state objects if necessary
	updateAll(self)
end

local function State(initialValue: any)
	local self = setmetatable({
		type = "State",
		kind = "State",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return State</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="419">
              <Properties>
                <string name="Name">Types</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0ExMTczNUQ5LUZFNUMtNDdFOS04RjNCLTIxRDdFQ0YzN0MxNH0=]]></BinaryString>
                <string name="Source">--[[
	Stores Luau type definitions shared across scripts in Fusion.
]]

export type Set&lt;T> = {[T]: any}

export type State&lt;T> = {get: (State&lt;T>) -> T}
export type StateOrValue&lt;T> = State&lt;T> | T

export type Symbol = {
	type: string,
	name: string,
	key: string?
}

export type Error = {
	raw: string,
	message: string,
	trace: string
}

export type Dependency&lt;T> = State&lt;T> &amp; {
	dependentSet: Set&lt;Dependent&lt;any>>
}

export type Dependent&lt;T> = State&lt;T> &amp; {
	update: (Dependent&lt;T>) -> boolean,
	dependencySet: Set&lt;Dependency&lt;any>>
}

export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

return nil</string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="Folder" referent="420">
              <Properties>
                <string name="Name">Utility</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="421">
                <Properties>
                  <string name="Name">None</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezg5Q0JCNkNBLUYxQTAtNEU5NC04MUFFLUQyOTg5ODNBMjMyRn0=]]></BinaryString>
                  <string name="Source">--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

return {
	type = "Symbol",
	name = "None"
}</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="422">
                <Properties>
                  <string name="Name">cleanup</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0RDRTdDNkJFLTNCMTEtNERCNS1BMjVCLUNENjYyMUUyNzdGMH0=]]></BinaryString>
                  <string name="Source">--[[
	Cleans up the task passed in as the argument.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

local function cleanup(task: Task)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanup(subtask)
			end
		end
	end
end

return cleanup</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="423">
                <Properties>
                  <string name="Name">cleanupOnDestroy</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezhFNzk3OUI0LTNENDgtNDJDNC1CRUI4LTFCQUYwM0Q1RTM5OH0=]]></BinaryString>
                  <string name="Source">--[[
	Functions like a hypothetical 'Instance.Destroyed' event - when the instance
	is destroyed, cleans up the given task using the default `cleanup` function.
	Returns a function which can be called to stop listening for destruction.

	Relying on this function is dangerous - this should only ever be used when
	no more suitable solution exists. In particular, it's almost certainly the
	wrong solution if you're not dealing with instances passed in by the user.

	NOTE: yes, this uses polling. I've been working on making this function
	work better with events for months, and even then I can't avoid polling. I
	just want something that works in all edge cases, even it if might not be
	the theoretically best solution. This is the best choice for the short term.

	You can find the 'better' version with less polling in the
	`cleanupOnDestroy_smart` file if you're interested in helping out :)
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local cleanup = require(Package.Utility.cleanup)

type TaskData = {
	connection: RBXScriptConnection,
	task: cleanup.Task,
	cleaned: boolean
}

local function noOp()
	-- intentionally blank - no operation!
end

local tasks: {TaskData} = {}
local numTasks = 0
local currentIndex = 1

-- called to check for dead connections and run their cleanup tasks
local function runCleanupTasks()
	if numTasks == 0 then
		return
	end

	-- we want to clean as much stuff up as possible, but we don't want to hang
	-- the client, so we forcibly terminate after a short while
	local startTime = os.clock()
	local endTime = startTime + 1/1000

	-- run at most `numTask` times
	for _=1, numTasks do
		local taskData = tasks[currentIndex]

		if taskData.connection.Connected then
			-- instance is still alive, so move on to the next task
			currentIndex += 1
		else
			-- instance destroyed, so run cleanup and remove the task
			taskData.cleaned = true
			-- print("cleaning up", taskData.debugName)
			cleanup(taskData.task)

			table.remove(tasks, currentIndex)
			numTasks -= 1
		end

		-- wrap around if we passed the end of the task list
		if currentIndex > numTasks then
			currentIndex = 1
		end

		-- if this took too long, exit early to avoid hanging
		if os.clock() > endTime then
			break
		end
	end
end

RunService.Heartbeat:Connect(runCleanupTasks)

local function cleanupOnDestroy(instance: Instance, task: cleanup.Task): (() -> ())
	-- set up connection so we can check if the instance is alive
	-- we don't care about the event we're connecting to, just that we can see
	-- when it's disconnected by the garbage collector
	local connection = instance:GetPropertyChangedSignal("ClassName"):Connect(noOp)

	-- store data about the task for later
	local taskData = {
		debugName = instance.Name,
		connection = connection,
		task = task,
		cleaned = false
	}

	-- remove instance reference so we don't accidentally inhibit gc
	instance = nil

	-- add task to list
	numTasks += 1
	tasks[numTasks] = taskData

	-- return disconnect function to stop listening for destroy
	return function()
		if taskData.cleaned then
			return
		end

		taskData.cleaned = true
		connection:Disconnect()

		local index = table.find(tasks, taskData)
		if index ~= nil then
			table.remove(tasks, index)
			numTasks -= 1
		end
	end
end

return cleanupOnDestroy</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="424">
                <Properties>
                  <string name="Name">cleanupOnDestroy_smart</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0VDREQyNTlCLTNFRjQtNDlFQy1BNUM3LUMwMDNBQTkzMUYxRH0=]]></BinaryString>
                  <string name="Source">--[[
	The 'smarter' version of `cleanupOnDestroy` - this attempts to match the
	results from the 'dumber' polling-based version by using events to reduce
	processing.

	I'd like to improve this technique in the future - it breaks in a fair few
	edge cases right now, so in the interest of stability I don't want to adopt
	it yet.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local cleanup = require(Package.Utility.cleanup)

-- The event to use for waiting (typically Heartbeat)
local STEP_EVENT = RunService.Heartbeat

local function cleanupOnDestroy(instance: Instance?, task: cleanup.Task): (() -> ())
	-- set up manual disconnection logic
	local isDisconnected = false
	local ancestryChangedConn

	local function disconnect()
		if not isDisconnected then
			isDisconnected = true
			ancestryChangedConn:Disconnect()
		end
	end

	-- We can't keep a reference to the instance, but we need to keep track of
	-- when the instance is parented to `nil`.
	-- To get around this, we can save the parent from AncestryChanged here
	local isNilParented = instance.Parent == nil

	-- when AncestryChanged is called, run some destroy-checking logic
	-- this function can yield when called, so make sure to call in a new thread
	-- if you don't want your current thread to block
	local function onInstanceMove(_doNotUse: Instance?, newParent: Instance?)
		if isDisconnected then
			return
		end

		-- discard the first argument so we don't inhibit GC
		_doNotUse = nil

		isNilParented = newParent == nil

		-- if the instance has been moved into a nil parent, it could possibly
		-- have been destroyed if no other references exist
		if isNilParented then
			-- We don't want this function to yield, because it's called
			-- directly from the main body of `connectToDestroy`
			coroutine.wrap(function()
				-- This delay is needed because the event will always be connected
				-- when it is first run, but we need to see if it's disconnected as
				-- a result of the instance being destroyed.
				STEP_EVENT:Wait()

				if isDisconnected then
					return

				elseif not ancestryChangedConn.Connected then
					-- if our event was disconnected, the instance was destroyed
					cleanup(task)
					disconnect()

				else
					-- The instance currently still exists, however there's a
					-- nasty edge case to deal with; if an instance is destroyed
					-- while in nil, `AncestryChanged` won't fire, because its
					-- parent will have changed from nil to nil.

					-- For this reason, we set up a loop to poll
					-- for signs of the instance being destroyed, because we're
					-- out of event-based options.
					while
						isNilParented and
						ancestryChangedConn.Connected and
						not isDisconnected
					do
						-- FUTURE: is this too often?
						STEP_EVENT:Wait()
					end

					-- The instance was either destroyed, or we stopped looping
					-- for another reason (reparented or `disconnect` called)
					-- Check those other conditions before calling the callback.
					if isDisconnected or not isNilParented then
						return
					end

					cleanup(task)
					disconnect()
				end
			end)()
		end
	end

	ancestryChangedConn = instance.AncestryChanged:Connect(onInstanceMove)

	-- in case the instance is currently in nil, we should call `onInstanceMove`
	-- before any other code has the opportunity to run
	if isNilParented then
		onInstanceMove(nil, instance.Parent)
	end

	-- remove this functions' reference to the instance, so it doesn't influence
	-- any garbage collection and cause memory leaks
	instance = nil

	return disconnect
end

return cleanupOnDestroy</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="425">
                <Properties>
                  <string name="Name">restrictRead</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezEyRUI1NjlCLTJCRkUtNDdCOS05RjFFLTRCMUMxMjVBRUQ1MH0=]]></BinaryString>
                  <string name="Source">--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

local function restrictRead(tableName: string, strictTable: table): table
	local metatable = getmetatable(strictTable)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead</string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="426">
          <Properties>
            <string name="Name">evaera_promise@4.0.0</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="427">
            <Properties>
              <string name="Name">promise</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[e0NCMzdEMkNGLUVGRTItNDI0Qi04RDkwLTEwMTI5NUY5MkFBQn0=]]></BinaryString>
              <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="428">
              <Properties>
                <string name="Name">init.spec</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0RCRTVFMDdFLTBBODgtNEQ3NS1CNkVELUQzMEQzNzY5MEJEM30=]]></BinaryString>
                <string name="Source"><![CDATA[return function()
	local Promise = require(script.Parent)
	Promise.TEST = true

	local timeEvent = Instance.new("BindableEvent")
	Promise._timeEvent = timeEvent.Event

	local advanceTime
	do
		local injectedPromiseTime = 0

		Promise._getTime = function()
			return injectedPromiseTime
		end

		function advanceTime(delta)
			delta = delta or (1 / 60)

			injectedPromiseTime = injectedPromiseTime + delta
			timeEvent:Fire(delta)
		end
	end

	local function pack(...)
		local len = select("#", ...)

		return len, { ... }
	end

	describe("Promise.Status", function()
		it("should error if indexing nil value", function()
			expect(function()
				local _ = Promise.Status.wrong
			end).to.throw()
		end)
	end)

	describe("Unhandled rejection signal", function()
		it("should call unhandled rejection callbacks", function()
			local badPromise = Promise.new(function(_resolve, reject)
				reject(1, 2)
			end)

			local callCount = 0

			local function callback(promise, rejectionA, rejectionB)
				callCount += 1

				expect(promise).to.equal(badPromise)
				expect(rejectionA).to.equal(1)
				expect(rejectionB).to.equal(2)
			end

			local unregister = Promise.onUnhandledRejection(callback)

			advanceTime()

			expect(callCount).to.equal(1)

			unregister()

			Promise.new(function(_resolve, reject)
				reject(3, 4)
			end)

			advanceTime()

			expect(callCount).to.equal(1)
		end)
	end)

	describe("Promise.new", function()
		it("should instantiate with a callback", function()
			local promise = Promise.new(function() end)

			expect(promise).to.be.ok()
		end)

		it("should invoke the given callback with resolve and reject", function()
			local callCount = 0
			local resolveArg
			local rejectArg

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				resolveArg = resolve
				rejectArg = reject
			end)

			expect(promise).to.be.ok()

			expect(callCount).to.equal(1)
			expect(resolveArg).to.be.a("function")
			expect(rejectArg).to.be.a("function")
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should resolve promises on resolve()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve)
				callCount = callCount + 1
				resolve()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should reject promises on reject()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				reject()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.new(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(tostring(promise._values[1]):find("init.spec")).to.be.ok()
			expect(tostring(promise._values[1]):find("runExecutor")).to.be.ok()
		end)

		it("should work with C functions", function()
			expect(function()
				Promise.new(tick):andThen(tick)
			end).to.never.throw()
		end)

		it("should have a nice tostring", function()
			expect(tostring(Promise.resolve()):gmatch("Promise(Resolved)")).to.be.ok()
		end)

		it("should allow yielding", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.new(function(resolve)
				bindable.Event:Wait()
				resolve(5)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
		end)

		it("should preserve stack traces of resolve-chained promises", function()
			local function nestedCall(text)
				error(text)
			end

			local promise = Promise.new(function(resolve)
				resolve(Promise.new(function()
					nestedCall("sample text")
				end))
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)

			local trace = tostring(promise._values[1])
			expect(trace:find("sample text")).to.be.ok()
			expect(trace:find("nestedCall")).to.be.ok()
			expect(trace:find("runExecutor")).to.be.ok()
			expect(trace:find("runPlanNode")).to.be.ok()
			expect(
				trace:find("...Rejected because it was chained to the following Promise, which encountered an error:")
			).to.be.ok()
		end)

		it("should report errors from Promises with _error (< v2)", function()
			local oldPromise = Promise.reject()
			oldPromise._error = "Sample error"

			local newPromise = Promise.resolve():andThenReturn(oldPromise)

			expect(newPromise:getStatus()).to.equal(Promise.Status.Rejected)

			local trace = tostring(newPromise._values[1])
			expect(trace:find("Sample error")).to.be.ok()
			expect(
				trace:find("...Rejected because it was chained to the following Promise, which encountered an error:")
			).to.be.ok()
			expect(trace:find("%[No stack trace available")).to.be.ok()
		end)

		it("should allow callable tables", function()
			local promise = Promise.new(setmetatable({}, {
				__call = function(_, resolve)
					resolve(1)
				end,
			}))

			local called = false
			promise:andThen(setmetatable({}, {
				__call = function(_, var)
					expect(var).to.equal(1)
					called = true
				end,
			}))

			expect(called).to.equal(true)
		end)

		itSKIP("should close the thread after resolve", function()
			local count = 0
			Promise.new(function(resolve)
				count += 1
				resolve()
				Promise.delay(1):await()
				count += 1
			end)

			task.wait(1)

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise.defer", function()
		it("should execute after the time event", function()
			local callCount = 0
			local promise = Promise.defer(function(resolve, reject, onCancel, nothing)
				expect(type(resolve)).to.equal("function")
				expect(type(reject)).to.equal("function")
				expect(type(onCancel)).to.equal("function")
				expect(type(nothing)).to.equal("nil")

				callCount = callCount + 1

				resolve("foo")
			end)

			expect(callCount).to.equal(0)
			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)

			advanceTime()
			expect(callCount).to.equal(1)
		end)
	end)

	describe("Promise.delay", function()
		it("should schedule promise resolution", function()
			local promise = Promise.delay(1)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime()
			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should allow for delays to be cancelled", function()
			local promise = Promise.delay(2)

			Promise.delay(1):andThen(function()
				promise:cancel()
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			advanceTime()
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			advanceTime(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			advanceTime(1)
		end)
	end)

	describe("Promise.resolve", function()
		it("should immediately resolve with a value", function()
			local promise = Promise.resolve(5, 6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
			expect(promise._values[2]).to.equal(6)
		end)

		it("should chain onto passed promises", function()
			local promise = Promise.resolve(Promise.new(function(_, reject)
				reject(7)
			end))

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(7)
		end)
	end)

	describe("Promise.reject", function()
		it("should immediately reject with a value", function()
			local promise = Promise.reject(6, 7)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)
			expect(promise._values[2]).to.equal(7)
		end)

		it("should pass a promise as-is as an error", function()
			local innerPromise = Promise.new(function(resolve)
				resolve(6)
			end)

			local promise = Promise.reject(innerPromise)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(innerPromise)
		end)
	end)

	describe("Promise:andThen", function()
		it("should allow yielding", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.resolve():andThen(function()
				bindable.Event:Wait()
				return 5
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
		end)

		it("should run andThens on a new thread", function()
			local bindable = Instance.new("BindableEvent")

			local resolve
			local parentPromise = Promise.new(function(_resolve)
				resolve = _resolve
			end)

			local deadlockedPromise = parentPromise:andThen(function()
				bindable.Event:Wait()
				return 5
			end)

			local successfulPromise = parentPromise:andThen(function()
				return "foo"
			end)

			expect(parentPromise:getStatus()).to.equal(Promise.Status.Started)
			resolve()
			expect(successfulPromise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(successfulPromise._values[1]).to.equal("foo")
			expect(deadlockedPromise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should chain onto resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.resolve(5)

			local chained = promise:andThen(function(...)
				argsLength, args = pack(...)
				callCount = callCount + 1
			end, function()
				badCallCount = badCallCount + 1
			end)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.reject(5)

			local chained = promise:andThen(function(...)
				badCallCount = badCallCount + 1
			end, function(...)
				argsLength, args = pack(...)
				callCount = callCount + 1
			end)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.resolve(1):andThen(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(tostring(promise._values[1]):find("init.spec")).to.be.ok()
			expect(tostring(promise._values[1]):find("runExecutor")).to.be.ok()
		end)

		it("should chain onto asynchronously resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(resolve)
				startResolution = resolve
			end)

			local chained = promise:andThen(function(...)
				args = { ... }
				argsLength = select("#", ...)
				callCount = callCount + 1
			end, function()
				badCallCount = badCallCount + 1
			end)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(_, reject)
				startResolution = reject
			end)

			local chained = promise:andThen(function()
				badCallCount = badCallCount + 1
			end, function(...)
				args = { ... }
				argsLength = select("#", ...)
				callCount = callCount + 1
			end)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should propagate errors through multiple levels", function()
			local x, y, z
			Promise.new(function(resolve, reject)
				reject(1, 2, 3)
			end):andThen(function() end):catch(function(a, b, c)
				x, y, z = a, b, c
			end)

			expect(x).to.equal(1)
			expect(y).to.equal(2)
			expect(z).to.equal(3)
		end)

		it("should not call queued callbacks from a cancelled sub-promise", function()
			local resolve
			local count = 0

			local root = Promise.new(function(r)
				resolve = r
			end)

			root:andThen(function()
				count += 1
			end)

			root
				:andThen(function()
					count += 1
				end)
				:cancel()

			resolve("foo")

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise:cancel", function()
		it("should mark promises as cancelled and not resolve or reject them", function()
			local callCount = 0
			local finallyCallCount = 0
			local promise = Promise.new(function() end)
				:andThen(function()
					callCount = callCount + 1
				end)
				:finally(function()
					finallyCallCount = finallyCallCount + 1
				end)

			promise:cancel()
			promise:cancel() -- Twice to check call counts

			expect(callCount).to.equal(0)
			expect(finallyCallCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should call the cancellation hook once", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject, onCancel)
				onCancel(function()
					callCount = callCount + 1
				end)
			end)

			promise:cancel()
			promise:cancel() -- Twice to check call count

			expect(callCount).to.equal(1)
		end)

		it("should propagate cancellations", function()
			local promise = Promise.new(function() end)

			local consumer1 = promise:andThen()
			local consumer2 = promise:andThen()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Started)

			consumer1:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Started)

			consumer2:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should affect downstream promises", function()
			local promise = Promise.new(function() end)
			local consumer = promise:andThen()

			promise:cancel()

			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should track consumers", function()
			local pending = Promise.new(function() end)
			local p0 = Promise.resolve()
			local p1 = p0:andThen(function()
				return pending
			end)
			local p2 = Promise.new(function(resolve)
				resolve(p1)
			end)
			local p3 = p2:andThen(function() end)

			expect(p1._parent).to.never.equal(p0)
			expect(p2._parent).to.never.equal(p1)
			expect(p2._consumers[p3]).to.be.ok()
			expect(p3._parent).to.equal(p2)
		end)

		it("should cancel resolved pending promises", function()
			local p1 = Promise.new(function() end)

			local p2 = Promise.new(function(resolve)
				resolve(p1)
			end):finally(function() end)

			p2:cancel()

			expect(p1._status).to.equal(Promise.Status.Cancelled)
			expect(p2._status).to.equal(Promise.Status.Cancelled)
		end)

		it("should close the promise thread", function()
			local count = 0
			local promise = Promise.new(function()
				count += 1
				Promise.delay(1):await()
				count += 1
			end)

			promise:cancel()
			advanceTime(2)

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise:finally", function()
		it("should be called upon resolve, reject, or cancel", function()
			local callCount = 0

			local function finally()
				callCount = callCount + 1
			end

			-- Resolved promise
			Promise.new(function(resolve, reject)
				resolve()
			end):finally(finally)

			-- Chained promise
			Promise.resolve():andThen(function() end):finally(finally):finally(finally)

			-- Rejected promise
			Promise.reject():finally(finally)

			local cancelledPromise = Promise.new(function() end):finally(finally)
			cancelledPromise:cancel()

			expect(callCount).to.equal(5)
		end)

		it("should not forward return values", function()
			local value

			Promise.resolve(2)
				:finally(function()
					return 1
				end)
				:andThen(function(v)
					value = v
				end)

			expect(value).to.equal(2)
		end)

		it("should not consume rejections", function()
			local catchRan = false
			local thenRan = false
			Promise.reject(5)
				:finally(function()
					return 42
				end)
				:andThen(function()
					thenRan = true
				end)
				:catch(function(value)
					catchRan = true
					expect(value).to.equal(5)
				end)

			expect(catchRan).to.equal(true)
			expect(thenRan).to.equal(false)
		end)

		it("should wait for returned promises", function()
			local resolve
			local promise = Promise.reject("foo"):finally(function()
				return Promise.new(function(r)
					resolve = r
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			resolve()

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			local _, value = promise:_unwrap()
			expect(value).to.equal("foo")
		end)

		it("should reject with a returned rejected promise's value", function()
			local reject
			local promise = Promise.reject("foo"):finally(function()
				return Promise.new(function(_, r)
					reject = r
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			reject("bar")

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			local _, value = promise:_unwrap()
			expect(value).to.equal("bar")
		end)

		it("should reject when handler errors", function()
			local errorValue = {}
			local promise = Promise.reject("bar"):finally(function()
				error(errorValue)
			end)

			local ok, value = promise:_unwrap()

			expect(ok).to.equal(false)
			expect(value).to.equal(errorValue)
		end)

		it("should not prevent cancellation", function()
			local promise = Promise.new(function() end)

			local finallyRan = false
			promise:finally(function()
				finallyRan = true
			end)

			local consumer = promise:andThen(function() end)

			consumer:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(finallyRan).to.equal(true)
		end)

		it("should propagate cancellation downwards", function()
			local finallyRan = false
			local andThenRan = false
			local root = Promise.new(function() end)

			local consumer = root:finally(function()
				finallyRan = true
			end)

			root:cancel()

			expect(root:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)

			expect(finallyRan).to.equal(true)
			expect(andThenRan).to.equal(false)
		end)

		it("should propagate cancellation upwards", function()
			local finallyRan = false
			local andThenRan = false
			local root = Promise.new(function() end)

			local consumer = root:finally(function()
				finallyRan = true
			end)

			consumer:cancel()

			expect(root:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)

			expect(finallyRan).to.equal(true)
			expect(andThenRan).to.equal(false)
		end)

		it("should cancel returned promise if cancelled", function()
			local internal = Promise.new(function() end)

			local promise = Promise.resolve():finally(function()
				return internal
			end)

			promise:cancel()

			expect(internal:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.all", function()
		it("should error if given something other than a table", function()
			expect(function()
				Promise.all(1)
			end).to.throw()
		end)

		it("should resolve instantly with an empty table if given no promises", function()
			local promise = Promise.all({})
			local success, value = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(value).to.be.a("table")
			expect(next(value)).to.equal(nil)
		end)

		it("should error if given non-promise values", function()
			expect(function()
				Promise.all({ {}, {}, {} })
			end).to.throw()
		end)

		it("should wait for all promises to be resolved and return their values", function()
			local resolveFunctions = {}

			local testValuesLength, testValues = pack(1, "A string", nil, false)

			local promises = {}

			for i = 1, testValuesLength do
				promises[i] = Promise.new(function(resolve)
					resolveFunctions[i] = { resolve, testValues[i] }
				end)
			end

			local combinedPromise = Promise.all(promises)

			for _, resolve in ipairs(resolveFunctions) do
				expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)
				resolve[1](resolve[2])
			end

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, resolved = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(2)
			expect(success).to.equal(true)
			expect(resolved).to.be.a("table")
			expect(#resolved).to.equal(#promises)

			for i = 1, testValuesLength do
				expect(resolved[i]).to.equal(testValues[i])
			end
		end)

		it("should reject if any individual promise rejected", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
			expect(b:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should not resolve if resolved after rejecting", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
		end)

		it("should only reject once", function()
			local rejectA
			local rejectB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(_, reject)
				rejectB = reject
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("foo", "bar")

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Rejected)

			rejectB("baz", "qux")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("foo")
			expect(second).to.equal("bar")
		end)

		it("should error if a non-array table is passed in", function()
			local ok, err = pcall(function()
				Promise.all(Promise.new(function() end))
			end)

			expect(ok).to.be.ok()
			expect(err:find("Non%-promise")).to.be.ok()
		end)

		it("should cancel pending promises if one rejects", function()
			local p = Promise.new(function() end)
			expect(Promise.all({
				Promise.resolve(),
				Promise.reject(),
				p,
			}):getStatus()).to.equal(Promise.Status.Rejected)
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.all(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise.fold", function()
		it("should return the initial value in a promise when the list is empty", function()
			local initialValue = {}
			local result = Promise.fold({}, function()
				error("should not be called")
			end, initialValue)

			expect(Promise.is(result)).to.equal(true)
			expect(result:getStatus()).to.equal(Promise.Status.Resolved)
			expect(result:expect()).to.equal(initialValue)
		end)

		it("should accept promises in the list", function()
			local resolve

			local sum = Promise.fold({ Promise.new(function(r)
				resolve = r
			end), 2, 3 }, function(sum, element)
				return sum + element
			end, 0)

			resolve(1)

			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Resolved)
			expect(sum:expect()).to.equal(6)
		end)

		it("should always return a promise even if the list or reducer don't use them", function()
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 2 then
					return Promise.delay(1):andThenReturn(sum + element)
				else
					return sum + element
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Started)
			advanceTime(2)
			expect(sum:getStatus()).to.equal(Promise.Status.Resolved)
			expect(sum:expect()).to.equal(6)
		end)

		it("should return the first rejected promise", function()
			local errorMessage = "foo"
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 2 then
					return Promise.reject(errorMessage)
				else
					return sum + element
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			local status, rejection = sum:awaitStatus()
			expect(status).to.equal(Promise.Status.Rejected)
			expect(rejection).to.equal(errorMessage)
		end)

		it("should return the first canceled promise", function()
			local secondPromise
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 1 then
					return sum + element
				elseif index == 2 then
					secondPromise = Promise.delay(1):andThenReturn(sum + element)
					return secondPromise
				else
					error("this should not run if the promise is cancelled")
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Started)
			secondPromise:cancel()
			expect(sum:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.race", function()
		it("should resolve with the first settled value", function()
			local promise = Promise.race({
				Promise.resolve(1),
				Promise.resolve(2),
			}):andThen(function(value)
				expect(value).to.equal(1)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should cancel other promises", function()
			local promise = Promise.new(function() end)
			promise:andThen(function() end)
			local promises = {
				promise,
				Promise.new(function() end),
				Promise.new(function(resolve)
					resolve(2)
				end),
			}

			local promise = Promise.race(promises)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(2)
			expect(promises[1]:getStatus()).to.equal(Promise.Status.Started)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Resolved)

			local p = Promise.new(function() end)
			expect(Promise.race({
				Promise.reject(),
				Promise.resolve(),
				p,
			}):getStatus()).to.equal(Promise.Status.Rejected)
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should error if a non-array table is passed in", function()
			local ok, err = pcall(function()
				Promise.race(Promise.new(function() end))
			end)

			expect(ok).to.be.ok()
			expect(err:find("Non%-promise")).to.be.ok()
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.race(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise.promisify", function()
		it("should wrap functions", function()
			local function test(n)
				return n + 1
			end

			local promisified = Promise.promisify(test)
			local promise = promisified(1)
			local success, result = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(result).to.equal(2)
		end)

		it("should catch errors after a yield", function()
			local bindable = Instance.new("BindableEvent")
			local test = Promise.promisify(function()
				bindable.Event:Wait()
				error("errortext")
			end)

			local promise = test()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("errortext")).to.be.ok()
		end)
	end)

	describe("Promise.tap", function()
		it("should thread through values", function()
			local first, second

			Promise.resolve(1)
				:andThen(function(v)
					return v + 1
				end)
				:tap(function(v)
					first = v
					return v + 1
				end)
				:andThen(function(v)
					second = v
				end)

			expect(first).to.equal(2)
			expect(second).to.equal(2)
		end)

		it("should chain onto promises", function()
			local resolveInner, finalValue

			local promise = Promise.resolve(1)
				:tap(function()
					return Promise.new(function(resolve)
						resolveInner = resolve
					end)
				end)
				:andThen(function(v)
					finalValue = v
				end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(finalValue).to.never.be.ok()

			resolveInner(1)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(finalValue).to.equal(1)
		end)
	end)

	describe("Promise.try", function()
		it("should catch synchronous errors", function()
			local errorText
			Promise.try(function()
				error("errortext")
			end):catch(function(e)
				errorText = tostring(e)
			end)

			expect(errorText:find("errortext")).to.be.ok()
		end)

		it("should reject with error objects", function()
			local object = {}
			local success, value = Promise.try(function()
				error(object)
			end):_unwrap()

			expect(success).to.equal(false)
			expect(value).to.equal(object)
		end)

		it("should catch asynchronous errors", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.try(function()
				bindable.Event:Wait()
				error("errortext")
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("errortext")).to.be.ok()
		end)
	end)

	describe("Promise:andThenReturn", function()
		it("should return the given values", function()
			local value1, value2

			Promise.resolve():andThenReturn(1, 2):andThen(function(one, two)
				value1 = one
				value2 = two
			end)

			expect(value1).to.equal(1)
			expect(value2).to.equal(2)
		end)
	end)

	describe("Promise:andThenCall", function()
		it("should call the given function with arguments", function()
			local value1, value2
			Promise.resolve():andThenCall(function(a, b)
				value1 = a
				value2 = b
			end, 3, 4)

			expect(value1).to.equal(3)
			expect(value2).to.equal(4)
		end)
	end)

	describe("Promise.some", function()
		it("should resolve once the goal is reached", function()
			local p = Promise.some({
				Promise.resolve(1),
				Promise.reject(),
				Promise.resolve(2),
			}, 2)
			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(p._values[1][1]).to.equal(1)
			expect(p._values[1][2]).to.equal(2)
		end)

		it("should error if the goal can't be reached", function()
			expect(Promise.some({
				Promise.resolve(),
				Promise.reject(),
			}, 2):getStatus()).to.equal(Promise.Status.Rejected)

			local reject
			local p = Promise.some({
				Promise.resolve(),
				Promise.new(function(_, r)
					reject = r
				end),
			}, 2)

			expect(p:getStatus()).to.equal(Promise.Status.Started)
			reject("foo")
			expect(p:getStatus()).to.equal(Promise.Status.Rejected)
			expect(p._values[1]).to.equal("foo")
		end)

		it("should cancel pending Promises once the goal is reached", function()
			local resolve
			local pending1 = Promise.new(function() end)
			local pending2 = Promise.new(function(r)
				resolve = r
			end)

			local some = Promise.some({
				pending1,
				pending2,
				Promise.resolve(),
			}, 2)

			expect(some:getStatus()).to.equal(Promise.Status.Started)
			expect(pending1:getStatus()).to.equal(Promise.Status.Started)
			expect(pending2:getStatus()).to.equal(Promise.Status.Started)

			resolve()

			expect(some:getStatus()).to.equal(Promise.Status.Resolved)
			expect(pending1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(pending2:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should error if passed a non-number", function()
			expect(function()
				Promise.some({}, "non-number")
			end).to.throw()
		end)

		it("should return an empty array if amount is 0", function()
			local p = Promise.some({
				Promise.resolve(2),
			}, 0)

			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#p._values[1]).to.equal(0)
		end)

		it("should not return extra values", function()
			local p = Promise.some({
				Promise.resolve(1),
				Promise.resolve(2),
				Promise.resolve(3),
				Promise.resolve(4),
			}, 2)

			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#p._values[1]).to.equal(2)
			expect(p._values[1][1]).to.equal(1)
			expect(p._values[1][2]).to.equal(2)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.some(promises, 3):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)

		describe("Promise.any", function()
			it("should return the value directly", function()
				local p = Promise.any({
					Promise.reject(),
					Promise.reject(),
					Promise.resolve(1),
				})

				expect(p:getStatus()).to.equal(Promise.Status.Resolved)
				expect(p._values[1]).to.equal(1)
			end)

			it("should error if all are rejected", function()
				expect(Promise.any({
					Promise.reject(),
					Promise.reject(),
					Promise.reject(),
				}):getStatus()).to.equal(Promise.Status.Rejected)
			end)
		end)
	end)

	describe("Promise.allSettled", function()
		it("should resolve with an array of PromiseStatuses", function()
			local reject
			local p = Promise.allSettled({
				Promise.resolve(),
				Promise.reject(),
				Promise.resolve(),
				Promise.new(function(_, r)
					reject = r
				end),
			})

			expect(p:getStatus()).to.equal(Promise.Status.Started)
			reject()
			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(p._values[1][1]).to.equal(Promise.Status.Resolved)
			expect(p._values[1][2]).to.equal(Promise.Status.Rejected)
			expect(p._values[1][3]).to.equal(Promise.Status.Resolved)
			expect(p._values[1][4]).to.equal(Promise.Status.Rejected)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.allSettled(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise:await", function()
		it("should return the correct values", function()
			local promise = Promise.resolve(5, 6, nil, 7)

			local a, b, c, d, e = promise:await()

			expect(a).to.equal(true)
			expect(b).to.equal(5)
			expect(c).to.equal(6)
			expect(d).to.equal(nil)
			expect(e).to.equal(7)
		end)

		it("should work if yielding is needed", function()
			local ran = false
			task.spawn(function()
				local _, actualTime = Promise.delay(1):await()
				expect(type(actualTime)).to.equal("number")
				ran = true
			end)

			advanceTime(2)
			expect(ran).to.equal(true)
		end)
	end)

	describe("Promise:expect", function()
		it("should throw the correct values", function()
			local rejectionValue = {}
			local promise = Promise.reject(rejectionValue)

			local success, value = pcall(function()
				promise:expect()
			end)

			expect(success).to.equal(false)
			expect(value).to.equal(rejectionValue)
		end)
	end)

	describe("Promise:now", function()
		it("should resolve if the Promise is resolved", function()
			local success, value = Promise.resolve("foo"):now():_unwrap()

			expect(success).to.equal(true)
			expect(value).to.equal("foo")
		end)

		it("should reject if the Promise is not resolved", function()
			local success, value = Promise.new(function() end):now():_unwrap()

			expect(success).to.equal(false)
			expect(Promise.Error.isKind(value, "NotResolvedInTime")).to.equal(true)
		end)

		it("should reject with a custom rejection value", function()
			local success, value = Promise.new(function() end):now("foo"):_unwrap()

			expect(success).to.equal(false)
			expect(value).to.equal("foo")
		end)
	end)

	describe("Promise.each", function()
		it("should iterate", function()
			local ok, result = Promise.each({
				"foo",
				"bar",
				"baz",
				"qux",
			}, function(...)
				return { ... }
			end):_unwrap()

			expect(ok).to.equal(true)
			expect(result[1][1]).to.equal("foo")
			expect(result[1][2]).to.equal(1)
			expect(result[2][1]).to.equal("bar")
			expect(result[2][2]).to.equal(2)
			expect(result[3][1]).to.equal("baz")
			expect(result[3][2]).to.equal(3)
			expect(result[4][1]).to.equal("qux")
			expect(result[4][2]).to.equal(4)
		end)

		it("should iterate serially", function()
			local resolves = {}
			local callCounts = {}

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				callCounts[index] = (callCounts[index] or 0) + 1

				return Promise.new(function(resolve)
					table.insert(resolves, function()
						resolve(value:upper())
					end)
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(#resolves).to.equal(1)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(#resolves).to.equal(1)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.equal(1)
			expect(callCounts[3]).to.never.be.ok()

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.equal(1)
			expect(callCounts[3]).to.equal(1)

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(type(promise._values[1])).to.equal("table")
			expect(type(promise._values[2])).to.equal("nil")

			local result = promise._values[1]

			expect(result[1]).to.equal("FOO")
			expect(result[2]).to.equal("BAR")
			expect(result[3]).to.equal("BAZ")
		end)

		it("should reject with the value if the predicate promise rejects", function()
			local promise = Promise.each({ 1, 2, 3 }, function()
				return Promise.reject("foobar")
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("foobar")
		end)

		it("should allow Promises to be in the list and wait when it gets to them", function()
			local innerResolve
			local innerPromise = Promise.new(function(resolve)
				innerResolve = resolve
			end)

			local promise = Promise.each({
				innerPromise,
			}, function(value)
				return value * 2
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			innerResolve(2)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1][1]).to.equal(4)
		end)

		it("should reject with the value if a Promise from the list rejects", function()
			local called = false
			local promise = Promise.each({ 1, 2, Promise.reject("foobar") }, function(value)
				called = true
				return "never"
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("foobar")
			expect(called).to.equal(false)
		end)

		it("should reject immediately if there's a cancelled Promise in the list initially", function()
			local cancelled = Promise.new(function() end)
			cancelled:cancel()

			local called = false
			local promise = Promise.each({ 1, 2, cancelled }, function()
				called = true
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(called).to.equal(false)
			expect(promise._values[1].kind).to.equal(Promise.Error.Kind.AlreadyCancelled)
		end)

		it("should stop iteration if Promise.each is cancelled", function()
			local callCounts = {}

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				callCounts[index] = (callCounts[index] or 0) + 1

				return Promise.new(function() end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()

			promise:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()
		end)

		it("should cancel the Promise returned from the predicate if Promise.each is cancelled", function()
			local innerPromise

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				innerPromise = Promise.new(function() end)
				return innerPromise
			end)

			promise:cancel()

			expect(innerPromise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should cancel Promises in the list if Promise.each is cancelled", function()
			local innerPromise = Promise.new(function() end)

			local promise = Promise.each({ innerPromise }, function() end)

			promise:cancel()

			expect(innerPromise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.retry", function()
		it("should retry N times", function()
			local counter = 0

			local promise = Promise.retry(function(parameter)
				expect(parameter).to.equal("foo")

				counter = counter + 1

				if counter == 5 then
					return Promise.resolve("ok")
				end

				return Promise.reject("fail")
			end, 5, "foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("ok")
		end)

		it("should reject if threshold is exceeded", function()
			local promise = Promise.retry(function()
				return Promise.reject("fail")
			end, 5)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("fail")
		end)
	end)

	describe("Promise.retryWithDelay", function()
		it("should retry after a delay", function()
			local counter = 0

			local promise = Promise.retryWithDelay(function(parameter)
				expect(parameter).to.equal("foo")

				counter = counter + 1

				if counter == 3 then
					return Promise.resolve("ok")
				end

				return Promise.reject("fail")
			end, 3, 10, "foo")

			expect(counter).to.equal(1)

			advanceTime(11)

			expect(counter).to.equal(2)

			advanceTime(11)

			expect(counter).to.equal(3)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("ok")
		end)
	end)

	describe("Promise.fromEvent", function()
		it("should convert a Promise into an event", function()
			local event = Instance.new("BindableEvent")

			local promise = Promise.fromEvent(event.Event)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("foo")
		end)

		it("should convert a Promise into an event with the predicate", function()
			local event = Instance.new("BindableEvent")

			local promise = Promise.fromEvent(event.Event, function(param)
				return param == "foo"
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("bar")

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("foo")
		end)
	end)

	describe("Promise.is", function()
		it("should work with current version", function()
			local promise = Promise.resolve(1)

			expect(Promise.is(promise)).to.equal(true)
		end)

		it("should work with any object with an andThen", function()
			local obj = {
				andThen = function()
					return 1
				end,
			}

			expect(Promise.is(obj)).to.equal(true)
		end)

		it("should work with older promises", function()
			local OldPromise = {}
			OldPromise.prototype = {}
			OldPromise.__index = OldPromise.prototype

			function OldPromise.prototype:andThen() end

			local oldPromise = setmetatable({}, OldPromise)

			expect(Promise.is(oldPromise)).to.equal(true)
		end)
	end)
end
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="429">
          <Properties>
            <string name="Name">howmanysmall_janitor@1.14.1</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="430">
            <Properties>
              <string name="Name">janitor</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezIyNzA5MjMwLTYxOEMtNDRFMC1BRjVELTUzMDMyNUNGOUEyRH0=]]></BinaryString>
              <string name="Source"><![CDATA[-- Compiled with L+ C Edition
-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.
-- Cleanup edge cases fixed by codesenseAye.

local GetPromiseLibrary = require(script.GetPromiseLibrary)
local RbxScriptConnection = require(script.RbxScriptConnection)
local Symbol = require(script.Symbol)
local FoundPromiseLibrary, Promise = GetPromiseLibrary()

local IndicesReference = Symbol("IndicesReference")
local LinkToInstanceIndex = Symbol("LinkToInstanceIndex")

local INVALID_METHOD_NAME = "Object is a %s and as such expected `true?` for the method name and instead got %s. Traceback: %s"
local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s)) Traceback: %s"

type RbxScriptConnection = RbxScriptConnection.RbxScriptConnection

--[=[
	Janitor is a light-weight, flexible object for cleaning up connections, instances, or anything. This implementation covers all use cases,
	as it doesn't force you to rely on naive typechecking to guess how an instance should be cleaned up.
	Instead, the developer may specify any behavior for any object.

	@class Janitor
]=]
local Janitor = {}
Janitor.ClassName = "Janitor"
Janitor.CurrentlyCleaning = true
Janitor[IndicesReference] = nil
Janitor.__index = Janitor

--[=[
	@prop CurrentlyCleaning boolean
	@within Janitor

	Whether or not the Janitor is currently cleaning up.
]=]

local TypeDefaults = {
	["function"] = true;
	thread = true;
	RBXScriptConnection = "Disconnect";
}

--[=[
	Instantiates a new Janitor object.
	@return Janitor
]=]
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

--[=[
	Determines if the passed object is a Janitor. This checks the metatable directly.

	@param Object any -- The object you are checking.
	@return boolean -- `true` if `Object` is a Janitor.
]=]
function Janitor.Is(Object: any): boolean
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

type StringOrTrue = string | boolean

--[=[
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time.
	If the `MethodName` is `true` the `Object` itself will be called if it's a function or have `task.cancel` called on it if it is a thread. If passed
	an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.

	:::info
	Objects not given an explicit `MethodName` will be passed into the `typeof` function for a very naive typecheck.
	RBXConnections will be assigned to "Disconnect", functions and threads will be assigned to `true`, and everything else will default to "Destroy".
	Not recommended, but hey, you do you.
	:::

	### Luau:

	```lua
	local Workspace = game:GetService("Workspace")
	local TweenService = game:GetService("TweenService")

	local Obliterator = Janitor.new()
	local Part = Workspace.Part

	-- Queue the Part to be Destroyed at Cleanup time
	Obliterator:Add(Part, "Destroy")

	-- Queue function to be called with `true` MethodName
	Obliterator:Add(print, true)

	-- Close a thread.
	Obliterator:Add(task.defer(function()
		while true do
			print("Running!")
			task.wait(0.5)
		end
	end), true)

	-- This implementation allows you to specify behavior for any object
	Obliterator:Add(TweenService:Create(Part, TweenInfo.new(1), {Size = Vector3.new(1, 1, 1)}), "Cancel")

	-- By passing an Index, the Object will occupy a namespace
	-- If "CurrentTween" already exists, it will call :Remove("CurrentTween") before writing
	Obliterator:Add(TweenService:Create(Part, TweenInfo.new(1), {Size = Vector3.new(1, 1, 1)}), "Destroy", "CurrentTween")
	```

	### TypeScript:

	```ts
	import { Workspace, TweenService } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor<{ CurrentTween: Tween }>();
	const Part = Workspace.FindFirstChild("Part") as Part;

	// Queue the Part to be Destroyed at Cleanup time
	Obliterator.Add(Part, "Destroy");

	// Queue function to be called with `true` MethodName
	Obliterator.Add(print, true);

	// Close a thread.
	Obliterator.Add(task.defer(() => {
		while (true) {
			print("Running!");
			task.wait(0.5);
		}
	}), true);

	// This implementation allows you to specify behavior for any object
	Obliterator.Add(TweenService.Create(Part, new TweenInfo(1), {Size: new Vector3(1, 1, 1)}), "Cancel");

	// By passing an Index, the Object will occupy a namespace
	// If "CurrentTween" already exists, it will call :Remove("CurrentTween") before writing
	Obliterator.Add(TweenService.Create(Part, new TweenInfo(1), {Size: new Vector3(1, 1, 1)}), "Destroy", "CurrentTween");
	```

	@param Object T -- The object you want to clean up.
	@param MethodName? string|true -- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param Index? any -- The index that can be used to clean up the object manually.
	@return T -- The object that was passed as the first argument.
]=]
function Janitor:Add<T>(Object: T, MethodName: StringOrTrue?, Index: any?): T
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local TypeOf = typeof(Object)
	local NewMethodName = MethodName or TypeDefaults[TypeOf] or "Destroy"

	if TypeOf == "function" or TypeOf == "thread" then
		if NewMethodName ~= true then
			warn(string.format(INVALID_METHOD_NAME, TypeOf, tostring(NewMethodName), debug.traceback(nil :: any, 2)))
		end
	else
		if not (Object :: any)[NewMethodName] then
			warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(NewMethodName), debug.traceback(nil :: any, 2)))
		end
	end

	self[Object] = NewMethodName
	return Object
end

--[=[
	Adds a [Promise](https://github.com/evaera/roblox-lua-promise) to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled.

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:AddPromise(Promise.delay(3)):andThenCall(print, "Finished!"):catch(warn)
	task.wait(1)
	Obliterator:Cleanup()
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor();
	Obliterator.AddPromise(Promise.delay(3)).andThenCall(print, "Finished!").catch(warn);
	task.wait(1);
	Obliterator.Cleanup();
	```

	@param PromiseObject Promise -- The promise you want to add to the Janitor.
	@return Promise
]=]
function Janitor:AddPromise(PromiseObject)
	if FoundPromiseLibrary then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject), debug.traceback(nil :: any, 2)))
		end

		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
					PromiseObject:cancel()
				end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end

--[=[
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of [Janitor.Add](#Add).

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(workspace.Baseplate, "Destroy", "Baseplate")
	Obliterator:Remove("Baseplate")
	```

	### TypeScript:

	```ts
	import { Workspace } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor<{ Baseplate: Part }>();
	Obliterator.Add(Workspace.FindFirstChild("Baseplate") as Part, "Destroy", "Baseplate");
	Obliterator.Remove("Baseplate");
	```

	@param Index any -- The index you want to remove.
	@return Janitor
]=]
function Janitor:Remove(Index: any)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					if type(Object) == "function" then
						Object()
					else
						task.cancel(Object)
					end
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[=[
	Cleans up multiple objects at once.

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(function()
		print("Removed One")
	end, true, "One")

	Obliterator:Add(function()
		print("Removed Two")
	end, true, "Two")

	Obliterator:Add(function()
		print("Removed Three")
	end, true, "Three")

	Obliterator:RemoveList("One", "Two", "Three") -- Prints "Removed One", "Removed Two", and "Removed Three"
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	type NoOp = () => void

	const Obliterator = new Janitor<{ One: NoOp, Two: NoOp, Three: NoOp }>();
	Obliterator.Add(() => print("Removed One"), true, "One");
	Obliterator.Add(() => print("Removed Two"), true, "Two");
	Obliterator.Add(() => print("Removed Three"), true, "Three");

	Obliterator.RemoveList("One", "Two", "Three"); // Prints "Removed One", "Removed Two", and "Removed Three"
	```

	@since v1.14
	@param ... any -- The indices you want to remove.
	@return Janitor
]=]
function Janitor:RemoveList(...: any)
	local This = self[IndicesReference]
	if This then
		local Length = select("#", ...)
		if Length == 1 then
			return self:Remove(...)
		else
			for Index = 1, Length do
				-- MACRO
				local Object = This[select(Index, ...)]
				if Object then
					local MethodName = self[Object]

					if MethodName then
						if MethodName == true then
							if type(Object) == "function" then
								Object()
							else
								task.cancel(Object)
							end
						else
							local ObjectMethod = Object[MethodName]
							if ObjectMethod then
								ObjectMethod(Object)
							end
						end

						self[Object] = nil
					end

					This[Index] = nil
				end
			end
		end
	end

	return self
end

--[=[
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using `__index`.

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(workspace.Baseplate, "Destroy", "Baseplate")
	print(Obliterator:Get("Baseplate")) -- Returns Baseplate.
	```

	### TypeScript:

	```ts
	import { Workspace } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor<{ Baseplate: Part }>();
	Obliterator.Add(Workspace.FindFirstChild("Baseplate") as Part, "Destroy", "Baseplate");
	print(Obliterator.Get("Baseplate")); // Returns Baseplate.
	```

	@param Index any -- The index that the object is stored under.
	@return any? -- This will return the object if it is found, but it won't return anything if it doesn't exist.
]=]
function Janitor:Get(Index: any): any?
	local This = self[IndicesReference]
	return if This then This[Index] else nil
end

local function GetFenv(self)
	return function()
		for Object, MethodName in next, self do
			if Object ~= IndicesReference then
				return Object, MethodName
			end
		end
	end
end

--[=[
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace.
	This function is also called when you call a Janitor Object (so it can be used as a destructor callback).

	### Luau:

	```lua
	Obliterator:Cleanup() -- Valid.
	Obliterator() -- Also valid.
	```

	### TypeScript:

	```ts
	Obliterator.Cleanup()
	```
]=]
function Janitor:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil

		local Get = GetFenv(self)
		local Object, MethodName = Get()

		while Object and MethodName do -- changed to a while loop so that if you add to the janitor inside of a callback it doesn't get untracked (instead it will loop continuously which is a lot better than a hard to pindown edgecase)
			if MethodName == true then
				if type(Object) == "function" then
					Object()
				else
					task.cancel(Object)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
			Object, MethodName = Get()
		end

		local This = self[IndicesReference]
		if This then
			table.clear(This)
			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

--[=[
	Calls [Janitor.Cleanup](#Cleanup) and renders the Janitor unusable.

	:::warning
	Running this will make any further attempts to call a method of Janitor error.
	:::
]=]
function Janitor:Destroy()
	self:Cleanup()
	table.clear(self)
	setmetatable(self, nil)
end

Janitor.__call = Janitor.Cleanup

--[=[
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected.
	A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter,
	the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable.
	When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.

	### Luau:

	```lua
	local Obliterator = Janitor.new()

	Obliterator:Add(function()
		print("Cleaning up!")
	end, true)

	do
		local Folder = Instance.new("Folder")
		Obliterator:LinkToInstance(Folder)
		Folder:Destroy()
	end
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor();
	Obliterator.Add(() => print("Cleaning up!"), true);

	{
		const Folder = new Instance("Folder");
		Obliterator.LinkToInstance(Folder, false);
		Folder.Destroy();
	}
	```

	@param Object Instance -- The instance you want to link the Janitor to.
	@param AllowMultiple? boolean -- Whether or not to allow multiple links on the same Janitor.
	@return RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance.
]=]
function Janitor:LinkToInstance(Object: Instance, AllowMultiple: boolean?): RBXScriptConnection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex

	return self:Add(Object.Destroying:Connect(function()
		self:Cleanup()
	end), "Disconnect", IndexToUse)
end

--[=[
	This is the legacy LinkToInstance function. It is kept for backwards compatibility in case something is different with `Instance.Destroying`.

	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected.
	A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter,
	the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable.
	When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	This returns a mock `RBXScriptConnection` (see: [RbxScriptConnection](/api/RbxScriptConnection)).

	### Luau:

	```lua
	local Obliterator = Janitor.new()

	Obliterator:Add(function()
		print("Cleaning up!")
	end, true)

	do
		local Folder = Instance.new("Folder")
		Obliterator:LinkToInstance(Folder)
		Folder:Destroy()
	end
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor();
	Obliterator.Add(() => print("Cleaning up!"), true);

	{
		const Folder = new Instance("Folder");
		Obliterator.LinkToInstance(Folder, false);
		Folder.Destroy();
	}
	```

	@deprecated v1.4.1 -- Use `Janitor:LinkToInstance` instead.
	@param Object Instance -- The instance you want to link the Janitor to.
	@param AllowMultiple? boolean -- Whether or not to allow multiple links on the same Janitor.
	@return RbxScriptConnection -- A pseudo RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance.
]=]
function Janitor:LegacyLinkToInstance(Object: Instance, AllowMultiple: boolean?): RbxScriptConnection
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, RbxScriptConnection)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				task.defer(function()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							task.wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil :: any
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

--[=[
	Links several instances to a new Janitor, which is then returned.

	@param ... Instance -- All the Instances you want linked.
	@return Janitor -- A new Janitor that can be used to manually disconnect all LinkToInstances.
]=]
function Janitor:LinkToInstances(...: Instance)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

function Janitor:__tostring()
	return "Janitor"
end

export type Janitor = typeof(Janitor.new())
table.freeze(Janitor)
return Janitor
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="431">
              <Properties>
                <string name="Name">GetPromiseLibrary</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezZGRDQyN0ZDLUU4RDItNEMzRC05NDI3LTI4OEY4REZBNDdEM30=]]></BinaryString>
                <string name="Source"><![CDATA[-- TODO: When Promise is on Wally, remove this in favor of just `script.Parent.Parent:FindFirstChild("Promise")`.
local ReplicatedFirst = game:GetService("ReplicatedFirst")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local ServerStorage = game:GetService("ServerStorage")

local LOCATIONS_TO_SEARCH = {script.Parent.Parent, ReplicatedFirst, ReplicatedStorage, ServerScriptService, ServerStorage}

local function FindFirstDescendantWithNameAndClassName(Parent: Instance, Name: string, ClassName: string)
	for _, Descendant in ipairs(Parent:GetDescendants()) do
		if Descendant:IsA(ClassName) and Descendant.Name == Name then
			return Descendant
		end
	end

	return nil
end

local function GetPromiseLibrary()
	-- I'm not too keen on how this is done.
	-- It's better than the multiple if statements (probably).
	local Plugin = script:FindFirstAncestorOfClass("Plugin")
	if Plugin then
		local Promise = FindFirstDescendantWithNameAndClassName(Plugin, "Promise", "ModuleScript")
		if Promise then
			return true, require(Promise)
		else
			return false
		end
	end

	local Promise
	for _, Location in ipairs(LOCATIONS_TO_SEARCH) do
		Promise = FindFirstDescendantWithNameAndClassName(Location, "Promise", "ModuleScript")
		if Promise then
			break
		end
	end

	if Promise then
		return true, require(Promise)
	else
		return false
	end
end

return GetPromiseLibrary
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="432">
              <Properties>
                <string name="Name">RbxScriptConnection</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0I4NzlENTUxLTU5REMtNENBNi05N0UyLTM1RDg1QTc1OEIxQX0=]]></BinaryString>
                <string name="Source"><![CDATA[--[=[
	A wrapper for an `RBXScriptConnection`. Makes the Janitor clean up when the instance is destroyed. This was created by Corecii.

	@class RbxScriptConnection
]=]
local RbxScriptConnection = {}
RbxScriptConnection.Connected = true
RbxScriptConnection.__index = RbxScriptConnection

--[=[
	@prop Connected boolean
	@within RbxScriptConnection

	Whether or not this connection is still connected.
]=]

--[=[
	Disconnects the Signal.
]=]
function RbxScriptConnection:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function RbxScriptConnection._new(RBXScriptConnection: RBXScriptConnection)
	return setmetatable({
		Connection = RBXScriptConnection;
	}, RbxScriptConnection)
end

function RbxScriptConnection:__tostring()
	return "RbxScriptConnection<" .. tostring(self.Connected) .. ">"
end

export type RbxScriptConnection = typeof(RbxScriptConnection._new(game:GetPropertyChangedSignal("ClassName"):Connect(function() end)))
return RbxScriptConnection
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="433">
              <Properties>
                <string name="Name">Symbol</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezY5OTU1Qjg5LTQxNkEtNEU4MC05MTY3LTVEQ0RFODRFRTM2Qn0=]]></BinaryString>
                <string name="Source"><![CDATA[-- This only exists because the LSP warns Key `__tostring` not found in type `table?`.
local function Symbol(Name: string)
	local self = newproxy(true)
	local Metatable = getmetatable(self)
	function Metatable.__tostring()
		return Name
	end

	return self
end

return Symbol
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="434">
          <Properties>
            <string name="Name">csqrl_sift@0.0.2</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="435">
            <Properties>
              <string name="Name">sift</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <Content name="LinkedSource">
                <null>
                </null>
              </Content>
              <BinaryString name="ScriptGuid"><![CDATA[ezc5RjI3QUY1LUQxOUYtNDQyOS04NkQzLUVDMzQzNjFGRTdGRX0=]]></BinaryString>
              <string name="Source"><![CDATA[--!strict
local Types = require(script.Types)

--[=[
	@class Sift

	Sift is a library for manipulating arrays. It provides a number of
	functions for manipulating arrays (lists), dictionaries, and sets.

	Sift is comprised of a number of submodules. Each submodule provides
	a number of functions for manipulating a specific type of data, and
	can be accessed via their respective names within the Sift module
	(e.g. `Sift.Array.At()`), or accessed directly (e.g. `local At = require(Sift.Array.At)`).

	Some methods and modules also have aliases, which can are documented in the
	corresponding submodule/method's documentation.

	See the individual submodule pages for full documentation.

	The Luau types `Dictionary<K, V>`, `Array<T>` (aliased as `List<T>`) and `Set<T>` are exported from the Sift module (e.g. they can be used via `Sift.Array<string>`), but are also available from [Sift.Types].
]=]
local Sift = {
	Array = require(script.Array),
	Dictionary = require(script.Dictionary),
	Set = require(script.Set),

	None = require(script.None),
	Types = require(script.Types),

	equalObjects = require(script.Util.equalObjects),
	isEmpty = require(script.Util.isEmpty),
}

Sift.List = Sift.Array

--- @prop Array Array
--- @within Sift

--- @prop List Array
--- @within Sift
--- @tag Alias

--- @prop Dictionary Dictionary
--- @within Sift

--- @prop Set Set
--- @within Sift

--- @prop Types Types
--- @within Sift

export type Dictionary<K, V> = Types.Dictionary<K, V>

export type Array<T> = Types.Array<T>
export type List<T> = Array<T>
export type Set<T> = Types.Set<T>

return Sift
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="436">
              <Properties>
                <string name="Name">Array</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0RDRTJDNjQxLTQ3MkEtNEQ4MC1BNTVFLTk2Q0Q5MkJEMTE0M30=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict
--[=[
	@class Array

	An array is a table consisting of index-value pairs. You don't need to
	manually specify the indices when you create an array.

	```lua
	local array = {
		"hello",
		"world",
	}
	```

	<br><br>

	#### Aliases

	`List`
]=]
local Array = {
	at = require(script.at),
	concat = require(script.concat),
	concatDeep = require(script.concatDeep),
	copy = require(script.copy),
	copyDeep = require(script.copyDeep),
	count = require(script.count),
	create = require(script.create),
	equals = require(script.equals),
	equalsDeep = require(script.equalsDeep),
	every = require(script.every),
	filter = require(script.filter),
	find = require(script.find),
	findLast = require(script.findLast),
	findWhere = require(script.findWhere),
	findWhereLast = require(script.findWhereLast),
	first = require(script.first),
	flatten = require(script.flatten),
	freeze = require(script.freeze),
	freezeDeep = require(script.freezeDeep),
	includes = require(script.includes),
	insert = require(script.insert),
	last = require(script.last),
	map = require(script.map),
	pop = require(script.pop),
	push = require(script.push),
	reduce = require(script.reduce),
	reduceRight = require(script.reduceRight),
	removeIndex = require(script.removeIndex),
	removeIndices = require(script.removeIndices),
	removeValue = require(script.removeValue),
	removeValues = require(script.removeValues),
	reverse = require(script.reverse),
	set = require(script.set),
	shift = require(script.shift),
	shuffle = require(script.shuffle),
	slice = require(script.slice),
	some = require(script.some),
	sort = require(script.sort),
	splice = require(script.splice),
	toSet = require(script.toSet),
	unshift = require(script.unshift),
	update = require(script.update),
	zip = require(script.zip),
	zipAll = require(script.zipAll),
}

Array.join = Array.concat
Array.merge = Array.concat
Array.joinDeep = Array.concatDeep
Array.mergeDeep = Array.concatDeep
Array.append = Array.push
Array.prepend = Array.unshift
Array.indexOf = Array.find
Array.has = Array.includes
Array.contains = Array.includes

return Array
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="437">
                <Properties>
                  <string name="Name">at</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezVBOTZCMUM5LThFMEYtNDIzNS04OTdFLTE3MjcyQUQ3OEMzMX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function at
	@within Array

	@param array {T} -- The array to get the value from.
	@param index number -- The index to get the value from (can be negative).
	@return T -- The value at the given index.

	Gets a value from an array at the given index.

	```lua
	local array = { 1, 2, 3 }

	local value = At(array, 1) -- 1
	local value = At(array, 0) -- 3
	```
]=]
local function at<T>(array: { T }, index: number): T
	local length = #array

	if index < 1 then
		index += length
	end

	return array[index]
end

return at
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="438">
                <Properties>
                  <string name="Name">concat</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezNEN0QzNzI5LUFDMUEtNEYwQy04MUVELUQ3QkZDQUZGRkMxN30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local None = require(Sift.None)

--[=[
	@function concat
	@within Array

	@param ... ...any -- The arrays to concatenate.
	@return {T} -- The concatenated array.

	Joins multiple arrays together into a single array.

	#### Aliases

	`join`, `merge`

	```lua
	local table1 = { 1, 2, 3 }
	local table2 = { 4, 5, 6 }

	local new = Concat(table1, table2) -- { 1, 2, 3, 4, 5, 6 }
	```
]=]
local function concat<T>(...: any): { T }
	local result = {}

	for arrayIndex = 1, select("#", ...) do
		local array = select(arrayIndex, ...)

		if type(array) ~= "table" then
			continue
		end

		for _, item in ipairs(array) do
			if item ~= None then
				table.insert(result, item)
			end
		end
	end

	return result
end

return concat
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="439">
                <Properties>
                  <string name="Name">concatDeep</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0M5RjhBMzdFLTIyRTEtNDZFNi1CM0Q4LTA1QUNDODQyRUY5M30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local CopyDeep = require(script.Parent.copyDeep)
local None = require(Sift.None)

--[=[
	@function concatDeep
	@within Array

	@param ... ...any -- The arrays to concatenate.
	@return {T} -- The concatenated array.

	Joins multiple arrays together into a single array, with deep copies of all
	nested arrays.

	#### Aliases

	`joinDeep`, `mergeDeep`

	```lua
	local table1 = { 1, 2, { 3, 4 } }
	local table2 = { 5, 6, { 7, 8 } }

	local new = ConcatDeep(table1, table2) -- { 1, 2, { 3, 4 }, 5, 6, { 7, 8 } }
	```
]=]
local function concatDeep<T>(...: any): { T }
	local result = {}

	for arrayIndex = 1, select("#", ...) do
		local array = select(arrayIndex, ...)

		if type(array) ~= "table" then
			continue
		end

		for _, value in ipairs(array) do
			if value ~= None then
				if type(value) == "table" then
					table.insert(result, CopyDeep(value))
				else
					table.insert(result, value)
				end
			end
		end
	end

	return result
end

return concatDeep
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="440">
                <Properties>
                  <string name="Name">copy</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezkzOENCOTI4LUFBNzgtNEExOS05QUZCLUJDOTdENEM4NjY0OH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function copy
	@within Array

	@param array {T} -- The array to copy.
	@return {T} -- The copied array.

	Copies an array.

	```lua
	local array = { 1, 2, 3 }

	local new = Copy(array) -- { 1, 2, 3 }

	print(new == array) -- false
	```
]=]
return table.clone
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="441">
                <Properties>
                  <string name="Name">copyDeep</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezJBNUQ5MUQ0LUJGMUUtNDQxQi1BNkFFLUVCQjE1MTA0N0Q3MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function copyDeep
	@within Array

	@param array {T} -- The array to copy.
	@return {T} -- The copied array.

	Copies an array, with deep copies of all nested arrays.

	```lua
	local array = { 1, 2, 3, { 4, 5 } }

	local result = CopyDeep(array) -- { 1, 2, 3, { 4, 5 } }

	print(result == array) -- false
	print(result[4] == array[4]) -- false
	```
]=]
local function copyDeep<T>(array: { T }): { T }
	local result = {}

	for _, value in ipairs(array) do
		if type(value) == "table" then
			table.insert(result, copyDeep(value))
		else
			table.insert(result, value)
		end
	end

	return result
end

return copyDeep
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="442">
                <Properties>
                  <string name="Name">count</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezVEMzZGOEJGLTlGRkYtNDBCNS1CMzM3LTNBQ0MyOEU2OUZBOX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)

--[=[
	@function count
	@within Array

	@param array {T} -- The array to count the number of items in.
	@param predicate? (value: T, index: number, array: {T}) -> any -- The predicate to use to filter the array.
	@return number -- The number of items in the array.

	Counts the number of items in an array.

	```lua
	local array = { 1, 2, 3 }

	local value = Count(array) -- 3
	local value = Count(array, function(item, index)
		return item == 2
	end) -- 1
	```
]=]
local function count<T>(array: { T }, predicate: ((value: T, index: number, array: { T }) -> any)?): number
	local counter = 0

	predicate = if type(predicate) == "function" then predicate else Util.func.truthy

	for index, value in ipairs(array) do
		if predicate(value, index, array) then
			counter += 1
		end
	end

	return counter
end

return count
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="443">
                <Properties>
                  <string name="Name">create</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezZBQzgzRTVDLTI0QUYtNDA3MS1BOUY1LTRGNTYzRjJGNjA5NX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function create
  @within Array

  @param length number -- The length of the array to create.
  @param value? T -- The value to fill the array with.
  @return {T} -- The created array.

  Creates an array of the given length, filled with the given value.
  This is just a wrapper around `table.create`.

  ```lua
  local array = Create(3, "Hello")

  print(array) -- { "Hello", "Hello", "Hello" }
  ```
]=]
return table.create
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="444">
                <Properties>
                  <string name="Name">equals</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezIwNEE2QkMxLUQyNzEtNEMwQi1BMTE1LTc1MjQwNENDMkI4RH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)

local function compare(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return a == b
	end

	local aLength = #a

	if #b ~= aLength then
		return false
	end

	for i = 1, aLength do
		if a[i] ~= b[i] then
			return false
		end
	end

	return true
end

--[=[
	@function equals
	@within Array

	@param ... ...{any} -- The arrays to compare.
	@return boolean -- Whether the arrays are equal.

	Compares two arrays for equality.

	```lua
	local array = { 1, 2, 3 }
	local other = { 1, 2, 3 }

	local value = Equals(array, other) -- true
	local value = Equals(array, other, { 1, 2, 3 }) -- true
	local value = Equals(array, other, { 1, 2, 4 }) -- false
	```
]=]
local function equals<T>(...: { T }): boolean
	if Util.equalObjects(...) then
		return true
	end

	local totalArgs = select("#", ...)
	local firstItem = select(1, ...)

	for i = 2, totalArgs do
		local item = select(i, ...)

		if not compare(firstItem, item) then
			return false
		end
	end

	return true
end

return equals
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="445">
                <Properties>
                  <string name="Name">equalsDeep</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezUzM0E5QkU2LURGQTEtNDVEQi1CRjRELUI5RUVDMTdFOUIxNn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)

local function compareDeep(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return a == b
	end

	local aLength = #a

	if #b ~= aLength then
		return false
	end

	for i = 1, aLength do
		if not compareDeep(a[i], b[i]) then
			return false
		end
	end

	return true
end

--[=[
	@function equalsDeep
	@within Array

	@param ... ...{any} -- The arrays to compare.
	@return boolean -- Whether the arrays are equal.

	Compares two arrays for equality using deep comparison.

	```lua
	local array = { 1, 2, 3, { 4, 5 } }
	local other = { 1, 2, 3, { 4, 5 } }

	local value = EqualsDeep(array, other) -- true
	local value = EqualsDeep(array, other, { 1, 2, 3, { 4, 5 } }) -- true
	local value = EqualsDeep(array, other, { 1, 2, 3, { 4, 6 } }) -- false
	```
]=]
local function equalsDeep<T>(...: { T }): boolean
	if Util.equalObjects(...) then
		return true
	end

	local totalArgs = select("#", ...)
	local firstItem = select(1, ...)

	for i = 2, totalArgs do
		local item = select(i, ...)

		if not compareDeep(firstItem, item) then
			return false
		end
	end

	return true
end

return equalsDeep
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="446">
                <Properties>
                  <string name="Name">every</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezVENDQzRTZDLTBGNkMtNDJFNC1CRkZELTU0MTFCMERCNDE0Rn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function every
	@within Array

	@param array {T} -- The array to check.
	@param predicate (value: T, index: number, array: {T}) -> any -- The predicate to use to check the array.
	@return boolean -- Whether every item in the array passes the predicate.

	Checks whether every item in the array passes the predicate.

	```lua
	local array = { 1, 2, 3 }

	local value = Every(array, function(item, index)
		return item > 0
	end) -- true

	local value = Every(array, function(item, index)
		return item > 1
	end) -- false
	```
]=]
local function every<T>(array: { T }, predicate: (value: T, index: number, array: { T }) -> any): boolean
	for index, value in ipairs(array) do
		if not predicate(value, index, array) then
			return false
		end
	end

	return true
end

return every
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="447">
                <Properties>
                  <string name="Name">filter</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezBDRjQ4QUU3LTYwODItNEIxRi04MDY0LTg0QTJBREQ2N0NDNX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)

--[=[
	@function filter
	@within Array

	@param array {T} -- The array to filter.
	@param filterer? (value: T, index: number, array: {T}) -> any -- The callback to use to filter the array.
	@return {T} -- The filtered array.

	Filters an array using a filterer callback. Any items that do not pass the filterer will be removed from the array.

	If no filterer is provided, all items will be kept.

	```lua
	local array = { 1, 2, 3 }

	local result = Filter(array, function(item, index)
		return item > 1
	end) -- { 2, 3 }
	```
]=]
local function filter<T>(array: { T }, predicate: ((value: T, index: number, array: { T }) -> boolean?)?): { T }
	local result = {}

	predicate = if type(predicate) == "function" then predicate else Util.func.truthy

	for index, value in ipairs(array) do
		if predicate(value, index, array) then
			table.insert(result, value)
		end
	end

	return result
end

return filter
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="448">
                <Properties>
                  <string name="Name">find</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezEwOEM0OUU5LTM1RDgtNEQ4NS1BNzBCLUJDQjA3QUU3NjEyOX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function find
	@within Array

	@param array {T} -- The array to search.
	@param value? any -- The value to search for.
	@param from? number -- The index to start searching from.
	@return number? -- The index of the first item in the array that matches the value.

	Finds the index of the first item in the array that matches the value. This is
	mostly a wrapper around `table.find`, with the ability to specify a negative
	number as the start index (to search relative to the end of the array).

	#### Aliases
	`indexOf`

	```lua
	local array = { "hello", "world", "hello" }

	local index = Find(array, "hello") -- 1
	local index = Find(array, "hello", 2) -- 3
	```
]=]
local function find<T>(array: { T }, value: any?, from: number?): number?
	local length = #array

	from = if type(from) == "number" then if from < 1 then length + from else from else 1

	return table.find(array, value, from)
end

return find
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="449">
                <Properties>
                  <string name="Name">findLast</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezYwNEYzQzYzLTk3QUYtNDdDOC04OTZELTJCMDI2MkRGRUU2MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function findLast
	@within Array

	@param array {T} -- The array to search.
	@param value? any -- The value to search for.
	@param from? number -- The index to start searching from.
	@return number? -- The index of the last item in the array that matches the value.

	Finds the index of the last item in the array that matches the value.

	```lua
	local array = { "hello", "world", "hello" }

	local index = FindLast(array, "hello") -- 3
	local index = FindLast(array, "hello", 2) -- 1
	```
]=]
local function findLast<T>(array: { T }, value: any?, from: number?): number?
	local length = #array

	from = if type(from) == "number" then if from < 1 then length + from else from else length

	for index = from, 1, -1 do
		if array[index] == value then
			return index
		end
	end

	return
end

return findLast
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="450">
                <Properties>
                  <string name="Name">findWhere</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0YwOEREM0VBLUMwMEEtNDA0Ny04RTQ0LUZCMzg0M0UwNjk4NH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function findWhere
	@within Array

	@param array {T} -- The array to search.
	@param predicate (value: T, index: number, array: {T}) -> any -- The predicate to use to check the array.
	@param from? number -- The index to start searching from.
	@return number -- The index of the first item in the array that matches the predicate.

	Finds the index of the first item in the array that passes the predicate.

	```lua
	local array = { 1, 2, 3 }

	local index = FindWhere(array, function(item, index)
		return item > 1
	end) -- 2
	```
]=]
local function findWhere<T>(
	array: { T },
	predicate: (value: T, index: number, array: { T }) -> any,
	from: number?
): number?
	local length = #array

	from = if type(from) == "number" then if from < 1 then length + from else from else 1

	for index = from, #array do
		if predicate(array[index], index, array) then
			return index
		end
	end

	return
end

return findWhere
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="451">
                <Properties>
                  <string name="Name">findWhereLast</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezlEMjY2MUVGLTE3OTgtNDFBRC04RkM2LTg2QzczOUIyQjA4NH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function findWhereLast
	@within Array

	@param array {T} -- The array to search.
	@param predicate (value: T, index: number, array: {T}) -> any -- The predicate to use to check the array.
	@param from? number -- The index to start searching from.
	@return number -- The index of the last item in the array that matches the predicate.

	Finds the index of the last item in the array that passes the predicate.

	```lua
	local array = { "hello", "world", "hello" }

	local index = FindWhereLast(array, function(item, index)
		return item == "hello"
	end) -- 3

	local index = FindWhereLast(array, function(item, index)
		return item == "hello"
	end, 2) -- 1
	```
]=]
local function findWhereLast<T>(
	array: { T },
	predicate: (value: T, index: number, array: { T }) -> any,
	from: number?
): number?
	local length = #array

	from = if type(from) == "number" then if from < 1 then length + from else from else length

	for index = from, 1, -1 do
		if predicate(array[index], index, array) then
			return index
		end
	end

	return
end

return findWhereLast
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="452">
                <Properties>
                  <string name="Name">first</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezYwQUFENEZGLTRBRjYtNEY4Ni1CMzVELUNGMjNCNjI2RjQ5M30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local At = require(script.Parent.at)

--[=[
	@function first
	@within Array

	@param array {T} -- The array to get the first item from.
	@return T -- The first item in the array.

	Gets the first item in the array.

	```lua
	local array = { 1, 2, 3 }

	local value = First(array) -- 1
	```
]=]
local function first<T>(array: { T }): T
	return At(array, 1)
end

return first
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="453">
                <Properties>
                  <string name="Name">flatten</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0Q1OEU4NTg1LUVFRTYtNEIzMy1CQzE5LTMzNDE2MEU5OENFRX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function flatten
	@within Array

	@param array {T} -- The array to flatten.
	@param depth? number -- The depth to flatten the array to.
	@return {T} -- The flattened array.

	Flattens an array. If depth is not specified, it will flatten
	the array as far as it can go.

	```lua
	local array = {
		{ 1, 2, 3 },
		{ 4, 5, 6 },
		{ 7, { 8, 9 } },
	}

	local new = Flatten(array) -- { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	local new = Flatten(array, 1) -- { 1, 2, 3, 4, 5, 6, 7, { 8, 9 } }
	```
]=]
local function flatten<T>(array: { T }, depth: number?): { T }
	depth = if type(depth) == "number" then depth else math.huge

	local result = {}

	for _, value in ipairs(array) do
		if type(value) == "table" and depth > 0 then
			local nested = flatten(value, depth - 1)

			for _, nestedValue in ipairs(nested) do
				table.insert(result, nestedValue)
			end
		else
			table.insert(result, value)
		end
	end

	return result
end

return flatten
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="454">
                <Properties>
                  <string name="Name">freeze</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0RDMDBDODBDLTZBQkUtNDE2Ny04RDcyLTk1RDEzNUVFNjRCMn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Copy = require(script.Parent.copy)

--[=[
  @function freeze
  @within Array

  @param array {T} -- The array to freeze.
  @return {T} -- The frozen array.

  Freezes the top level of the array, making it read-only.

  ```lua
  local array = { 1, 2, 3, { 4, 5, 6 } }

  local new = Freeze(array)

  new[1] = 4 -- error!
  new[4][1] = 7 -- still works!
  ```
]=]
local function freeze<T>(array: { T }): { T }
	local new = Copy(array)

	table.freeze(new)

	return new
end

return freeze
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="455">
                <Properties>
                  <string name="Name">freezeDeep</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezJDOUU0NDY0LTQxODgtNDNDRS05MERDLUVFODk2OUJDNzFCNX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function freezeDeep
	@within Array

	@param array {T} -- The array to freeze.
	@return {T} -- The frozen array.

	Freezes the entire array, making it read-only, including all
	nested arrays.

	```lua
	local array = { 1, 2, 3, { 4, 5, 6 } }

	local new = FreezeDeep(array)

	new[1] = 4 -- error!
	new[4][1] = 7 -- error!
	```
]=]
local function freezeDeep<T>(array: { T }): { T }
	local result = {}

	for i = 1, #array do
		local value = array[i]

		if type(value) == "table" then
			table.insert(result, freezeDeep(value))
		else
			table.insert(result, value)
		end
	end

	table.freeze(result)

	return result
end

return freezeDeep
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="456">
                <Properties>
                  <string name="Name">includes</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0NFRDNBRTJBLTRDODktNDdEMC04NjExLTFFNkYyMUIxRDg5Qn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Find = require(script.Parent.find)

--[=[
	@function includes
	@within Array

	@param array {T} -- The array to search.
	@param value any -- The value to search for.
	@param from? number -- The index to start searching from.
	@return boolean -- Whether the array contains the value.

	Checks whether the array contains the value. This is a wrapper
	around `Find`.

	#### Aliases

	`contains`, `has`

	```lua
	local array = { "hello", "world", "goodbye" }

	local value = Includes(array, "hello") -- true
	local value = Includes(array, "sift") -- false
	local value = Includes(array, "hello", 2) -- false
	```
]=]
local function includes<T>(array: { T }, value: any, from: number?): boolean
	return Find(array, value, from) ~= nil
end

return includes
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="457">
                <Properties>
                  <string name="Name">insert</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0Q2NTk0OEQwLUZGQzEtNENGQy05MjM1LTAyQkJCQjZDRjY4NH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function insert
	@within Array

	@param array {T} -- The array to insert the value into.
	@param index number -- The index to insert the value at (can be negative).
	@param values ...T -- The values to insert.
	@return {T} -- The array with the value inserted.

	Inserts the given values into an array at the given index, shifting all values after it to the right. If the index is negative (or 0), it is counted from the end of the array.

	If the index to insert at is out of range, the array is not modified.

	```lua
	local array = { 1, 2, 3 }

	local newArray = Insert(array, 2, 4) -- { 1, 4, 2, 3 }
	```
]=]
local function insert<T>(array: { T }, index: number, ...: T): { T }
	local length = #array

	if index < 1 then
		index += length + 1
	end

	if index > length then
		if index > length + 1 then
			return array
		end

		index = length + 1
		length += 1
	end

	local result = {}

	for i = 1, length do
		if i == index then
			for _, value in ipairs({ ... }) do
				table.insert(result, value)
			end
		end

		table.insert(result, array[i])
	end

	return result
end

return insert
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="458">
                <Properties>
                  <string name="Name">last</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezM3QjU1QjFCLTkxMTgtNEZCNy1CNTFBLTQ5QzRGMEU0REJDNX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local At = require(script.Parent.at)

--[=[
	@function last
	@within Array

	@param array {T} -- The array to get the last element of.
	@return T -- The last element of the array.

	Gets the last element of the array.

	```lua
	local array = { 1, 2, 3 }

	local value = Last(array) -- 3
	```
]=]
local function last<T>(array: { T }): T
	return At(array, 0)
end

return last
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="459">
                <Properties>
                  <string name="Name">map</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0IwRjlGQjIzLUEyNTQtNDlGOS05RTY4LUY0RDhBMTUwNTEwQn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function map
	@within Array

	@param array {T} -- The array to map.
	@param mapper (value: T, index: number, array: {T}) -> U? -- The mapper function.
	@return {U} -- The mapped array.

	Maps the array using the mapper function.

	```lua
	local array = { 1, 2, 3 }

	local new = Map(array, function(value, index)
		return value * 2
	end) -- { 2, 4, 6 }
	```
]=]
local function map<T, U>(array: { T }, mapper: (value: T, index: number, array: { T }) -> U?): { U }
	local mapped = {}

	for index, value in ipairs(array) do
		local mappedValue = mapper(value, index, array)

		if mappedValue ~= nil then
			table.insert(mapped, mappedValue)
		end
	end

	return mapped
end

return map
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="460">
                <Properties>
                  <string name="Name">pop</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezQ3REIwQjZBLUVFN0EtNDRBOC05MDU0LTM4RjJDOTdGMTU5M30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function pop
	@within Array

	@param array {T} -- The array to pop an element from.
	@param count? number = 1 -- The number of elements to pop.
	@return {T} -- An array with the popped elements removed.

	Removes an element from the end of the array, and returns
	the array with the popped elements removed.

	```lua
	local array = { 1, 2, 3 }

	local new = Pop(array) -- { 1, 2 }
	local new = Pop(array, 2) -- { 1 }
	```
]=]
local function pop<T>(array: { T }, count: number?): { T }
	local length = #array
	local result = {}

	count = if type(count) == "number" then count else 1

	for i = 1, length - count do
		table.insert(result, array[i])
	end

	return result
end

return pop
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="461">
                <Properties>
                  <string name="Name">push</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0JGM0M2QTAxLTU0NTYtNEE0MS05MUEyLTIzRkRDNDMwQ0M1Nn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function push
	@within Array

	@param array {T} -- The array to push an element to.
	@param ... ...T -- The elements to push.
	@return {T} -- The array with the pushed elements.

	Adds elements to the end of the array.

	#### Aliases

	`append`

	```lua
	local array = { 1, 2, 3 }

	local new = Push(array, 4, 5, 6) -- { 1, 2, 3, 4, 5, 6 }
	```
]=]
local function push<T>(array: { T }, ...: T): { T }
	local result = {}

	for index, value in ipairs(array) do
		table.insert(result, value)
	end

	for _, value in ipairs({ ... }) do
		table.insert(result, value)
	end

	return result
end

return push
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="462">
                <Properties>
                  <string name="Name">reduce</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezYxRjZCRjk2LUZEOEItNEE0Qi04NkE4LUQ5ODMzRTQyMEIxRX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function reduce
	@within Array

	@param array {T} -- The array to reduce.
	@param reducer (accumulator: U, value: T, index: number, array: {T}) -> U -- The reducer to use.
	@param initialReduction? U = {T}[1] -- The initial accumulator value.
	@return U -- The final accumulator value.

	Reduces the array using the given reducer and initial accumulator value.
	If no `initialReduction` value is given, the first item in the array is used.

	```lua
	local array = { 1, 2, 3 }

	local value = Reduce(array, function(accumulator, item, index)
		return accumulator - item
	end) -- -4

	local value = Reduce(array, function(accumulator, item, index)
		table.insert(accumulator, item)
		return accumulator
	end, {}) -- { 1, 2, 3 }
	```
]=]
local function reduce<T, U>(
	array: { T },
	reducer: (accumulator: U, value: T, index: number, array: { T }) -> U,
	initReduction: U?
): U
	local result = initReduction
	local start = 1

	if not result then
		result = array[1]
		start = 2
	end

	for index = start, #array do
		result = reducer(result, array[index], index, array)
	end

	return result
end

return reduce
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="463">
                <Properties>
                  <string name="Name">reduceRight</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezlEMTgxNENBLTkzQTAtNDU1Qi05MjlFLTVBMTY4ODIwOEFCQ30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function reduceRight
	@within Array

	@param array {T} -- The array to reduce.
	@param reducer (accumulator: U, value: T, index: number, array: {T}) -> U -- The reducer to use.
	@param initialReduction? U = {T}[#{T}] -- The initial accumulator value.
	@return U -- The final accumulator value.

	Reduces the array using the given reducer and initial accumulator value,
	starting from the end of the array. If no `initialReduction` value is given,
	the last item in the array is used.

	```lua
	local array = { 1, 2, 3 }

	local value = ReduceRight(array, function(accumulator, item, index)
		return accumulator - item
	end) -- 0

	local value = ReduceRight(array, function(accumulator, item, index)
		table.insert(accumulator, item)
		return accumulator
	end, {}) -- { 3, 2, 1 }
	```
]=]
local function reduceRight<T, U>(
	array: { T },
	reducer: (accumulator: U, value: T, index: number, array: { T }) -> U,
	initReduction: U?
): U
	local result = initReduction
	local start = #array

	if not result then
		result = array[start]
		start -= 1
	end

	for index = start, 1, -1 do
		result = reducer(result, array[index], index, array)
	end

	return result
end

return reduceRight
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="464">
                <Properties>
                  <string name="Name">removeIndex</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezgzRjhBMkQ5LTQ0RDctNDhCMC04MzZFLUQ0OTBFQ0JDMzExM30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function removeIndex
	@within Array

	@param array {T} -- The array to remove the value from.
	@param index number -- The index to remove the value from (can be negative).
	@return {T} -- The array with the value removed.

	Removes a value from an array at the given index.

	```lua
	local array = { 1, 2, 3 }

	local new = RemoveIndex(array, 1) -- { 2, 3 }
	local new = RemoveIndex(array, -1) -- { 1, 3 }
	```
]=]
local function removeIndex<T>(array: { T }, index: number): { T }
	local length = #array
	local result = {}

	if index < 1 then
		index += length
	end

	for arrIndex, value in ipairs(array) do
		if arrIndex ~= index then
			table.insert(result, value)
		end
	end

	return result
end

return removeIndex
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="465">
                <Properties>
                  <string name="Name">removeIndices</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezE5RTA1QUVELTczRjEtNEQ3Qi1CNDBCLUVDOEEyRjJEMkM2MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function removeIndices
	@within Array

	@param array {T} -- The array to remove the indices from.
	@param ... ...number -- The indices to remove the values from (can be negative).
	@return {T} -- The array with the values removed.

	Removes values from an array at the given indices.

	```lua
	local array = { 1, 2, 3 }

	local new = RemoveIndices(array, 1, 2) -- { 3 }
	local new = RemoveIndices(array, 0, -1) -- { 1 }
	```
]=]
local function removeIndices<T>(array: { T }, ...: number): { T }
	local length = #array
	local indices = {}
	local result = {}

	for _, index in ipairs({ ... }) do
		if index < 1 then
			index += length
		end

		indices[index] = true
	end

	for index, value in ipairs(array) do
		if not indices[index] then
			table.insert(result, value)
		end
	end

	return result
end

return removeIndices
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="466">
                <Properties>
                  <string name="Name">removeValue</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezBDMDZEN0ExLTQ2N0UtNDgwMS1BOEY0LThDQzBFQUZBNTRGOH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function removeValue
	@within Array

	@param array {T} -- The array to remove the value from.
	@param value T -- The value to remove.
	@return {T} -- The array with the value removed.

	Removes a value from an array.

	```lua
	local array = { 1, 2, 3 }

	local new = RemoveValue(array, 2) -- { 1, 3 }
	```
]=]
local function removeValue<T>(array: { T }, value: T): { T }
	local result = {}

	for index, arrValue in ipairs(array) do
		if arrValue ~= value then
			table.insert(result, arrValue)
		end
	end

	return result
end

return removeValue
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="467">
                <Properties>
                  <string name="Name">removeValues</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0VCMUI5MDM1LTREMUUtNEU3RC04M0M4LTVGRjkzMThFRDNCNn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local ToSet = require(script.Parent.toSet)

--[=[
	@function removeValues
	@within Array

	@param array {T} -- The array to remove values from.
	@param ... T -- The values to remove.
	@return {T} -- The array with the values removed.

	Removes values from an array.

	```lua
	local array = { "a", "b", "c", "c", "d", "e" }

	local new = RemoveValues(array, "c", "d") -- { "a", "b", "e" }
	```
]=]
local function removeValues<T>(array: { T }, ...: T): { T }
	local valueSet = ToSet({ ... })
	local result = {}

	for _, value in ipairs(array) do
		if not valueSet[value] then
			table.insert(result, value)
		end
	end

	return result
end

return removeValues
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="468">
                <Properties>
                  <string name="Name">reverse</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0JEM0FDOTE0LTdEMTMtNDlDMC1CODVGLTNCMTg1RDAxODcxQ30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function reverse
	@within Array

	@param array {T} -- The array to reverse.
	@return {T} -- The reversed array.

	Reverses the order of the items in an array.

	```lua
	local array = { 1, 2, 3 }

	local new = Reverse(array) -- { 3, 2, 1 }
	```
]=]
local function reverse<T>(array: { T }): { T }
	local result = {}

	for index = #array, 1, -1 do
		table.insert(result, array[index])
	end

	return result
end

return reverse
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="469">
                <Properties>
                  <string name="Name">set</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezEyMkVBMDUyLTM2NUYtNENBOC1BOEQ1LTFFRDAxMTYyMUQ5MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function set
	@within Array

	@param array {T} -- The array to set the value on.
	@param index number -- The index to set the value at (can be negative).
	@param value T -- The value to set.
	@return {T} -- The array with the value set.

	Sets a value on an array at the given index.

	```lua
	local array = { 1, 2, 3 }

	local new = Set(array, 2, 4) -- { 1, 4, 3 }
	local new = Set(array, -1, 4) -- { 1, 2, 4 }
	```
]=]
local function set<T>(array: { T }, index: number, value: T?): { T }
	local length = #array
	local result = {}

	if index < 1 then
		index += length
	end

	for arrIndex, arrValue in ipairs(array) do
		if arrIndex == index then
			table.insert(result, value)
		else
			table.insert(result, arrValue)
		end
	end

	return result
end

return set
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="470">
                <Properties>
                  <string name="Name">shift</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezdBNDYxNDc5LTUwOEMtNDA0MS04NzE0LTFDODNBNUJBRkU5NH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function shift
	@within Array

	@param array {T} -- The array to shift.
	@param count? number -- The number of items to shift.
	@return {T} -- The shifted array.

	Removes the first item from an array and returns the array
	with the item removed.

	```lua
	local array = { 1, 2, 3 }

	local new = Shift(array) -- { 2, 3 }
	local new = Shift(array, 2) -- { 3 }
	```
]=]
local function shift<T>(array: { T }, count: number?): { T }
	local length = #array
	local result = {}

	count = if type(count) == "number" then count + 1 else 2

	for i = count, length do
		table.insert(result, array[i])
	end

	return result
end

return shift
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="471">
                <Properties>
                  <string name="Name">shuffle</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezlGNTEyRTlBLThDOTUtNEU0NC05NkZDLUJGQ0I2MDgzNkU3MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Copy = require(script.Parent.copy)

--[=[
	@function shuffle
	@within Array

	@param array {T} -- The array to shuffle.
	@return {T} -- The shuffled array.

	Randomises the order of the items in an array.

	```lua
	local array = { 1, 2, 3 }

	local new = Shuffle(array) -- { 2, 3, 1 }
	```
]=]
local function shuffle<T>(array: { T }): { T }
	local random = Random.new(os.time() * #array)
	local result = Copy(array)

	for index = #result, 1, -1 do
		local randomIndex = random:NextInteger(1, index)
		local temp = result[index]

		result[index] = result[randomIndex]
		result[randomIndex] = temp
	end

	return result
end

return shuffle
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="472">
                <Properties>
                  <string name="Name">slice</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezg5MEZBNkNELTEzMjctNEEwQi1CNDkyLTQzRkRBQURBRDY1N30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function slice
	@within Array

	@param array {T} -- The array to slice.
	@param from? number -- The index to start from (can be negative).
	@param to? number -- The index to end at (can be negative).
	@return {T} -- The sliced array.

	Slices an array.

	```lua
	local array = { 1, 2, 3, 4, 5 }

	local new = Slice(array, 2, 3) -- { 2, 3 }
	local new = Slice(array, -2, -1) -- { 3, 4 }
	local new = Slice(array, 3) -- { 3, 4, 5 }
	```
]=]
local function slice<T>(array: { T }, from: number?, to: number?): { T }
	local length = #array
	local result = {}

	from = if type(from) == "number" then from else 1
	to = if type(to) == "number" then to else length

	if from < 1 then
		from += length
	end

	if to < 1 then
		to += length
	end

	for i = from, to do
		table.insert(result, array[i])
	end

	return result
end

return slice
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="473">
                <Properties>
                  <string name="Name">some</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezIwRDE5QzZFLUI1N0QtNDA4QS1CNkEyLTRBMkI2QTA2RDlGQ30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function some
	@within Array

	@param array {T} -- The array to check.
	@param predicate (value: T, index: number, array: {T}) -> any -- The predicate to use to check the array.
	@return boolean -- Whether some item in the array passes the predicate.

	Checks whether some item in the array passes the predicate.

	```lua
	local array = { 1, 2, 3 }

	local value = Some(array, function(item, index)
		return item > 1
	end) -- true

	local value = Some(array, function(item, index)
		return item > 3
	end) -- false
	```
]=]
local function some<T>(array: { T }, predicate: (value: T, index: number, array: { T }) -> any): boolean
	for index, value in ipairs(array) do
		if predicate(value, index, array) then
			return true
		end
	end

	return false
end

return some
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="474">
                <Properties>
                  <string name="Name">sort</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0U4NEY2QTZBLTZBMzAtNDJFOC1BMzJDLTgzOTM5Qjk5Q0QwM30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Copy = require(script.Parent.copy)

--[=[
	@function sort
	@within Array

	@param array {T} -- The array to sort.
	@param comparator? (a: T, b: T) -> boolean -- The comparator function.
	@return {T} -- The sorted array.

	Sorts an array.

	```lua
	local array = { "a", "b", "c", "d", "e" }

	local new = Sort(array, function(a, b)
		return a > b
	end) -- { "e", "d", "c", "b", "a" }
	```
]=]
local function sort<T>(array: { T }, comparator: ((firstValue: T, secondValue: T) -> boolean)?): { T }
	local result = Copy(array)

	table.sort(result, comparator)

	return result
end

return sort
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="475">
                <Properties>
                  <string name="Name">splice</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezUwMUM4NEJELTdGRUQtNDkzOC1BQ0ZBLTVEOTc2QTk1Qzg5M30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function splice
	@within Array

	@param array {T} -- The array to splice.
	@param start? number -- The index to start splicing at (can be negative).
	@param end? number -- The index to end splicing at (can be negative).
	@param ... ...T -- The values to insert.
	@return {T} -- The spliced array.

	Splices an array.

	```lua
	local array = { 1, 2, 3, 4, 5 }

	local new = Splice(array, 3, 4, 6, 7) -- { 1, 2, 6, 7, 4, 5 }
	local new = Splice(array, -1, 0, 6, 7) -- { 1, 2, 3, 4, 6, 7 }
	local new = Splice(array, 4, -1, 6, 7) -- { 1, 2, 3, 6, 7, 5 }
	```
]=]
local function splice<T>(array: { T }, from: number?, to: number?, ...: T?): { T }
	local length = #array
	local result = {}

	from = if type(from) == "number" then from else 1
	to = if type(to) == "number" then to else length

	if from < 1 then
		from += length
	end

	if to < 1 then
		to += length
	end

	for index = 1, from - 1 do
		table.insert(result, array[index])
	end

	for _, value in ipairs({ ... }) do
		table.insert(result, value)
	end

	for index = to + 1, length do
		table.insert(result, array[index])
	end

	return result
end

return splice
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="476">
                <Properties>
                  <string name="Name">toSet</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0U2MTI4QzA1LTczOUQtNEYxMy04MEM4LTZGNkVFMjczRTk4MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent
local _T = require(Sift.Types)

--[=[
	@function toSet
	@within Array

	@param array {T} -- The array to convert to a set.
	@return Set<T> -- The set.

	Converts an array to a set.

	```lua
	local array = { "a", "b", "b", "c", "d" }

	local set = ToSet(array) -- { a = true, b = true, c = true, d = true }
	```
]=]
local function toSet<T>(array: { T }): _T.Set<T>
	local set = {}

	for _, value in ipairs(array) do
		set[value] = true
	end

	return set
end

return toSet
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="477">
                <Properties>
                  <string name="Name">unshift</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezM4NzczMDA5LTNDQkMtNDZGNC1CMkRCLTIyMEQyQjgzMDEzMn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@function unshift
	@within Array

	@param array {T} -- The array to insert the values to.
	@param ... ...T -- The values to insert.
	@return {T} -- The array with the values inserted.

	Inserts values to the beginning of an array.

	#### Aliases

	`prepend`

	```lua
	local array = { 1, 2, 3 }

	local new = Unshift(array, 4, 5) -- { 4, 5, 1, 2, 3 }
	```
]=]
local function unshift<T>(array: { T }, ...: T): { T }
	local result = { ... }

	for _, value in ipairs(array) do
		table.insert(result, value)
	end

	return result
end

return unshift
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="478">
                <Properties>
                  <string name="Name">update</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezUyQTJFRDIwLTI2ODItNDIyRi05M0E3LUQwQTI2NzRDNDRCNH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)
local Copy = require(script.Parent.copy)

type Callback<T> = (index: number) -> T
type Updater<T> = (currentValue: T, index: number) -> T

local function call<T>(callback: Callback<T>, index: number)
	if type(callback) == "function" then
		return callback(index)
	end
end

--[=[
	@function update
	@within Array

	@param array {T} -- The array to update.
	@param index {number} -- The index to update.
	@param updater? (value: T, index: number) -> T -- The updater function.
	@param callback? (index: number) -> T -- The callback function.
	@return {T} -- The updated array.

	Updates an array at the given index. If the value at the given index does
	not exist, `callback` will be called, and its return value will be used
	as the value at the given index.

	```lua
	local array = { 1, 2, 3 }

	local new = Update(array, 2, function(value)
		return value + 1
	end) -- { 2, 3, 3 }

	local new = Update(array, 4, function(value)
		return value + 1
	end, function(value)
		return 10
	end) -- { 1, 2, 3, 10 }
	```
]=]
local function update<T>(array: { T }, index: number, updater: Updater<T>?, callback: Callback<T>?): { T }
	local length = #array
	local result = Copy(array)

	if index < 1 then
		index += length
	end

	updater = if type(updater) == "function" then updater else Util.func.returned

	if result[index] ~= nil then
		result[index] = updater(result[index], index)
	else
		result[index] = call(callback, index)
	end

	return result
end

return update
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="479">
                <Properties>
                  <string name="Name">zip</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezYzMzBCMUMxLUM5ODUtNDEzMi04OTAxLUZGRUM2MTc3QzY2Rn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Reduce = require(script.Parent.reduce)

--[=[
	@function zip
	@within Array

	@param ... {any} -- The arrays to zip together.
	@return {any} -- The zipped array.

	Zips multiple arrays together into a single array.

	```lua
	local table1 = { 1, 2, 3 }
	local table2 = { "hello", "world", "goodbye" }

	local new = Zip(table1, table2) -- { { 1, "hello" }, { 2, "world" }, { 3, "goodbye" } }
	```
]=]
local function zip<T>(...: { any }): T
	local argCount = select("#", ...)
	local arguments = { ... }

	local result = {}

	if argCount == 0 then
		return result
	end

	local minLength: number = Reduce(arguments, function(acc, val)
		return math.min(acc, #val)
	end, #arguments[1])

	for index = 1, minLength do
		local values = {}

		for _, argArray in ipairs(arguments) do
			table.insert(values, argArray[index])
		end

		table.insert(result, values)
	end

	return result
end

return zip
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="480">
                <Properties>
                  <string name="Name">zipAll</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezJFRjQyQzY4LTQ4OUMtNDkzMC05QzY4LTQ2NTEwQ0M5QzZBMH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Reduce = require(script.Parent.reduce)
local None = require(Sift.None)

--[=[
	@function zipAll
	@within Array

	@param ... ...{any} -- The arrays to zip.
	@return {any} -- The zipped array.

	Zips multiple arrays together into a single array, filling
	in missing values with `None`.

	```lua
	local table1 = { 1, 2, 3, 4 }
	local table2 = { "hello", "world", "goodbye" }

	local new = ZipAll(table1, table2) -- { { 1, "hello" }, { 2, "world" }, { 3, "goodbye" }, { 4, None } }
	```
]=]
local function zipAll<T>(...: { any }): T
	local argCount = select("#", ...)
	local arguments = { ... }
	local result = {}

	if argCount == 0 then
		return result
	end

	local maxLength = Reduce(arguments, function(acc, val)
		return math.max(acc, #val)
	end, #arguments[1])

	for index = 1, maxLength do
		local values = {}

		for _, argArray in ipairs(arguments) do
			local value = argArray[index]
			table.insert(values, if value == nil then None else value)
		end

		table.insert(result, values)
	end

	return result
end

return zipAll
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="481">
              <Properties>
                <string name="Name">Dictionary</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezgyQUZDMjg3LTExMEQtNDRCNy1CQjUwLTg2OUYxMDc4MkFCRH0=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict
--[=[
	@class Dictionary

	Dictionaries are a type of data structure that can be used to store key-value pairs.

	```lua
	local dictionary = {
		cats = 2,
		dogs = 1
	}

	print(dictionary.cats) -- 2
	```
]=]
local Dictionary = {
	copy = require(script.copy),
	copyDeep = require(script.copyDeep),
	count = require(script.count),
	entries = require(script.entries),
	equals = require(script.equals),
	equalsDeep = require(script.equalsDeep),
	every = require(script.every),
	filter = require(script.filter),
	flatten = require(script.flatten),
	flip = require(script.flip),
	freeze = require(script.freeze),
	freezeDeep = require(script.freezeDeep),
	fromArrays = require(script.fromArrays),
	fromEntries = require(script.fromEntries),
	has = require(script.has),
	includes = require(script.includes),
	keys = require(script.keys),
	map = require(script.map),
	merge = require(script.merge),
	mergeDeep = require(script.mergeDeep),
	removeKey = require(script.removeKey),
	removeKeys = require(script.removeKeys),
	removeValue = require(script.removeValue),
	removeValues = require(script.removeValues),
	set = require(script.set),
	some = require(script.some),
	update = require(script.update),
	values = require(script.values),
}

Dictionary.join = Dictionary.merge
Dictionary.joinDeep = Dictionary.mergeDeep

return Dictionary
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="482">
                <Properties>
                  <string name="Name">copy</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezA0MTQyQzVELTk4MkItNDUwNy1BOEI5LTMyNjhCODA5NTQ2Q30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function copy
  @within Dictionary

  @param dictionary T -- The dictionary to copy.
  @return T -- The copied dictionary.

  Copies a dictionary.

  ```lua
  local dictionary = { hello = "world" }

  local new = Copy(dictionary) -- { hello = "world" }

  print(new == dictionary) -- false
  print(new.hello == dictionary.hello) -- true
  ```
]=]
return table.clone
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="483">
                <Properties>
                  <string name="Name">copyDeep</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0NCNEUxOTk3LTM0MjItNDFGQS1BMkU0LTVCMkFFQ0M3OUJDQX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function copyDeep
  @within Dictionary

  @param dictionary T -- The dictionary to copy.
  @return T -- The copied dictionary.

  Copies a dictionary recursively.

  ```lua
  local dictionary = { hello = { world = "goodbye" } }

  local new = CopyDeep(dictionary) -- { hello = { world = "goodbye" } }

  print(new == dictionary) -- false
  print(new.hello == dictionary.hello) -- false
  ```
]=]
local function copyDeep<T>(dictionary: T): T
	local new = {}

	for key, value in pairs(dictionary) do
		if type(value) == "table" then
			new[key] = copyDeep(value)
		else
			new[key] = value
		end
	end

	return new
end

return copyDeep
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="484">
                <Properties>
                  <string name="Name">count</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0JEQ0RBQjQ1LTRGREUtNEI4Qy1CMzA4LTkzNjhFOENGQ0Q1Rn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)

--[=[
  @function count
  @within Dictionary

  @param dictionary T -- The dictionary to count.
  @param predicate? (value: T, key: K, dictionary: T) -> any -- The predicate to use to filter the dictionary.
  @return number -- The number of items in the dictionary.

  Counts the number of items in a dictionary.

  ```lua
  local dictionary = { hello = "world", goodbye = "world" }

  local value = Count(dictionary) -- 2
  local value = Count(dictionary, function(item, key)
    return item == "world"
  end) -- 1
  ```
]=]
local function count<K, V>(
	dictionary: { [K]: V },
	predicate: ((value: V, key: K, dictionary: { [K]: V }) -> any)?
): number
	local counter = 0

	predicate = if type(predicate) == "function" then predicate else Util.func.truthy

	for key, value in pairs(dictionary) do
		if predicate(value, key, dictionary) then
			counter += 1
		end
	end

	return counter
end

return count
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="485">
                <Properties>
                  <string name="Name">entries</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezJGOUY2NDM1LTNDMTEtNEUyQS1CRDlDLUZDQjE3N0E2NUY0Mn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function entries
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to get the entries from.
  @return {{ K, V }} -- The entries in the dictionary.

  Returns the entries in the given dictionary as an array of key-value pairs.

  ```lua
  local dictionary = { hello = "roblox", goodbye = "world" }

  local entries = Entries(dictionary) -- { { "hello", "roblox" }, { "goodbye", "world" } }
  ```
]=]
local function entries<K, V>(dictionary: { [K]: V }): { [number]: { [number]: K | V } }
	local result = {}

	for key, value in pairs(dictionary) do
		table.insert(result, { key, value })
	end

	return result
end

return entries
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="486">
                <Properties>
                  <string name="Name">equals</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezAyNDczQzhELUE1MUItNDVFRC1CNTk3LTNCOUY5QjFBQjE5OX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)
local _T = require(Sift.Types)

local function compare(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return a == b
	end

	for key, value in pairs(a) do
		if b[key] ~= value then
			return false
		end
	end

	for key, value in pairs(b) do
		if a[key] ~= value then
			return false
		end
	end

	return true
end

--[=[
  @function equals
  @within Dictionary

  @param ... ...{ [any]: any } -- The dictionaries to compare.
  @return boolean -- Whether the dictionaries are equal.

  Compares two dictionaries for equality.

  ```lua
  local dictionary = { hello = "world", goodbye = "world" }
  local other1 = { hello = "world", goodbye = "world" }
  local other2 = { hello = "hello", world = "goodbye" }

  local value = Equals(dictionary, other1) -- true
  local value = Equals(dictionary, other1, other2) -- false
  ```
]=]
local function equals(...: _T.AnyDictionary): boolean
	if Util.equalObjects(...) then
		return true
	end

	local totalArgs = select("#", ...)
	local firstItem = select(1, ...)

	for i = 2, totalArgs do
		local item = select(i, ...)

		if not compare(firstItem, item) then
			return false
		end
	end

	return true
end

return equals
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="487">
                <Properties>
                  <string name="Name">equalsDeep</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0U0RUIwNDkwLTNCM0MtNEZGQy1BOTJDLUQ0REUxNzFCNTAzOH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)
local _T = require(Sift.Types)

local function compareDeep(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return a == b
	end

	for key, value in pairs(a) do
		if not compareDeep(value, b[key]) then
			return false
		end
	end

	for key, value in pairs(b) do
		if not compareDeep(value, a[key]) then
			return false
		end
	end

	return true
end

--[=[
  @function equalsDeep
  @within Dictionary

  @param ... ...{ [any]: any } -- The dictionaries to compare.
  @return boolean -- Whether the dictionaries are equal.

  Compares two dictionaries for equality using deep comparison.

  ```lua
  local dictionary = { hello = "world", goodbye = { world = "hello" } }
  local other1 = { hello = "world", goodbye = { world = "hello" } }
  local other2 = { hello = "hello", world = "goodbye" }

  local value = EqualsDeep(dictionary, other1) -- true
  local value = EqualsDeep(dictionary, other1, other2) -- false
  ```
]=]
local function equalsDeep(...: _T.AnyDictionary): boolean
	if Util.equalObjects(...) then
		return true
	end

	local totalArgs = select("#", ...)
	local firstItem = select(1, ...)

	for i = 2, totalArgs do
		local item = select(i, ...)

		if not compareDeep(firstItem, item) then
			return false
		end
	end

	return true
end

return equalsDeep
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="488">
                <Properties>
                  <string name="Name">every</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezlBOUEwNTg4LTFBN0UtNEUwRi1BNUU5LTAwRjg4RUZFRTIzQ30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function every
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to check.
  @param predicate (value: V, key: K, dictionary: {[K]: V}) -> any -- The predicate to use to check the dictionary.
  @return boolean -- Whether every item in the dictionary passes the predicate.

  Checks whether every item in the dictionary passes the predicate.

  ```lua
  local dictionary = { hello = "world", goodbye = "world" }

  local value = Every(dictionary, function(value, key)
    return value == "world"
  end) -- true

  local value = Every(dictionary, function(value, key)
    return value == "hello"
  end) -- false
  ```
]=]
local function every<K, V>(
	dictionary: { [K]: V },
	predicate: (value: V, key: K, dictionary: { [K]: V }) -> any
): boolean
	for key, value in pairs(dictionary) do
		if not predicate(value, key, dictionary) then
			return false
		end
	end

	return true
end

return every
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="489">
                <Properties>
                  <string name="Name">filter</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0RGODdFREVBLTcxQTgtNEYxQS05MDgzLUNCRDgzMjE3MEE0MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)

--[=[
  @function filter
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to filter.
  @param predicate? (value: V, key: K, dictionary: {[K]: V}) -> any -- The predicate to use to filter the dictionary.
  @return {[K]: V} -- The filtered dictionary.

  Filters a dictionary using a predicate. Any items that do not pass the predicate will be removed from the dictionary.

  ```lua
  local dictionary = { hello = "world", goodbye = "goodbye" }

  local result = Filter(dictionary, function(value, key)
    return value == "world"
  end) -- { hello = "world" }
  ```
]=]
local function filter<K, V>(
	dictionary: { [K]: V },
	predicate: ((value: V, key: K, dictionary: { [K]: V }) -> any)?
): { [K]: V }
	local result = {}

	predicate = if type(predicate) == "function" then predicate else Util.func.truthy

	for key, value in pairs(dictionary) do
		if predicate(value, key, dictionary) then
			result[key] = value
		end
	end

	return result
end

return filter
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="490">
                <Properties>
                  <string name="Name">flatten</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezI5RTJCMkM3LTQyMDItNDE4My04MDdELUM2RkU1M0FDN0ZDMn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local _T = require(script.Parent.Parent.Types)

--[=[
  @function flatten
  @within Dictionary

  @param dictionary T -- The dictionary to flatten.
  @param depth? number -- The depth to flatten the dictionary to.
  @return T -- The flattened dictionary.

  Flattens a dictionary. If depth is not specified, it will flatten the dictionary as far as it can go.

  ```lua
  local dictionary = {
    hello = "world",
    goodbye = {
      world = "hello",
      roblox = {
        yes = "no",
        no = "yes",
      }
    }
  }

  local new = Flatten(dictionary) -- { hello = "world", world = "hello", yes = "no", no = "yes" }
  local new = Flatten(dictionary, 1) -- { hello = "world", world = "hello", roblox = { yes = "no", no = "yes" } }
  ```
]=]
local function flatten(dictionary: _T.AnyDictionary, depth: number?): _T.AnyDictionary
	depth = if type(depth) == "number" then depth else math.huge

	local result = {}

	for key, value in pairs(dictionary :: _T.AnyDictionary) do
		if type(value) == "table" and depth > 0 then
			local nested = flatten(value, depth - 1)

			for resultKey, resultValue in pairs(result) do
				nested[resultKey] = resultValue
			end

			result = nested
		else
			result[key] = value
		end
	end

	return result
end

return flatten
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="491">
                <Properties>
                  <string name="Name">flip</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezcyRTg2RkVELUFEOUMtNDc0OC04NTFBLTg5ODA4NzdFOTU3OH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function flip
  @within Dictionary

  @param dictionary { [K]: V } -- The dictionary to flip.
  @return { [V]: K } -- The flipped dictionary.

  Flips a dictionary. Keys become values and values become keys.

  ```lua
  local dictionary = { hello = "roblox", goodbye = "world" }

  local new = Flip(dictionary) -- { world = "goodbye", roblox = "hello" }
  ```
]=]
local function flip<K, V>(dictionary: { [K]: V }): { [V]: K }
	local result = {}

	for key, value in pairs(dictionary) do
		result[value] = key
	end

	return result
end

return flip
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="492">
                <Properties>
                  <string name="Name">freeze</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezk4RUI3NzI2LTkyOEMtNDAyNS1BQTdELUJCREZDODAyRTRBNX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local _T = require(script.Parent.Parent.Types)
local Copy = require(script.Parent.copy)

--[=[
  @function freeze
  @within Dictionary

  @param dictionary T -- The dictionary to freeze.
  @return T -- The frozen dictionary.

  Freezes the given dictionary at the top level, making it read-only.

  ```lua
  local dictionary = { hello = "roblox", goodbye = { world = "world" } }

  local new = Freeze(dictionary)

  new.hello = "world" -- error!
  new.goodbye.world = "hello" -- still works!
  ```
]=]
local function freeze(dictionary: _T.AnyDictionary): _T.AnyDictionary
	local new = Copy(dictionary)

	table.freeze(new)

	return new
end

return freeze
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="493">
                <Properties>
                  <string name="Name">freezeDeep</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezQwOEE5Q0MxLUVCMUItNEY5OS1BQTg5LUFDMUM4REJERDA4MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local _T = require(script.Parent.Parent.Types)

--[=[
  @function freezeDeep
  @within Dictionary

  @param dictionary T -- The dictionary to freeze.
  @return T -- The frozen dictionary.

  Freezes the entire dictionary, making it read-only, including all nested dictionaries.

  ```lua
  local dictionary = { hello = "roblox", goodbye = { world = "world" } }

  local new = FreezeDeep(dictionary)

  new.hello = "world" -- error!
  new.goodbye.world = "hello" -- error!
  ```
]=]
local function freezeDeep(dictionary: _T.AnyDictionary): _T.AnyDictionary
	local result = {}

	for key, value in pairs(dictionary) do
		if type(value) == "table" then
			result[key] = freezeDeep(value)
		else
			result[key] = value
		end
	end

	table.freeze(result)

	return result
end

return freezeDeep
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="494">
                <Properties>
                  <string name="Name">fromArrays</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezdCQUI0NDMzLTYxNUMtNDBGQy1CMUYwLUM3RTQyQTM5MjhFM30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function fromArrays
  @within Dictionary

  @param keys {K} -- An array containing values to be used as keys.
  @param values {V} -- An array containing values to be used as values.
  @return {[K]: V} -- A dictionary composed of the given keys and values.

  Creates a dictionary from the given arrays, where the first array is used
  as keys and the second array is used as values.

  ```lua
  local keys = { "hello", "goodbye" }
  local values = { "roblox", "world" }

  local dictionary = FromArrays(keys, values) -- { hello = "roblox", goodbye = "world" }
  ```
]=]
local function fromArrays<K, V>(keys: { K }, values: { V }): { [K]: V }
	local keysLength = #keys
	local result = {}

	for i = 1, keysLength do
		result[keys[i]] = values[i]
	end

	return result
end

return fromArrays
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="495">
                <Properties>
                  <string name="Name">fromEntries</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0I4RTUwN0JGLURBRUYtNEI4MS05QzY3LTMxRUUwNUJERDE2Rn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function fromEntries
  @within Dictionary

  @param entries {{ K, V }} -- An array of key-value pairs.
  @return {[K]: V} -- A dictionary composed of the given key-value pairs.

  Creates a dictionary from the given key-value pairs.

  ```lua
  local entries = { { "hello", "roblox" }, { "goodbye", "world" } }

  local dictionary = FromEntries(entries) -- { hello = "roblox", goodbye = "world" }
  ```
]=]
local function fromEntries<K, V>(entries: { [number]: { [number]: K | V } }): { [K]: V }
	local result = {}

	for _, entry in ipairs(entries) do
		result[entry[1]] = entry[2]
	end

	return result
end

return fromEntries
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="496">
                <Properties>
                  <string name="Name">has</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezRDREI2NDlFLTAwMkMtNDg0QS1COTgxLUQ2MTY0M0JFRDNFOX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local _T = require(script.Parent.Parent.Types)

--[=[
  @function has
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to check.
  @param key any -- The key to check for.
  @return boolean -- Whether or not the dictionary has the given key.

  Checks whether or not the given dictionary has the given key.

  ```lua
  local dictionary = { hello = "roblox", goodbye = "world" }

  local hasHello = Has(dictionary, "hello") -- true
  local hasCat = Has(dictionary, "cat") -- false
  ```
]=]
local function has(dictionary: _T.AnyDictionary, key: any): boolean
	return dictionary[key] ~= nil
end

return has
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="497">
                <Properties>
                  <string name="Name">includes</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0VEODhDOEZCLTA5M0UtNEMzRS05RkFELTdDN0Q5RTM1ODZDMX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function includes
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to check.
  @param value V -- The value to check for.
  @return boolean -- Whether or not the dictionary includes the given value.

  Checks whether or not the given dictionary includes the given value.

  ```lua
  local dictionary = { hello = "roblox", goodbye = "world" }

  local includesRoblox = Includes(dictionary, "roblox") -- true
  local includesCat = Includes(dictionary, "cat") -- false
  ```
]=]
local function includes<K, V>(dictionary: { [K]: V }, value: V): boolean
	for _, v in pairs(dictionary) do
		if v == value then
			return true
		end
	end

	return false
end

return includes
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="498">
                <Properties>
                  <string name="Name">keys</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezM4QTc0NDQzLTFCN0MtNDJDOC05RDYwLTk0OUQ0Nzc3MzFBOX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function keys
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to get the keys of.
  @return {K} -- An array containing the keys of the given dictionary.

  Gets the keys of the given dictionary as an array.

  ```lua
  local dictionary = { hello = "roblox", goodbye = "world" }

  local keys = Keys(dictionary) -- { "hello", "goodbye" }
  ```
]=]
local function keys<K, V>(dictionary: { [K]: V }): { K }
	local result = {}

	for key in pairs(dictionary) do
		table.insert(result, key)
	end

	return result
end

return keys
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="499">
                <Properties>
                  <string name="Name">map</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezJFRUZGRjM1LTAzRjItNDI0Qy1CNDBELUIwMTk2MUYwQjhDNH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function map
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to map.
  @param mapper (value: V, key: K, dictionary: {[K]: V}) -> (Y?, X?) -- The mapper function.
  @return {[X]: Y} -- The mapped dictionary.

  Maps the dictionary using the mapper function. The mapper function can
  return a value and a key. If the mapper function does not return a key,
  the original key will be used.

  ```lua
  local dictionary = { hello = 10, goodbye = 20 }

  local new = Map(dictionary, function(value, key)
    return value * 2, key .. "!"
  end) -- { ["hello!"] = 20, ["goodbye!"] = 40 }

  local new = Map(dictionary, function(value, key)
    return value * 10
  end) -- { hello = 100, goodbye = 200 }
  ```
]=]
local function map<K, V, X, Y>(
	dictionary: { [K]: V },
	mapper: (value: V, key: K, dictionary: { [K]: V }) -> (Y?, X?)
): { [X]: Y }
	local mapped = {}

	for key, value in pairs(dictionary) do
		local mappedValue, mappedKey = mapper(value, key, dictionary)
		mapped[mappedKey or key] = mappedValue
	end

	return mapped
end

return map
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="500">
                <Properties>
                  <string name="Name">merge</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0MxRDhGQjlGLTQzQjItNEE4Mi1BRDE2LUQxRUY3RUUwMTE0MX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local None = require(Sift.None)

--[=[
  @function merge
  @within Dictionary

  @param dictionaries? ...any -- The dictionaries to merge.
  @return T -- The merged dictionary.

  Merges the given dictionaries into a single dictionary. If the
  value is `None`, it will be removed from the result. The
  parameters may be any number of dictionaries or `nil`.
  Non-dictonaries will be ignored.

  Aliases: `join`

  ```lua
  local dictionary1 = { hello = "roblox", goodbye = "world" }
  local dictionary2 = { goodbye = "goodbye" }

  local merged = Merge(dictionary1, dictionary2) -- { hello = "roblox", goodbye = "goodbye" }
  ```
]=]
local function merge<T>(...: any): T
	local result = {}

	for dictionaryIndex = 1, select("#", ...) do
		local dictionary = select(dictionaryIndex, ...)

		if type(dictionary) ~= "table" then
			continue
		end

		for key, value in pairs(dictionary) do
			result[key] = if value == None then nil else value
		end
	end

	return result
end

return merge
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="501">
                <Properties>
                  <string name="Name">mergeDeep</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezI5RjNBMkQ0LTg2NzctNEU4QS04QkJDLTRDODhDRjBFQzVCQn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local None = require(Sift.None)
local copyDeep = require(script.Parent.copyDeep)

--[=[
	@function mergeDeep
	@within Dictionary

	@param dictionaries? ...any -- The dictionaries to merge.
	@return T -- The merged dictionary.

	Merges the given dictionaries into a single dictionary. If the
	value is `None`, it will be removed from the result. This is
	recursive. The parameters may be any number of dictionaries or
	`nil`. Non-dictonaries will be ignored.

	Aliases: `joinDeep`

	```lua
	local dictionary1 = { hello = "roblox", goodbye = { world = "goodbye" } }
	local dictionary2 = { goodbye = { world = "world" } }

	local merged = MergeDeep(dictionary1, dictionary2) -- { hello = "roblox", goodbye = { world = "world" } }
	```
]=]
local function mergeDeep<T>(...: any): T
	local result = {}

	for dictionaryIndex = 1, select("#", ...) do
		local dictionary = select(dictionaryIndex, ...)

		if type(dictionary) ~= "table" then
			continue
		end

		for key, value in pairs(dictionary) do
			if value == None then
				result[key] = nil
			elseif type(value) == "table" then
				if result[key] == nil or type(result[key]) ~= "table" then
					result[key] = copyDeep(value)
				else
					result[key] = mergeDeep(result[key], value)
				end
			else
				result[key] = value
			end
		end
	end

	return result
end

return mergeDeep
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="502">
                <Properties>
                  <string name="Name">removeKey</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0I0NDk2MDhGLUQ1QUItNDVEOC1CMTQyLUY2MjJDREQ5OThEM30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local copy = require(script.Parent.copy)

--[=[
  @function removeKey
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to remove the key from.
  @param key K -- The key to remove.
  @return {[K]: V} -- The dictionary without the given key.

  Removes the given key from the given dictionary.

  ```lua
  local dictionary = { hello = "roblox", goodbye = "world" }

  local withoutHello = RemoveKey(dictionary, "hello") -- { goodbye = "world" }
  local withoutGoodbye = RemoveKey(dictionary, "goodbye") -- { hello = "roblox" }
  ```
]=]
local function removeKey<K, V>(dictionary: { [K]: V }, key: K): { [K]: V }
	local result = copy(dictionary)

	result[key] = nil

	return result
end

return removeKey
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="503">
                <Properties>
                  <string name="Name">removeKeys</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezFBNEE5ODJGLTU4NEMtNDIxNS04MjgzLTk4NzNDNDZGREFBM30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local copy = require(script.Parent.copy)

--[=[
  @function removeKeys
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to remove the keys from.
  @param keys ...K -- The keys to remove.
  @return {[K]: V} -- The dictionary without the given keys.

  Removes the given keys from the given dictionary.

  ```lua
  local dictionary = { hello = "world", cat = "meow", dog = "woof", unicorn = "rainbow" }

  local withoutCatDog = RemoveKeys(dictionary, "cat", "dog") -- { hello = "world", unicorn = "rainbow" }
  ```
]=]
local function removeKeys<K, V>(dictionary: { [K]: V }, ...: K): { [K]: V }
	local result = copy(dictionary)

	for _, key in ipairs({ ... }) do
		result[key] = nil
	end

	return result
end

return removeKeys
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="504">
                <Properties>
                  <string name="Name">removeValue</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezcwQ0UzM0Y0LUJERUMtNDM4MS04ODY5LUM5Q0U5QjlDODc5MX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function removeValue
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to remove the value from.
  @param value V -- The value to remove.
  @return {[K]: V} -- The dictionary without the given value.

  Removes the given value from the given dictionary.

  ```lua
  local dictionary = { hello = "roblox", goodbye = "world" }

  local withoutHello = RemoveValue(dictionary, "roblox") -- { goodbye = "world" }
  local withoutGoodbye = RemoveValue(dictionary, "world") -- { hello = "roblox" }
  ```
]=]
local function removeValue<K, V>(dictionary: { [K]: V }, value: V): { [K]: V }
	local result = {}

	for key, v in pairs(dictionary) do
		if v ~= value then
			result[key] = v
		end
	end

	return result
end

return removeValue
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="505">
                <Properties>
                  <string name="Name">removeValues</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezJCNTdDMEU1LThGNTMtNDJBQS05RkZELTFEMjA3QzA1RTU2RH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local ToSet = require(Sift.Array.toSet)

--[=[
  @function removeValues
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to remove the values from.
  @param values ...V -- The values to remove.
  @return {[K]: V} -- The dictionary without the given values.

  Removes the given values from the given dictionary.

  ```lua
  local dictionary = { hello = "world", cat = "meow", unicorn = "rainbow", goodbye = "world" }

  local withoutWorld = RemoveValues(dictionary, "world") -- { cat = "meow", unicorn = "rainbow" }
  local onlyWorld = RemoveValues(dictionary, "meow", "rainbow") -- { hello = "world", goodbye = "world" }
  ```
]=]
local function removeValues<K, V>(dictionary: { [K]: V }, ...: V): { [K]: V }
	local values = ToSet({ ... })
	local result = {}

	for key, value in pairs(dictionary) do
		if not values[value] then
			result[key] = value
		end
	end

	return result
end

return removeValues
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="506">
                <Properties>
                  <string name="Name">set</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezhBMEY5MkZDLTI0RkItNEVGMS1BNUNDLTJBMEMxRTY2MDQzNX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local copy = require(script.Parent.copy)

--[=[
  @function set
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to set the value in.
  @param key K -- The key to set the value in.
  @param value V -- The value to set.
  @return {[K]: V} -- The dictionary with the given value set.

  Sets the given value in the given dictionary.

  ```lua
  local dictionary = { hello = "world", cat = "meow", unicorn = "rainbow" }

  local setCat = Set(dictionary, "cat", "woof") -- { hello = "world", cat = "woof", unicorn = "rainbow" }
  ```
]=]
local function set<K, V>(dictionary: { [K]: V }, key: K, value: V): { [K]: V }
	local result = copy(dictionary)

	result[key] = value

	return result
end

return set
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="507">
                <Properties>
                  <string name="Name">some</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezAyNzAwMEJBLUIyRjMtNDcxQi05N0VELThDNDEzNTIxMzBFNH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function some
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to check.
  @param predicate (value: V, key: K, dictionary: { [K]: V }) -> any -- The predicate to check against.
  @return boolean -- Whether or not the predicate returned true for any value.

  Checks whether or not the predicate returned true for any value in the dictionary.

  ```lua
  local dictionary = { hello = "world", cat = "meow", unicorn = "rainbow" }

  local hasMeow = Some(dictionary, function(value)
    return value == "meow"
  end) -- true

  local hasDog = Some(dictionary, function(_, key)
    return key == "dog"
  end) -- false
  ```
]=]
local function some<K, V>(dictionary: { [K]: V }, predicate: (value: V, key: V, dictionary: { [K]: V }) -> any): boolean
	for key, value in pairs(dictionary) do
		if predicate(value, key, dictionary) then
			return true
		end
	end

	return false
end

return some
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="508">
                <Properties>
                  <string name="Name">update</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezI1NEFDRTY3LTFCMEUtNDNFQy1COTMwLTEwREIxN0Y5ODQ0MH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)
local copy = require(script.Parent.copy)

type Callback<K, V> = (key: K) -> V
type Updater<K, V> = (value: V, key: K) -> V

local function call<K, V>(callback: Callback<K, V>, key: K)
	if type(callback) == "function" then
		return callback(key)
	end
end

--[=[
  @function update
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to update.
  @param key K -- The key to update.
  @param updater? (value: V, key: K) -> U -- The updater function.
  @param callback? (key: K) -> C -- The callback function.
  @return {[K]: V & U & C } -- The updated dictionary.

  Updates a value in a dictionary at the given key. If the value at the given key does not exist, `callback` will be called, and its return value will be used as the value at the given key.

  ```lua
  local dictionary = { cats = 2 }

  local new = Update(dictionary, "cats", function(value)
    return value + 1
  end) -- { cats = 3 }

  local new = Update(dictionary, "dogs", function(value)
    return value + 1
  end, function(value)
    return 1
  end) -- { cats = 3, dogs = 1 }
  ```
]=]
local function update<K, V, U, C>(
	dictionary: { [K]: V },
	key: K,
	updater: ((value: V, key: K) -> U)?,
	callback: ((key: K) -> C)?
): { [K]: V & U & C }
	local result = copy(dictionary)

	updater = if type(updater) == "function" then updater else Util.func.returned

	callback = if type(callback) == "function" then callback else Util.func.returned

	if result[key] ~= nil then
		result[key] = updater(result[key], key)
	else
		result[key] = call(callback, key)
	end

	return result
end

return update
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="509">
                <Properties>
                  <string name="Name">values</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0I4QTJGQTg4LTIzRTAtNDQzNi1CMkFGLUFGNUZGNDJGMkI2RX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function values
  @within Dictionary

  @param dictionary {[K]: V} -- The dictionary to get the values from.
  @return {V} -- The values in the dictionary.

  Gets the values in the given dictionary.

  ```lua
  local dictionary = { hello = "roblox", goodbye = "world" }

  local values = Values(dictionary) -- { "roblox", "world" }
  ```
]=]
local function values<K, V>(dictionary: { [K]: V }): { V }
	local result = {}

	for _, value in pairs(dictionary) do
		table.insert(result, value)
	end

	return result
end

return values
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="510">
              <Properties>
                <string name="Name">None</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0I1MkNFRTUxLUMyQjAtNDk1Qi05NzhBLTlBNTNDREM5OTZGOX0=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict
--[=[
	@prop None None
	@within Sift

	Luau can't distinguish between a nil value and a non-existent value. This
	constant is used to represent a non-existent value. It can be used in methods
	like `Array.Concat` or `Dictionary.Merge` to remove the value from the result.
]=]
local None = newproxy(true)

getmetatable(None :: any).__tostring = function()
	return "Sift.None"
end

return None
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="511">
              <Properties>
                <string name="Name">Set</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0Q1QjA5QjM3LTUxRUUtNDU4OC1CQjNELUVDQkU4QkVEMTcyNH0=]]></BinaryString>
                <string name="Source"><![CDATA[--!strict
--[=[
	@class Set

	Sets are a collection of values. They are used to store unique values.
	They are essentially a dictionary, but each value is stored as a boolean.
	This means that a value can only be in a set once.

	```lua
	local set = { hello = true }

	local newSet = Add(set, "world") -- { hello = true, world = true }
	```
]=]
local set = {
	add = require(script.add),
	copy = require(script.copy),
	count = require(script.count),
	delete = require(script.delete),
	filter = require(script.filter),
	fromArray = require(script.fromArray),
	has = require(script.has),
	intersection = require(script.intersection),
	isSubset = require(script.isSubset),
	isSuperset = require(script.isSuperset),
	map = require(script.map),
	merge = require(script.merge),
	toArray = require(script.toArray),
}

set.fromList = set.fromArray
set.join = set.merge
set.subtract = set.delete
set.union = set.merge

return set
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="512">
                <Properties>
                  <string name="Name">add</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezgwREU5NDA1LTUxQ0YtNDM1QS1BMjkwLUZENTI2QUI4NDUyRH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function add
  @within Set

  @param set { [T]: boolean } -- The set to add the value to.
  @param ... ...T -- The values to add.
  @return { [T]: boolean } -- The set with the values added.

  Adds values to a set.

  ```lua
  local set = { hello = true }

  local newSet = Add(set, "world") -- { hello = true, world = true }
  ```
]=]
local function add<T>(set: { [T]: boolean }, ...: T): { [T]: boolean }
	local result = {}

	for key, _ in pairs(set) do
		result[key] = true
	end

	for _, value in ipairs({ ... }) do
		result[value] = true
	end

	return result
end

return add
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="513">
                <Properties>
                  <string name="Name">copy</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezY0M0FDRjZBLTlGQjYtNEMzRC1BOUVGLUM4NzYyQkRENTg0N30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local copy = require(Sift.Dictionary.copy)

--[=[
  @function copy
  @within Set

  @param set { [T]: boolean } -- The set to copy.
  @return { [T]: boolean } -- A copy of the set.

  Creates a copy of a set.

  ```lua
  local set = { hello = true }

  local newSet = Copy(set) -- { hello = true }
  ```
]=]
return copy
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="514">
                <Properties>
                  <string name="Name">count</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezIzRTNCNjU4LTlDOTItNDZENi04OUJDLTU1REMwQ0E5RUY3Qn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)

--[=[
  @function count
  @within Set

  @param set { [T]: boolean } -- The set to count.
  @param predicate? (item: T, set: { [T]: boolean }) -> boolean? -- The predicate to use to count.
  @return number -- The number of items in the set.

  Counts the number of items in a set.

  ```lua
  local set = { hello = true, world = true }

  local count = Count(set) -- 2
  local count = Count(set, function(item)
    return item == "hello"
  end) -- 1
  ```
]=]
local function count<T>(set: { [T]: boolean }, predicate: ((item: T, set: { [T]: boolean }) -> boolean?)?): number
	local counter = 0

	predicate = if type(predicate) == "function" then predicate else Util.func.truthy

	for item, _ in pairs(set) do
		if predicate(item, set) then
			counter += 1
		end
	end

	return counter
end

return count
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="515">
                <Properties>
                  <string name="Name">delete</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezY2NThBOTkzLTMxRjEtNDUzNS1BMDM3LTc1RDU2NjQxQTUwQ30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function delete
  @within Set

  @param set { [T]: boolean } -- The set to delete from.
  @param ... ...T -- The values to delete.
  @return { [T]: boolean } -- The set with the values deleted.

  Deletes values from a set.

  Aliases: `subtract`

  ```lua
  local set = { hello = true, world = true }

  local newSet = Delete(set, "hello") -- { world = true }
  ```
]=]
local function delete<T>(set: { [T]: boolean }, ...: T): { [T]: boolean }
	local result = {}

	for key, _ in pairs(set) do
		result[key] = true
	end

	for _, value in ipairs({ ... }) do
		result[value] = nil
	end

	return result
end

return delete
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="516">
                <Properties>
                  <string name="Name">filter</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezU0MTk4NzRELUU0OTktNDNDMy05Q0FCLTgxNTIxNjcxRjg3OX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local Sift = script.Parent.Parent

local Util = require(Sift.Util)

--[=[
  @function filter
  @within Set

  @param set { [T]: boolean } -- The set to filter.
  @param predicate? (item: T, set: { [T]: boolean }) -> any -- The function to filter the set with.
  @return { [T]: boolean } -- The filtered set.

  Filters a set using a predicate. Any items that do not pass the predicate will be removed from the set.

  ```lua
  local set = { hello = true, world = true }

  local newSet = Filter(set, function(value)
    return value ~= "hello"
  end) -- { world = true }
  ```
]=]
local function filter<T>(set: { [T]: boolean }, predicate: ((T, { [T]: boolean }) -> any)?): { [T]: boolean }
	local result = {}

	predicate = if type(predicate) == "function" then predicate else Util.func.truthy

	for key, _ in pairs(set) do
		if predicate(key, set) then
			result[key] = true
		end
	end

	return result
end

return filter
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="517">
                <Properties>
                  <string name="Name">fromArray</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezQzNTQxNjc2LThFMzEtNEI5NC1CNUY2LUFCMkM0MDAxQkE2Nn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function fromArray
  @within Set

  @param array {T} -- The array to convert to a set.
  @return {[T]: boolean} -- The set.

  Converts an array to a set, where each item is mapped to true.
  Duplicate items are discarded.

  Aliases: `fromList`

  ```lua
  local array = { "hello", "world", "hello" }

  local set = FromArray(array) -- { hello = true, world = true }
  ```
]=]
local function fromArray<T>(array: { T }): { [T]: boolean }
	local result = table.create(#array)

	for _, value in ipairs(array) do
		result[value] = true
	end

	return result
end

return fromArray
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="518">
                <Properties>
                  <string name="Name">has</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezM0MzAwQTg0LTA4MEUtNEI5RC1BNEM1LTgyNTYyN0FENkI5QX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function has
  @within Set

  @param set { [T]: boolean } -- The set to check.
  @param value any -- The value to check for.
  @return boolean -- Whether the value is in the set.

  Checks whether a value is in a set.

  ```lua
  local set = { hello = true }

  local has = Has(set, "hello") -- true
  ```
]=]
local function has<T>(set: { [T]: boolean }, value: any): boolean
	return set[value] == true
end

return has
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="519">
                <Properties>
                  <string name="Name">intersection</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezFDQzZCOEQ5LUUzNDMtNDMwRi05MzUyLTlEQTJCOEM4NjA0N30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function intersection
  @within Set

  @param ... ...{ [any]: boolean } -- The sets to intersect.
  @return { [T]: boolean } -- The intersection of the sets.

  Creates the intersection of multiple sets. The intersection
  is when both sets have a value in common. Unmatched values
  are discarded.

  ```lua
  local set1 = { hello = true, world = true }
  local set2 = { world = true, universe = true }

  local intersection = Intersection(set1, set2) -- { world = true }
  ```
]=]
local function intersection<T>(...: { [any]: boolean }): { [T]: boolean }
	local setCount = select("#", ...)
	local firstSet = select(1, ...)

	local result = {}

	for key, _ in pairs(firstSet) do
		local intersects = true

		for index = 2, setCount do
			local set = select(index, ...)

			if set[key] ~= true then
				intersects = false
				break
			end
		end

		if intersects then
			result[key] = true
		end
	end

	return result
end

return intersection
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="520">
                <Properties>
                  <string name="Name">isSubset</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezdFMUY0MTkxLTAyQTUtNDc4Mi04REZCLTg2MEVGRDFGQTA4M30=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function isSubset
  @within Set

  @param subset { [any]: boolean } -- The subset to check.
  @param superset { [any]: boolean } -- The superset to check against.
  @return boolean -- Whether the subset is a subset of the superset.

  Checks whether a set is a subset of another set.

  ```lua
  local set = { hello = true, world = true }
  local subset = { hello = true }

  local isSubset = IsSubset(subset, set) -- true
  ```
]=]
local function isSubset(subset: { [any]: boolean }, superset: { [any]: boolean }): boolean
	for key, value in pairs(subset) do
		if superset[key] ~= value then
			return false
		end
	end

	return true
end

return isSubset
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="521">
                <Properties>
                  <string name="Name">isSuperset</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezU2ODBBNDExLTgyRUEtNEE2MS05QjA4LUM1RkMyQUQxMTA3NH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local isSubset = require(script.Parent.isSubset)

--[=[
  @function isSuperset
  @within Set

  @param superset { [any]: boolean } -- The superset to check.
  @param subset { [any]: boolean } -- The subset to check against.
  @return boolean -- Whether the superset is a superset of the subset.

  Checks whether a set is a superset of another set.

  ```lua
  local set = { hello = true, world = true }
  local subset = { hello = true }

  local isSuperset = IsSuperset(set, subset) -- true
  ```
]=]
local function isSuperset<any>(superset: { [any]: boolean }, subset: { [any]: boolean }): boolean
	return isSubset(subset, superset)
end

return isSuperset
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="522">
                <Properties>
                  <string name="Name">map</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0Q4QjIyMDlBLUJFRTAtNDgwQi1BMzlFLTZEOUFBODM5NkM5RH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function map
  @within Set

  @param set { [T]: boolean } -- The set to map.
  @param mapper (T, {[T]: boolean}) -> U -- The mapper function.
  @return {[U]: boolean} -- The mapped set.

  Iterates over a set, calling a mapper function for each item.

  ```lua
  local set = { hello = true, world = true }

  local mappedSet = Map(set, function(value)
    return value .. "!"
  end) -- { ["hello!"] = true, ["world!"] = true }
  ```
]=]
local function map<T, U>(set: { [T]: boolean }, mapper: (T, { [T]: boolean }) -> U): { [U]: boolean }
	local result = {}

	for key, _ in pairs(set) do
		local mappedKey = mapper(key, set)

		if mappedKey ~= nil then
			result[mappedKey] = true
		end
	end

	return result
end

return map
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="523">
                <Properties>
                  <string name="Name">merge</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezIzNjBENzRELTYyQTAtNDUwNS05OEQ3LTJDMUZGQjIzQTgxRn0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function merge
  @within Set

  @param ... ...any -- The sets to merge.
  @return { [T]: boolean } -- The merged set.

  Combines one or more sets into a single set.

  Aliases: `join`, `union`

  ```lua
  local set1 = { hello = true, world = true }
  local set2 = { cat = true, dog = true, hello = true }

  local merge = Merge(set1, set2) -- { hello = true, world = true, cat = true, dog = true }
  ```
]=]
local function merge<T>(...: any): { [T]: boolean }
	local result = {}

	for setIndex = 1, select("#", ...) do
		local set = select(setIndex, ...)

		if type(set) ~= "table" then
			continue
		end

		for key, _ in pairs(set) do
			result[key] = true
		end
	end

	return result
end

return merge
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="524">
                <Properties>
                  <string name="Name">toArray</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezI0NTZFRTdELTlDODMtNDZFMy1CODg5LThCQkUwRTY1N0E4NX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
--[=[
  @function toArray
  @within Set

  @param set { [T]: boolean } -- The set to convert to an array.
  @return {T} -- The array.

  Converts a set to an array.

  ```lua
  local set = { hello = true, world = true }

  local array = ToArray(set) -- { "hello", "world" }
  ```
]=]
local function toArray<T>(set: { [T]: boolean }): { T }
	local result = {}

	for key, _ in pairs(set) do
		table.insert(result, key)
	end

	return result
end

return toArray
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="525">
              <Properties>
                <string name="Name">Types</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[ezIzMTVDM0U2LThBMkMtNEIyOS1BNDMxLUUxRDQ3OTVDNzk1Q30=]]></BinaryString>
                <string name="Source"><![CDATA[local None = require(script.Parent.None)

--[=[
  @type None None
  @within Sift
]=]
export type None = typeof(None)
export type Dictionary<K, V> = { [K]: V }
export type Array<T> = Dictionary<number, T>
export type Set<T> = Dictionary<T, boolean>
export type Table = Dictionary<any, any>

export type AnyDictionary = Dictionary<any, any>

return nil
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="526">
              <Properties>
                <string name="Name">Util</string>
                <BinaryString name="AttributesSerialize"></BinaryString>
                <Content name="LinkedSource">
                  <null>
                  </null>
                </Content>
                <BinaryString name="ScriptGuid"><![CDATA[e0JFMjQ3NDhDLTM4NUEtNDkzNS1CQTE1LTdGN0I4MDVFRkQ3MH0=]]></BinaryString>
                <string name="Source"><![CDATA[return {
	equalObjects = require(script.equalObjects),
	func = require(script.func),
	isEmpty = require(script.isEmpty),
}
]]></string>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"></BinaryString>
              </Properties>
              <Item class="ModuleScript" referent="527">
                <Properties>
                  <string name="Name">equalObjects</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezQ5NEM2NkNFLTkzMjMtNEY3Ny1CMDRBLUYxNkMzMjFGNEFGMH0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local _T = require(script.Parent.Parent.Types)

--[=[
	@function equalObjects
	@within Sift

	@param ... ...table -- The tables to compare.
	@return boolean -- Whether or not the tables are equal.

	Compares two or more tables to see if they are equal.

	```lua
	local a = { hello = "world" }
	local b = { hello = "world" }

	local equal = EqualObjects(a, b) -- true
	```
]=]
local function equalObjects(...: _T.Table): boolean
	local firstItem = select(1, ...)

	for i = 2, select("#", ...) do
		if firstItem ~= select(i, ...) then
			return false
		end
	end

	return true
end

return equalObjects
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="528">
                <Properties>
                  <string name="Name">func</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[ezFBMEIzMDUxLTNCM0MtNEE5MS1BRDY2LURFMjVEQjQ1MzVBOH0=]]></BinaryString>
                  <string name="Source"><![CDATA[local function truthy()
	return true
end

local function noop() end

local function returned(...)
	return ...
end

return {
	truthy = truthy,
	noop = noop,
	returned = returned,
}
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="529">
                <Properties>
                  <string name="Name">isEmpty</string>
                  <BinaryString name="AttributesSerialize"></BinaryString>
                  <Content name="LinkedSource">
                    <null>
                    </null>
                  </Content>
                  <BinaryString name="ScriptGuid"><![CDATA[e0U5QThCQTM3LTk0MUQtNDI3OS05RkQ0LUE3OEVDQUMzQjMwNX0=]]></BinaryString>
                  <string name="Source"><![CDATA[--!strict
local _T = require(script.Parent.Parent.Types)

--[=[
  @function isEmpty
  @within Sift
  @since v0.0.1

  @param table table -- The table to check.
  @return boolean -- Whether or not the table is empty.

  Checks whether or not a table is empty.

  ```lua
  local a = {}
  local b = { hello = "world" }

  local value = isEmpty(a) -- true
  local value = isEmpty(b) -- false
  ```
]=]
local function isEmpty(table: _T.Table): boolean
	return next(table) == nil
end

return isEmpty
]]></string>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"></BinaryString>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="530">
        <Properties>
          <string name="Name">Symbol</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[ezNBNTY3NjQ4LUU3RTItNDdDNC05NTZCLTUwMEQxMEQyNzMyNX0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_symbol@2.0.0"]["symbol"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="531">
        <Properties>
          <string name="Name">sift</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <Content name="LinkedSource">
            <null>
            </null>
          </Content>
          <BinaryString name="ScriptGuid"><![CDATA[e0JFMjc1Rjc2LTcwRjMtNDhCMS04MzQyLUQwODUyNDZFRTgwNn0=]]></BinaryString>
          <string name="Source"><![CDATA[return require(script.Parent._Index["csqrl_sift@0.0.2"]["sift"])
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="LuaWebService" referent="532">
    <Properties>
      <string name="Name">Instance</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="ProcessInstancePhysicsService" referent="533">
    <Properties>
      <string name="Name">ProcessInstancePhysicsService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Lighting" referent="534">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0.27450982</R>
        <G>0.27450982</G>
        <B>0.27450982</B>
      </Color3>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <float name="Brightness">3</float>
      <Color3 name="ColorShift_Bottom">
        <R>0</R>
        <G>0</G>
        <B>0</B>
      </Color3>
      <Color3 name="ColorShift_Top">
        <R>0</R>
        <G>0</G>
        <B>0</B>
      </Color3>
      <float name="EnvironmentDiffuseScale">1</float>
      <float name="EnvironmentSpecularScale">1</float>
      <float name="ExposureCompensation">0</float>
      <Color3 name="FogColor">
        <R>0.75294125</R>
        <G>0.75294125</G>
        <B>0.75294125</B>
      </Color3>
      <float name="FogEnd">100000</float>
      <float name="FogStart">0</float>
      <float name="GeographicLatitude">0</float>
      <bool name="GlobalShadows">true</bool>
      <Color3 name="OutdoorAmbient">
        <R>0.27450982</R>
        <G>0.27450982</G>
        <B>0.27450982</B>
      </Color3>
      <bool name="Outlines">false</bool>
      <float name="ShadowSoftness">0.2</float>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
      <token name="Technology">3</token>
      <string name="TimeOfDay">14:30:00</string>
    </Properties>
    <Item class="Sky" referent="535">
      <Properties>
        <string name="Name">Sky</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <bool name="CelestialBodiesShown">true</bool>
        <float name="MoonAngularSize">11</float>
        <Content name="MoonTextureId">
          <url>rbxassetid://6444320592</url>
        </Content>
        <Content name="SkyboxBk">
          <url>rbxassetid://6444884337</url>
        </Content>
        <Content name="SkyboxDn">
          <url>rbxassetid://6444884785</url>
        </Content>
        <Content name="SkyboxFt">
          <url>rbxassetid://6444884337</url>
        </Content>
        <Content name="SkyboxLf">
          <url>rbxassetid://6444884337</url>
        </Content>
        <Content name="SkyboxRt">
          <url>rbxassetid://6444884337</url>
        </Content>
        <Content name="SkyboxUp">
          <url>rbxassetid://6412503613</url>
        </Content>
        <int64 name="SourceAssetId">332039975</int64>
        <int name="StarCount">3000</int>
        <float name="SunAngularSize">11</float>
        <Content name="SunTextureId">
          <url>rbxassetid://6196665106</url>
        </Content>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
    <Item class="SunRaysEffect" referent="536">
      <Properties>
        <string name="Name">SunRays</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <bool name="Enabled">true</bool>
        <float name="Intensity">0.01</float>
        <int64 name="SourceAssetId">-1</int64>
        <float name="Spread">0.1</float>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
    <Item class="Atmosphere" referent="537">
      <Properties>
        <string name="Name">Atmosphere</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <Color3 name="Color">
          <R>0.78039217</R>
          <G>0.78039217</G>
          <B>0.78039217</B>
        </Color3>
        <Color3 name="Decay">
          <R>0.41568628</R>
          <G>0.4392157</G>
          <B>0.49019608</B>
        </Color3>
        <float name="Density">0.3</float>
        <float name="Glare">0</float>
        <float name="Haze">0</float>
        <float name="Offset">0.25</float>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
    <Item class="BloomEffect" referent="538">
      <Properties>
        <string name="Name">Bloom</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <bool name="Enabled">true</bool>
        <float name="Intensity">1</float>
        <float name="Size">24</float>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
        <float name="Threshold">2</float>
      </Properties>
    </Item>
    <Item class="DepthOfFieldEffect" referent="539">
      <Properties>
        <string name="Name">DepthOfField</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <bool name="Enabled">false</bool>
        <float name="FarIntensity">0.1</float>
        <float name="FocusDistance">0.05</float>
        <float name="InFocusRadius">30</float>
        <float name="NearIntensity">0.75</float>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
  </Item>
  <Item class="LodDataService" referent="540">
    <Properties>
      <string name="Name">Instance</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Instance" referent="541">
    <Properties>
      <string name="Name">FilteredSelection</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="DataStoreService" referent="542">
    <Properties>
      <string name="Name">DataStoreService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="AutomaticRetry">true</bool>
      <bool name="LegacyNamingScheme">false</bool>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="HttpService" referent="543">
    <Properties>
      <string name="Name">HttpService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="HttpEnabled">false</bool>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="LanguageService" referent="544">
    <Properties>
      <string name="Name">LanguageService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="ProximityPromptService" referent="545">
    <Properties>
      <string name="Name">ProximityPromptService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="Enabled">true</bool>
      <int name="MaxPromptsVisible">16</int>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Teams" referent="546">
    <Properties>
      <string name="Name">Teams</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="TestService" referent="547">
    <Properties>
      <string name="Name">TestService</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="AutoRuns">true</bool>
      <string name="Description"></string>
      <bool name="ExecuteWithStudioRun">false</bool>
      <bool name="Is30FpsThrottleEnabled">true</bool>
      <bool name="IsPhysicsEnvironmentalThrottled">true</bool>
      <bool name="IsSleepAllowed">true</bool>
      <int name="NumberOfPlayers">0</int>
      <double name="SimulateSecondsLag">0</double>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
      <double name="Timeout">10</double>
    </Properties>
  </Item>
  <Item class="VirtualInputManager" referent="548">
    <Properties>
      <string name="Name">VirtualInputManager</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Instance" referent="549">
    <Properties>
      <string name="Name">FilteredSelection</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Instance" referent="550">
    <Properties>
      <string name="Name">FilteredSelection</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <Item class="Instance" referent="551">
    <Properties>
      <string name="Name">FilteredSelection</string>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
    </Properties>
  </Item>
  <SharedStrings>
    <SharedString md5="rxNJufX5oaagQE3qNtzJSQ=="></SharedString>
  </SharedStrings>
</roblox>